/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/renderer.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../build/oss-experimental/react-debug-tools/cjs/react-debug-tools.development.js":
/*!**************************************************************************************************************!*\
  !*** /home/pomber/p/dev/react/build/oss-experimental/react-debug-tools/cjs/react-debug-tools.development.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React vundefined\n * react-debug-tools.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var _assign = __webpack_require__(/*! object-assign */ \"../../node_modules/object-assign/index.js\");\n\n    var ErrorStackParser = __webpack_require__(/*! error-stack-parser */ \"../../node_modules/error-stack-parser/error-stack-parser.js\");\n\n    var React = __webpack_require__(/*! react */ \"../../build/oss-experimental/react/index.js\");\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    var FunctionComponent = 0;\n    var ContextProvider = 10;\n    var ForwardRef = 11;\n    var SimpleMemoComponent = 15;\n    var hookLog = []; // Primitives\n\n    var primitiveStackCache = null;\n\n    function getPrimitiveStackCache() {\n      // This initializes a cache of all primitive hooks so that the top\n      // most stack frames added by calling the primitive hook can be removed.\n      if (primitiveStackCache === null) {\n        var cache = new Map();\n        var readHookLog;\n\n        try {\n          // Use all hooks here to add them to the hook log.\n          Dispatcher.useContext({\n            _currentValue: null\n          });\n          Dispatcher.useState(null);\n          Dispatcher.useReducer(function (s, a) {\n            return s;\n          }, null);\n          Dispatcher.useRef(null);\n\n          if (typeof Dispatcher.useCacheRefresh === 'function') {\n            // This type check is for Flow only.\n            Dispatcher.useCacheRefresh();\n          }\n\n          Dispatcher.useLayoutEffect(function () {});\n          Dispatcher.useInsertionEffect(function () {});\n          Dispatcher.useEffect(function () {});\n          Dispatcher.useImperativeHandle(undefined, function () {\n            return null;\n          });\n          Dispatcher.useDebugValue(null);\n          Dispatcher.useCallback(function () {});\n          Dispatcher.useMemo(function () {\n            return null;\n          });\n        } finally {\n          readHookLog = hookLog;\n          hookLog = [];\n        }\n\n        for (var i = 0; i < readHookLog.length; i++) {\n          var hook = readHookLog[i];\n          cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));\n        }\n\n        primitiveStackCache = cache;\n      }\n\n      return primitiveStackCache;\n    }\n\n    var currentHook = null;\n\n    function nextHook() {\n      var hook = currentHook;\n\n      if (hook !== null) {\n        currentHook = hook.next;\n      }\n\n      return hook;\n    }\n\n    function getCacheForType(resourceType) {\n      throw new Error('Not implemented.');\n    }\n\n    function readContext(context) {\n      // For now we don't expose readContext usage in the hooks debugging info.\n      return context._currentValue;\n    }\n\n    function useContext(context) {\n      hookLog.push({\n        primitive: 'Context',\n        stackError: new Error(),\n        value: context._currentValue\n      });\n      return context._currentValue;\n    }\n\n    function useState(initialState) {\n      var hook = nextHook();\n      var state = hook !== null ? hook.memoizedState : typeof initialState === 'function' ? // $FlowFixMe: Flow doesn't like mixed types\n      initialState() : initialState;\n      hookLog.push({\n        primitive: 'State',\n        stackError: new Error(),\n        value: state\n      });\n      return [state, function (action) {}];\n    }\n\n    function useReducer(reducer, initialArg, init) {\n      var hook = nextHook();\n      var state;\n\n      if (hook !== null) {\n        state = hook.memoizedState;\n      } else {\n        state = init !== undefined ? init(initialArg) : initialArg;\n      }\n\n      hookLog.push({\n        primitive: 'Reducer',\n        stackError: new Error(),\n        value: state\n      });\n      return [state, function (action) {}];\n    }\n\n    function useRef(initialValue) {\n      var hook = nextHook();\n      var ref = hook !== null ? hook.memoizedState : {\n        current: initialValue\n      };\n      hookLog.push({\n        primitive: 'Ref',\n        stackError: new Error(),\n        value: ref.current\n      });\n      return ref;\n    }\n\n    function useCacheRefresh() {\n      var hook = nextHook();\n      hookLog.push({\n        primitive: 'CacheRefresh',\n        stackError: new Error(),\n        value: hook !== null ? hook.memoizedState : function refresh() {}\n      });\n      return function () {};\n    }\n\n    function useLayoutEffect(create, inputs) {\n      nextHook();\n      hookLog.push({\n        primitive: 'LayoutEffect',\n        stackError: new Error(),\n        value: create\n      });\n    }\n\n    function useInsertionEffect(create, inputs) {\n      nextHook();\n      hookLog.push({\n        primitive: 'InsertionEffect',\n        stackError: new Error(),\n        value: create\n      });\n    }\n\n    function useEffect(create, inputs) {\n      nextHook();\n      hookLog.push({\n        primitive: 'Effect',\n        stackError: new Error(),\n        value: create\n      });\n    }\n\n    function useImperativeHandle(ref, create, inputs) {\n      nextHook(); // We don't actually store the instance anywhere if there is no ref callback\n      // and if there is a ref callback it might not store it but if it does we\n      // have no way of knowing where. So let's only enable introspection of the\n      // ref itself if it is using the object form.\n\n      var instance = undefined;\n\n      if (ref !== null && typeof ref === 'object') {\n        instance = ref.current;\n      }\n\n      hookLog.push({\n        primitive: 'ImperativeHandle',\n        stackError: new Error(),\n        value: instance\n      });\n    }\n\n    function useDebugValue(value, formatterFn) {\n      hookLog.push({\n        primitive: 'DebugValue',\n        stackError: new Error(),\n        value: typeof formatterFn === 'function' ? formatterFn(value) : value\n      });\n    }\n\n    function useCallback(callback, inputs) {\n      var hook = nextHook();\n      hookLog.push({\n        primitive: 'Callback',\n        stackError: new Error(),\n        value: hook !== null ? hook.memoizedState[0] : callback\n      });\n      return callback;\n    }\n\n    function useMemo(nextCreate, inputs) {\n      var hook = nextHook();\n      var value = hook !== null ? hook.memoizedState[0] : nextCreate();\n      hookLog.push({\n        primitive: 'Memo',\n        stackError: new Error(),\n        value: value\n      });\n      return value;\n    }\n\n    function useMutableSource(source, getSnapshot, subscribe) {\n      // useMutableSource() composes multiple hooks internally.\n      // Advance the current hook index the same number of times\n      // so that subsequent hooks have the right memoized state.\n      nextHook(); // MutableSource\n\n      nextHook(); // State\n\n      nextHook(); // Effect\n\n      nextHook(); // Effect\n\n      var value = getSnapshot(source._source);\n      hookLog.push({\n        primitive: 'MutableSource',\n        stackError: new Error(),\n        value: value\n      });\n      return value;\n    }\n\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      // useSyncExternalStore() composes multiple hooks internally.\n      // Advance the current hook index the same number of times\n      // so that subsequent hooks have the right memoized state.\n      nextHook(); // SyncExternalStore\n\n      nextHook(); // Effect\n\n      var value = getSnapshot();\n      hookLog.push({\n        primitive: 'SyncExternalStore',\n        stackError: new Error(),\n        value: value\n      });\n      return value;\n    }\n\n    function useTransition() {\n      // useTransition() composes multiple hooks internally.\n      // Advance the current hook index the same number of times\n      // so that subsequent hooks have the right memoized state.\n      nextHook(); // State\n\n      nextHook(); // Callback\n\n      hookLog.push({\n        primitive: 'Transition',\n        stackError: new Error(),\n        value: undefined\n      });\n      return [false, function (callback) {}];\n    }\n\n    function useDeferredValue(value) {\n      // useDeferredValue() composes multiple hooks internally.\n      // Advance the current hook index the same number of times\n      // so that subsequent hooks have the right memoized state.\n      nextHook(); // State\n\n      nextHook(); // Effect\n\n      hookLog.push({\n        primitive: 'DeferredValue',\n        stackError: new Error(),\n        value: value\n      });\n      return value;\n    }\n\n    function useId() {\n      var hook = nextHook();\n      var id = hook !== null ? hook.memoizedState : '';\n      hookLog.push({\n        primitive: 'Id',\n        stackError: new Error(),\n        value: id\n      });\n      return id;\n    }\n\n    var Dispatcher = {\n      getCacheForType: getCacheForType,\n      readContext: readContext,\n      useCacheRefresh: useCacheRefresh,\n      useCallback: useCallback,\n      useContext: useContext,\n      useEffect: useEffect,\n      useImperativeHandle: useImperativeHandle,\n      useDebugValue: useDebugValue,\n      useLayoutEffect: useLayoutEffect,\n      useInsertionEffect: useInsertionEffect,\n      useMemo: useMemo,\n      useReducer: useReducer,\n      useRef: useRef,\n      useState: useState,\n      useTransition: useTransition,\n      useMutableSource: useMutableSource,\n      useSyncExternalStore: useSyncExternalStore,\n      useDeferredValue: useDeferredValue,\n      useId: useId\n    }; // Inspect\n    // Don't assume\n    //\n    // We can't assume that stack frames are nth steps away from anything.\n    // E.g. we can't assume that the root call shares all frames with the stack\n    // of a hook call. A simple way to demonstrate this is wrapping `new Error()`\n    // in a wrapper constructor like a polyfill. That'll add an extra frame.\n    // Similar things can happen with the call to the dispatcher. The top frame\n    // may not be the primitive. Likewise the primitive can have fewer stack frames\n    // such as when a call to useState got inlined to use dispatcher.useState.\n    //\n    // We also can't assume that the last frame of the root call is the same\n    // frame as the last frame of the hook call because long stack traces can be\n    // truncated to a stack trace limit.\n\n    var mostLikelyAncestorIndex = 0;\n\n    function findSharedIndex(hookStack, rootStack, rootIndex) {\n      var source = rootStack[rootIndex].source;\n\n      hookSearch: for (var i = 0; i < hookStack.length; i++) {\n        if (hookStack[i].source === source) {\n          // This looks like a match. Validate that the rest of both stack match up.\n          for (var a = rootIndex + 1, b = i + 1; a < rootStack.length && b < hookStack.length; a++, b++) {\n            if (hookStack[b].source !== rootStack[a].source) {\n              // If not, give up and try a different match.\n              continue hookSearch;\n            }\n          }\n\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    function findCommonAncestorIndex(rootStack, hookStack) {\n      var rootIndex = findSharedIndex(hookStack, rootStack, mostLikelyAncestorIndex);\n\n      if (rootIndex !== -1) {\n        return rootIndex;\n      } // If the most likely one wasn't a hit, try any other frame to see if it is shared.\n      // If that takes more than 5 frames, something probably went wrong.\n\n\n      for (var i = 0; i < rootStack.length && i < 5; i++) {\n        rootIndex = findSharedIndex(hookStack, rootStack, i);\n\n        if (rootIndex !== -1) {\n          mostLikelyAncestorIndex = i;\n          return rootIndex;\n        }\n      }\n\n      return -1;\n    }\n\n    function isReactWrapper(functionName, primitiveName) {\n      if (!functionName) {\n        return false;\n      }\n\n      var expectedPrimitiveName = 'use' + primitiveName;\n\n      if (functionName.length < expectedPrimitiveName.length) {\n        return false;\n      }\n\n      return functionName.lastIndexOf(expectedPrimitiveName) === functionName.length - expectedPrimitiveName.length;\n    }\n\n    function findPrimitiveIndex(hookStack, hook) {\n      var stackCache = getPrimitiveStackCache();\n      var primitiveStack = stackCache.get(hook.primitive);\n\n      if (primitiveStack === undefined) {\n        return -1;\n      }\n\n      for (var i = 0; i < primitiveStack.length && i < hookStack.length; i++) {\n        if (primitiveStack[i].source !== hookStack[i].source) {\n          // If the next two frames are functions called `useX` then we assume that they're part of the\n          // wrappers that the React packager or other packages adds around the dispatcher.\n          if (i < hookStack.length - 1 && isReactWrapper(hookStack[i].functionName, hook.primitive)) {\n            i++;\n          }\n\n          if (i < hookStack.length - 1 && isReactWrapper(hookStack[i].functionName, hook.primitive)) {\n            i++;\n          }\n\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    function parseTrimmedStack(rootStack, hook) {\n      // Get the stack trace between the primitive hook function and\n      // the root function call. I.e. the stack frames of custom hooks.\n      var hookStack = ErrorStackParser.parse(hook.stackError);\n      var rootIndex = findCommonAncestorIndex(rootStack, hookStack);\n      var primitiveIndex = findPrimitiveIndex(hookStack, hook);\n\n      if (rootIndex === -1 || primitiveIndex === -1 || rootIndex - primitiveIndex < 2) {\n        // Something went wrong. Give up.\n        return null;\n      }\n\n      return hookStack.slice(primitiveIndex, rootIndex - 1);\n    }\n\n    function parseCustomHookName(functionName) {\n      if (!functionName) {\n        return '';\n      }\n\n      var startIndex = functionName.lastIndexOf('.');\n\n      if (startIndex === -1) {\n        startIndex = 0;\n      }\n\n      if (functionName.substr(startIndex, 3) === 'use') {\n        startIndex += 3;\n      }\n\n      return functionName.substr(startIndex);\n    }\n\n    function buildTree(rootStack, readHookLog, includeHooksSource) {\n      var rootChildren = [];\n      var prevStack = null;\n      var levelChildren = rootChildren;\n      var nativeHookID = 0;\n      var stackOfChildren = [];\n\n      for (var i = 0; i < readHookLog.length; i++) {\n        var hook = readHookLog[i];\n        var stack = parseTrimmedStack(rootStack, hook);\n\n        if (stack !== null) {\n          // Note: The indices 0 <= n < length-1 will contain the names.\n          // The indices 1 <= n < length will contain the source locations.\n          // That's why we get the name from n - 1 and don't check the source\n          // of index 0.\n          var commonSteps = 0;\n\n          if (prevStack !== null) {\n            // Compare the current level's stack to the new stack.\n            while (commonSteps < stack.length && commonSteps < prevStack.length) {\n              var stackSource = stack[stack.length - commonSteps - 1].source;\n              var prevSource = prevStack[prevStack.length - commonSteps - 1].source;\n\n              if (stackSource !== prevSource) {\n                break;\n              }\n\n              commonSteps++;\n            } // Pop back the stack as many steps as were not common.\n\n\n            for (var j = prevStack.length - 1; j > commonSteps; j--) {\n              levelChildren = stackOfChildren.pop();\n            }\n          } // The remaining part of the new stack are custom hooks. Push them\n          // to the tree.\n\n\n          for (var _j = stack.length - commonSteps - 1; _j >= 1; _j--) {\n            var children = [];\n            var stackFrame = stack[_j];\n            var _levelChild = {\n              id: null,\n              isStateEditable: false,\n              name: parseCustomHookName(stack[_j - 1].functionName),\n              value: undefined,\n              subHooks: children\n            };\n\n            if (includeHooksSource) {\n              _levelChild.hookSource = {\n                lineNumber: stackFrame.lineNumber,\n                columnNumber: stackFrame.columnNumber,\n                functionName: stackFrame.functionName,\n                fileName: stackFrame.fileName\n              };\n            }\n\n            levelChildren.push(_levelChild);\n            stackOfChildren.push(levelChildren);\n            levelChildren = children;\n          }\n\n          prevStack = stack;\n        }\n\n        var primitive = hook.primitive; // For now, the \"id\" of stateful hooks is just the stateful hook index.\n        // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).\n\n        var id = primitive === 'Context' || primitive === 'DebugValue' ? null : nativeHookID++; // For the time being, only State and Reducer hooks support runtime overrides.\n\n        var isStateEditable = primitive === 'Reducer' || primitive === 'State';\n        var levelChild = {\n          id: id,\n          isStateEditable: isStateEditable,\n          name: primitive,\n          value: hook.value,\n          subHooks: []\n        };\n\n        if (includeHooksSource) {\n          var hookSource = {\n            lineNumber: null,\n            functionName: null,\n            fileName: null,\n            columnNumber: null\n          };\n\n          if (stack && stack.length >= 1) {\n            var _stackFrame = stack[0];\n            hookSource.lineNumber = _stackFrame.lineNumber;\n            hookSource.functionName = _stackFrame.functionName;\n            hookSource.fileName = _stackFrame.fileName;\n            hookSource.columnNumber = _stackFrame.columnNumber;\n          }\n\n          levelChild.hookSource = hookSource;\n        }\n\n        levelChildren.push(levelChild);\n      } // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.\n\n\n      processDebugValues(rootChildren, null);\n      return rootChildren;\n    } // Custom hooks support user-configurable labels (via the special useDebugValue() hook).\n    // That hook adds user-provided values to the hooks tree,\n    // but these values aren't intended to appear alongside of the other hooks.\n    // Instead they should be attributed to their parent custom hook.\n    // This method walks the tree and assigns debug values to their custom hook owners.\n\n\n    function processDebugValues(hooksTree, parentHooksNode) {\n      var debugValueHooksNodes = [];\n\n      for (var i = 0; i < hooksTree.length; i++) {\n        var hooksNode = hooksTree[i];\n\n        if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {\n          hooksTree.splice(i, 1);\n          i--;\n          debugValueHooksNodes.push(hooksNode);\n        } else {\n          processDebugValues(hooksNode.subHooks, hooksNode);\n        }\n      } // Bubble debug value labels to their custom hook owner.\n      // If there is no parent hook, just ignore them for now.\n      // (We may warn about this in the future.)\n\n\n      if (parentHooksNode !== null) {\n        if (debugValueHooksNodes.length === 1) {\n          parentHooksNode.value = debugValueHooksNodes[0].value;\n        } else if (debugValueHooksNodes.length > 1) {\n          parentHooksNode.value = debugValueHooksNodes.map(function (_ref) {\n            var value = _ref.value;\n            return value;\n          });\n        }\n      }\n    }\n\n    function inspectHooks(renderFunction, props, currentDispatcher) {\n      var includeHooksSource = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; // DevTools will pass the current renderer's injected dispatcher.\n      // Other apps might compile debug hooks as part of their app though.\n\n      if (currentDispatcher == null) {\n        currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n      }\n\n      var previousDispatcher = currentDispatcher.current;\n      var readHookLog;\n      currentDispatcher.current = Dispatcher;\n      var ancestorStackError;\n\n      try {\n        ancestorStackError = new Error();\n        renderFunction(props);\n      } finally {\n        readHookLog = hookLog;\n        hookLog = [];\n        currentDispatcher.current = previousDispatcher;\n      }\n\n      var rootStack = ErrorStackParser.parse(ancestorStackError);\n      return buildTree(rootStack, readHookLog, includeHooksSource);\n    }\n\n    function setupContexts(contextMap, fiber) {\n      var current = fiber;\n\n      while (current) {\n        if (current.tag === ContextProvider) {\n          var providerType = current.type;\n          var context = providerType._context;\n\n          if (!contextMap.has(context)) {\n            // Store the current value that we're going to restore later.\n            contextMap.set(context, context._currentValue); // Set the inner most provider value on the context.\n\n            context._currentValue = current.memoizedProps.value;\n          }\n        }\n\n        current = current.return;\n      }\n    }\n\n    function restoreContexts(contextMap) {\n      contextMap.forEach(function (value, context) {\n        return context._currentValue = value;\n      });\n    }\n\n    function inspectHooksOfForwardRef(renderFunction, props, ref, currentDispatcher, includeHooksSource) {\n      var previousDispatcher = currentDispatcher.current;\n      var readHookLog;\n      currentDispatcher.current = Dispatcher;\n      var ancestorStackError;\n\n      try {\n        ancestorStackError = new Error();\n        renderFunction(props, ref);\n      } finally {\n        readHookLog = hookLog;\n        hookLog = [];\n        currentDispatcher.current = previousDispatcher;\n      }\n\n      var rootStack = ErrorStackParser.parse(ancestorStackError);\n      return buildTree(rootStack, readHookLog, includeHooksSource);\n    }\n\n    function resolveDefaultProps(Component, baseProps) {\n      if (Component && Component.defaultProps) {\n        // Resolve default props. Taken from ReactElement\n        var props = _assign({}, baseProps);\n\n        var defaultProps = Component.defaultProps;\n\n        for (var propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n\n        return props;\n      }\n\n      return baseProps;\n    }\n\n    function inspectHooksOfFiber(fiber, currentDispatcher) {\n      var includeHooksSource = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // DevTools will pass the current renderer's injected dispatcher.\n      // Other apps might compile debug hooks as part of their app though.\n\n      if (currentDispatcher == null) {\n        currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n      }\n\n      if (fiber.tag !== FunctionComponent && fiber.tag !== SimpleMemoComponent && fiber.tag !== ForwardRef) {\n        throw new Error('Unknown Fiber. Needs to be a function component to inspect hooks.');\n      } // Warm up the cache so that it doesn't consume the currentHook.\n\n\n      getPrimitiveStackCache();\n      var type = fiber.type;\n      var props = fiber.memoizedProps;\n\n      if (type !== fiber.elementType) {\n        props = resolveDefaultProps(type, props);\n      } // Set up the current hook so that we can step through and read the\n      // current state from them.\n\n\n      currentHook = fiber.memoizedState;\n      var contextMap = new Map();\n\n      try {\n        setupContexts(contextMap, fiber);\n\n        if (fiber.tag === ForwardRef) {\n          return inspectHooksOfForwardRef(type.render, props, fiber.ref, currentDispatcher, includeHooksSource);\n        }\n\n        return inspectHooks(type, props, currentDispatcher, includeHooksSource);\n      } finally {\n        currentHook = null;\n        restoreContexts(contextMap);\n      }\n    }\n\n    exports.inspectHooks = inspectHooks;\n    exports.inspectHooksOfFiber = inspectHooksOfFiber;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC1kZWJ1Zy10b29scy9janMvcmVhY3QtZGVidWctdG9vbHMuZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvcG9tYmVyL3AvZGV2L3JlYWN0L2J1aWxkL29zcy1leHBlcmltZW50YWwvcmVhY3QtZGVidWctdG9vbHMvY2pzL3JlYWN0LWRlYnVnLXRvb2xzLmRldmVsb3BtZW50LmpzPzJkMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHZ1bmRlZmluZWRcbiAqIHJlYWN0LWRlYnVnLXRvb2xzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgRXJyb3JTdGFja1BhcnNlciA9IHJlcXVpcmUoJ2Vycm9yLXN0YWNrLXBhcnNlcicpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTA7XG52YXIgRm9yd2FyZFJlZiA9IDExO1xudmFyIFNpbXBsZU1lbW9Db21wb25lbnQgPSAxNTtcblxudmFyIGhvb2tMb2cgPSBbXTsgLy8gUHJpbWl0aXZlc1xuXG52YXIgcHJpbWl0aXZlU3RhY2tDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldFByaW1pdGl2ZVN0YWNrQ2FjaGUoKSB7XG4gIC8vIFRoaXMgaW5pdGlhbGl6ZXMgYSBjYWNoZSBvZiBhbGwgcHJpbWl0aXZlIGhvb2tzIHNvIHRoYXQgdGhlIHRvcFxuICAvLyBtb3N0IHN0YWNrIGZyYW1lcyBhZGRlZCBieSBjYWxsaW5nIHRoZSBwcmltaXRpdmUgaG9vayBjYW4gYmUgcmVtb3ZlZC5cbiAgaWYgKHByaW1pdGl2ZVN0YWNrQ2FjaGUgPT09IG51bGwpIHtcbiAgICB2YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIHJlYWRIb29rTG9nO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBhbGwgaG9va3MgaGVyZSB0byBhZGQgdGhlbSB0byB0aGUgaG9vayBsb2cuXG4gICAgICBEaXNwYXRjaGVyLnVzZUNvbnRleHQoe1xuICAgICAgICBfY3VycmVudFZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIERpc3BhdGNoZXIudXNlU3RhdGUobnVsbCk7XG4gICAgICBEaXNwYXRjaGVyLnVzZVJlZHVjZXIoZnVuY3Rpb24gKHMsIGEpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9LCBudWxsKTtcbiAgICAgIERpc3BhdGNoZXIudXNlUmVmKG51bGwpO1xuXG4gICAgICBpZiAodHlwZW9mIERpc3BhdGNoZXIudXNlQ2FjaGVSZWZyZXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRoaXMgdHlwZSBjaGVjayBpcyBmb3IgRmxvdyBvbmx5LlxuICAgICAgICBEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCgpO1xuICAgICAgfVxuXG4gICAgICBEaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICBEaXNwYXRjaGVyLnVzZUluc2VydGlvbkVmZmVjdChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICBEaXNwYXRjaGVyLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICBEaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUodW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgICBEaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUobnVsbCk7XG4gICAgICBEaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIERpc3BhdGNoZXIudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlYWRIb29rTG9nID0gaG9va0xvZztcbiAgICAgIGhvb2tMb2cgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWRIb29rTG9nLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaG9vayA9IHJlYWRIb29rTG9nW2ldO1xuICAgICAgY2FjaGUuc2V0KGhvb2sucHJpbWl0aXZlLCBFcnJvclN0YWNrUGFyc2VyLnBhcnNlKGhvb2suc3RhY2tFcnJvcikpO1xuICAgIH1cblxuICAgIHByaW1pdGl2ZVN0YWNrQ2FjaGUgPSBjYWNoZTtcbiAgfVxuXG4gIHJldHVybiBwcmltaXRpdmVTdGFja0NhY2hlO1xufVxuXG52YXIgY3VycmVudEhvb2sgPSBudWxsO1xuXG5mdW5jdGlvbiBuZXh0SG9vaygpIHtcbiAgdmFyIGhvb2sgPSBjdXJyZW50SG9vaztcblxuICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRIb29rID0gaG9vay5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIGhvb2s7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlRm9yVHlwZShyZXNvdXJjZVR5cGUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgLy8gRm9yIG5vdyB3ZSBkb24ndCBleHBvc2UgcmVhZENvbnRleHQgdXNhZ2UgaW4gdGhlIGhvb2tzIGRlYnVnZ2luZyBpbmZvLlxuICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQpIHtcbiAgaG9va0xvZy5wdXNoKHtcbiAgICBwcmltaXRpdmU6ICdDb250ZXh0JyxcbiAgICBzdGFja0Vycm9yOiBuZXcgRXJyb3IoKSxcbiAgICB2YWx1ZTogY29udGV4dC5fY3VycmVudFZhbHVlXG4gIH0pO1xuICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGhvb2sgPSBuZXh0SG9vaygpO1xuICB2YXIgc3RhdGUgPSBob29rICE9PSBudWxsID8gaG9vay5tZW1vaXplZFN0YXRlIDogdHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIGluaXRpYWxTdGF0ZSgpIDogaW5pdGlhbFN0YXRlO1xuICBob29rTG9nLnB1c2goe1xuICAgIHByaW1pdGl2ZTogJ1N0YXRlJyxcbiAgICBzdGFja0Vycm9yOiBuZXcgRXJyb3IoKSxcbiAgICB2YWx1ZTogc3RhdGVcbiAgfSk7XG4gIHJldHVybiBbc3RhdGUsIGZ1bmN0aW9uIChhY3Rpb24pIHt9XTtcbn1cblxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gbmV4dEhvb2soKTtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgc3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUgPSBpbml0ICE9PSB1bmRlZmluZWQgPyBpbml0KGluaXRpYWxBcmcpIDogaW5pdGlhbEFyZztcbiAgfVxuXG4gIGhvb2tMb2cucHVzaCh7XG4gICAgcHJpbWl0aXZlOiAnUmVkdWNlcicsXG4gICAgc3RhY2tFcnJvcjogbmV3IEVycm9yKCksXG4gICAgdmFsdWU6IHN0YXRlXG4gIH0pO1xuICByZXR1cm4gW3N0YXRlLCBmdW5jdGlvbiAoYWN0aW9uKSB7fV07XG59XG5cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBuZXh0SG9vaygpO1xuICB2YXIgcmVmID0gaG9vayAhPT0gbnVsbCA/IGhvb2subWVtb2l6ZWRTdGF0ZSA6IHtcbiAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgfTtcbiAgaG9va0xvZy5wdXNoKHtcbiAgICBwcmltaXRpdmU6ICdSZWYnLFxuICAgIHN0YWNrRXJyb3I6IG5ldyBFcnJvcigpLFxuICAgIHZhbHVlOiByZWYuY3VycmVudFxuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICB2YXIgaG9vayA9IG5leHRIb29rKCk7XG4gIGhvb2tMb2cucHVzaCh7XG4gICAgcHJpbWl0aXZlOiAnQ2FjaGVSZWZyZXNoJyxcbiAgICBzdGFja0Vycm9yOiBuZXcgRXJyb3IoKSxcbiAgICB2YWx1ZTogaG9vayAhPT0gbnVsbCA/IGhvb2subWVtb2l6ZWRTdGF0ZSA6IGZ1bmN0aW9uIHJlZnJlc2goKSB7fVxuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xufVxuXG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpIHtcbiAgbmV4dEhvb2soKTtcbiAgaG9va0xvZy5wdXNoKHtcbiAgICBwcmltaXRpdmU6ICdMYXlvdXRFZmZlY3QnLFxuICAgIHN0YWNrRXJyb3I6IG5ldyBFcnJvcigpLFxuICAgIHZhbHVlOiBjcmVhdGVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGlucHV0cykge1xuICBuZXh0SG9vaygpO1xuICBob29rTG9nLnB1c2goe1xuICAgIHByaW1pdGl2ZTogJ0luc2VydGlvbkVmZmVjdCcsXG4gICAgc3RhY2tFcnJvcjogbmV3IEVycm9yKCksXG4gICAgdmFsdWU6IGNyZWF0ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgaW5wdXRzKSB7XG4gIG5leHRIb29rKCk7XG4gIGhvb2tMb2cucHVzaCh7XG4gICAgcHJpbWl0aXZlOiAnRWZmZWN0JyxcbiAgICBzdGFja0Vycm9yOiBuZXcgRXJyb3IoKSxcbiAgICB2YWx1ZTogY3JlYXRlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBpbnB1dHMpIHtcbiAgbmV4dEhvb2soKTsgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgc3RvcmUgdGhlIGluc3RhbmNlIGFueXdoZXJlIGlmIHRoZXJlIGlzIG5vIHJlZiBjYWxsYmFja1xuICAvLyBhbmQgaWYgdGhlcmUgaXMgYSByZWYgY2FsbGJhY2sgaXQgbWlnaHQgbm90IHN0b3JlIGl0IGJ1dCBpZiBpdCBkb2VzIHdlXG4gIC8vIGhhdmUgbm8gd2F5IG9mIGtub3dpbmcgd2hlcmUuIFNvIGxldCdzIG9ubHkgZW5hYmxlIGludHJvc3BlY3Rpb24gb2YgdGhlXG4gIC8vIHJlZiBpdHNlbGYgaWYgaXQgaXMgdXNpbmcgdGhlIG9iamVjdCBmb3JtLlxuXG4gIHZhciBpbnN0YW5jZSA9IHVuZGVmaW5lZDtcblxuICBpZiAocmVmICE9PSBudWxsICYmIHR5cGVvZiByZWYgPT09ICdvYmplY3QnKSB7XG4gICAgaW5zdGFuY2UgPSByZWYuY3VycmVudDtcbiAgfVxuXG4gIGhvb2tMb2cucHVzaCh7XG4gICAgcHJpbWl0aXZlOiAnSW1wZXJhdGl2ZUhhbmRsZScsXG4gICAgc3RhY2tFcnJvcjogbmV3IEVycm9yKCksXG4gICAgdmFsdWU6IGluc3RhbmNlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICBob29rTG9nLnB1c2goe1xuICAgIHByaW1pdGl2ZTogJ0RlYnVnVmFsdWUnLFxuICAgIHN0YWNrRXJyb3I6IG5ldyBFcnJvcigpLFxuICAgIHZhbHVlOiB0eXBlb2YgZm9ybWF0dGVyRm4gPT09ICdmdW5jdGlvbicgPyBmb3JtYXR0ZXJGbih2YWx1ZSkgOiB2YWx1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGlucHV0cykge1xuICB2YXIgaG9vayA9IG5leHRIb29rKCk7XG4gIGhvb2tMb2cucHVzaCh7XG4gICAgcHJpbWl0aXZlOiAnQ2FsbGJhY2snLFxuICAgIHN0YWNrRXJyb3I6IG5ldyBFcnJvcigpLFxuICAgIHZhbHVlOiBob29rICE9PSBudWxsID8gaG9vay5tZW1vaXplZFN0YXRlWzBdIDogY2FsbGJhY2tcbiAgfSk7XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBpbnB1dHMpIHtcbiAgdmFyIGhvb2sgPSBuZXh0SG9vaygpO1xuICB2YXIgdmFsdWUgPSBob29rICE9PSBudWxsID8gaG9vay5tZW1vaXplZFN0YXRlWzBdIDogbmV4dENyZWF0ZSgpO1xuICBob29rTG9nLnB1c2goe1xuICAgIHByaW1pdGl2ZTogJ01lbW8nLFxuICAgIHN0YWNrRXJyb3I6IG5ldyBFcnJvcigpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAvLyB1c2VNdXRhYmxlU291cmNlKCkgY29tcG9zZXMgbXVsdGlwbGUgaG9va3MgaW50ZXJuYWxseS5cbiAgLy8gQWR2YW5jZSB0aGUgY3VycmVudCBob29rIGluZGV4IHRoZSBzYW1lIG51bWJlciBvZiB0aW1lc1xuICAvLyBzbyB0aGF0IHN1YnNlcXVlbnQgaG9va3MgaGF2ZSB0aGUgcmlnaHQgbWVtb2l6ZWQgc3RhdGUuXG4gIG5leHRIb29rKCk7IC8vIE11dGFibGVTb3VyY2VcblxuICBuZXh0SG9vaygpOyAvLyBTdGF0ZVxuXG4gIG5leHRIb29rKCk7IC8vIEVmZmVjdFxuXG4gIG5leHRIb29rKCk7IC8vIEVmZmVjdFxuXG4gIHZhciB2YWx1ZSA9IGdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKTtcbiAgaG9va0xvZy5wdXNoKHtcbiAgICBwcmltaXRpdmU6ICdNdXRhYmxlU291cmNlJyxcbiAgICBzdGFja0Vycm9yOiBuZXcgRXJyb3IoKSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgLy8gdXNlU3luY0V4dGVybmFsU3RvcmUoKSBjb21wb3NlcyBtdWx0aXBsZSBob29rcyBpbnRlcm5hbGx5LlxuICAvLyBBZHZhbmNlIHRoZSBjdXJyZW50IGhvb2sgaW5kZXggdGhlIHNhbWUgbnVtYmVyIG9mIHRpbWVzXG4gIC8vIHNvIHRoYXQgc3Vic2VxdWVudCBob29rcyBoYXZlIHRoZSByaWdodCBtZW1vaXplZCBzdGF0ZS5cbiAgbmV4dEhvb2soKTsgLy8gU3luY0V4dGVybmFsU3RvcmVcblxuICBuZXh0SG9vaygpOyAvLyBFZmZlY3RcblxuICB2YXIgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuICBob29rTG9nLnB1c2goe1xuICAgIHByaW1pdGl2ZTogJ1N5bmNFeHRlcm5hbFN0b3JlJyxcbiAgICBzdGFja0Vycm9yOiBuZXcgRXJyb3IoKSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgLy8gdXNlVHJhbnNpdGlvbigpIGNvbXBvc2VzIG11bHRpcGxlIGhvb2tzIGludGVybmFsbHkuXG4gIC8vIEFkdmFuY2UgdGhlIGN1cnJlbnQgaG9vayBpbmRleCB0aGUgc2FtZSBudW1iZXIgb2YgdGltZXNcbiAgLy8gc28gdGhhdCBzdWJzZXF1ZW50IGhvb2tzIGhhdmUgdGhlIHJpZ2h0IG1lbW9pemVkIHN0YXRlLlxuICBuZXh0SG9vaygpOyAvLyBTdGF0ZVxuXG4gIG5leHRIb29rKCk7IC8vIENhbGxiYWNrXG5cbiAgaG9va0xvZy5wdXNoKHtcbiAgICBwcmltaXRpdmU6ICdUcmFuc2l0aW9uJyxcbiAgICBzdGFja0Vycm9yOiBuZXcgRXJyb3IoKSxcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4gW2ZhbHNlLCBmdW5jdGlvbiAoY2FsbGJhY2spIHt9XTtcbn1cblxuZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICAvLyB1c2VEZWZlcnJlZFZhbHVlKCkgY29tcG9zZXMgbXVsdGlwbGUgaG9va3MgaW50ZXJuYWxseS5cbiAgLy8gQWR2YW5jZSB0aGUgY3VycmVudCBob29rIGluZGV4IHRoZSBzYW1lIG51bWJlciBvZiB0aW1lc1xuICAvLyBzbyB0aGF0IHN1YnNlcXVlbnQgaG9va3MgaGF2ZSB0aGUgcmlnaHQgbWVtb2l6ZWQgc3RhdGUuXG4gIG5leHRIb29rKCk7IC8vIFN0YXRlXG5cbiAgbmV4dEhvb2soKTsgLy8gRWZmZWN0XG5cbiAgaG9va0xvZy5wdXNoKHtcbiAgICBwcmltaXRpdmU6ICdEZWZlcnJlZFZhbHVlJyxcbiAgICBzdGFja0Vycm9yOiBuZXcgRXJyb3IoKSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlSWQoKSB7XG4gIHZhciBob29rID0gbmV4dEhvb2soKTtcbiAgdmFyIGlkID0gaG9vayAhPT0gbnVsbCA/IGhvb2subWVtb2l6ZWRTdGF0ZSA6ICcnO1xuICBob29rTG9nLnB1c2goe1xuICAgIHByaW1pdGl2ZTogJ0lkJyxcbiAgICBzdGFja0Vycm9yOiBuZXcgRXJyb3IoKSxcbiAgICB2YWx1ZTogaWRcbiAgfSk7XG4gIHJldHVybiBpZDtcbn1cblxudmFyIERpc3BhdGNoZXIgPSB7XG4gIGdldENhY2hlRm9yVHlwZTogZ2V0Q2FjaGVGb3JUeXBlLFxuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZUNhY2hlUmVmcmVzaDogdXNlQ2FjaGVSZWZyZXNoLFxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB1c2VJbXBlcmF0aXZlSGFuZGxlLFxuICB1c2VEZWJ1Z1ZhbHVlOiB1c2VEZWJ1Z1ZhbHVlLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHVzZUxheW91dEVmZmVjdCxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB1c2VJbnNlcnRpb25FZmZlY3QsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIHVzZVRyYW5zaXRpb246IHVzZVRyYW5zaXRpb24sXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2UsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdXNlRGVmZXJyZWRWYWx1ZSxcbiAgdXNlSWQ6IHVzZUlkXG59OyAvLyBJbnNwZWN0XG5cbi8vIERvbid0IGFzc3VtZVxuLy9cbi8vIFdlIGNhbid0IGFzc3VtZSB0aGF0IHN0YWNrIGZyYW1lcyBhcmUgbnRoIHN0ZXBzIGF3YXkgZnJvbSBhbnl0aGluZy5cbi8vIEUuZy4gd2UgY2FuJ3QgYXNzdW1lIHRoYXQgdGhlIHJvb3QgY2FsbCBzaGFyZXMgYWxsIGZyYW1lcyB3aXRoIHRoZSBzdGFja1xuLy8gb2YgYSBob29rIGNhbGwuIEEgc2ltcGxlIHdheSB0byBkZW1vbnN0cmF0ZSB0aGlzIGlzIHdyYXBwaW5nIGBuZXcgRXJyb3IoKWBcbi8vIGluIGEgd3JhcHBlciBjb25zdHJ1Y3RvciBsaWtlIGEgcG9seWZpbGwuIFRoYXQnbGwgYWRkIGFuIGV4dHJhIGZyYW1lLlxuLy8gU2ltaWxhciB0aGluZ3MgY2FuIGhhcHBlbiB3aXRoIHRoZSBjYWxsIHRvIHRoZSBkaXNwYXRjaGVyLiBUaGUgdG9wIGZyYW1lXG4vLyBtYXkgbm90IGJlIHRoZSBwcmltaXRpdmUuIExpa2V3aXNlIHRoZSBwcmltaXRpdmUgY2FuIGhhdmUgZmV3ZXIgc3RhY2sgZnJhbWVzXG4vLyBzdWNoIGFzIHdoZW4gYSBjYWxsIHRvIHVzZVN0YXRlIGdvdCBpbmxpbmVkIHRvIHVzZSBkaXNwYXRjaGVyLnVzZVN0YXRlLlxuLy9cbi8vIFdlIGFsc28gY2FuJ3QgYXNzdW1lIHRoYXQgdGhlIGxhc3QgZnJhbWUgb2YgdGhlIHJvb3QgY2FsbCBpcyB0aGUgc2FtZVxuLy8gZnJhbWUgYXMgdGhlIGxhc3QgZnJhbWUgb2YgdGhlIGhvb2sgY2FsbCBiZWNhdXNlIGxvbmcgc3RhY2sgdHJhY2VzIGNhbiBiZVxuLy8gdHJ1bmNhdGVkIHRvIGEgc3RhY2sgdHJhY2UgbGltaXQuXG52YXIgbW9zdExpa2VseUFuY2VzdG9ySW5kZXggPSAwO1xuXG5mdW5jdGlvbiBmaW5kU2hhcmVkSW5kZXgoaG9va1N0YWNrLCByb290U3RhY2ssIHJvb3RJbmRleCkge1xuICB2YXIgc291cmNlID0gcm9vdFN0YWNrW3Jvb3RJbmRleF0uc291cmNlO1xuXG4gIGhvb2tTZWFyY2g6IGZvciAodmFyIGkgPSAwOyBpIDwgaG9va1N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhvb2tTdGFja1tpXS5zb3VyY2UgPT09IHNvdXJjZSkge1xuICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIGEgbWF0Y2guIFZhbGlkYXRlIHRoYXQgdGhlIHJlc3Qgb2YgYm90aCBzdGFjayBtYXRjaCB1cC5cbiAgICAgIGZvciAodmFyIGEgPSByb290SW5kZXggKyAxLCBiID0gaSArIDE7IGEgPCByb290U3RhY2subGVuZ3RoICYmIGIgPCBob29rU3RhY2subGVuZ3RoOyBhKyssIGIrKykge1xuICAgICAgICBpZiAoaG9va1N0YWNrW2JdLnNvdXJjZSAhPT0gcm9vdFN0YWNrW2FdLnNvdXJjZSkge1xuICAgICAgICAgIC8vIElmIG5vdCwgZ2l2ZSB1cCBhbmQgdHJ5IGEgZGlmZmVyZW50IG1hdGNoLlxuICAgICAgICAgIGNvbnRpbnVlIGhvb2tTZWFyY2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBmaW5kQ29tbW9uQW5jZXN0b3JJbmRleChyb290U3RhY2ssIGhvb2tTdGFjaykge1xuICB2YXIgcm9vdEluZGV4ID0gZmluZFNoYXJlZEluZGV4KGhvb2tTdGFjaywgcm9vdFN0YWNrLCBtb3N0TGlrZWx5QW5jZXN0b3JJbmRleCk7XG5cbiAgaWYgKHJvb3RJbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gcm9vdEluZGV4O1xuICB9IC8vIElmIHRoZSBtb3N0IGxpa2VseSBvbmUgd2Fzbid0IGEgaGl0LCB0cnkgYW55IG90aGVyIGZyYW1lIHRvIHNlZSBpZiBpdCBpcyBzaGFyZWQuXG4gIC8vIElmIHRoYXQgdGFrZXMgbW9yZSB0aGFuIDUgZnJhbWVzLCBzb21ldGhpbmcgcHJvYmFibHkgd2VudCB3cm9uZy5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdFN0YWNrLmxlbmd0aCAmJiBpIDwgNTsgaSsrKSB7XG4gICAgcm9vdEluZGV4ID0gZmluZFNoYXJlZEluZGV4KGhvb2tTdGFjaywgcm9vdFN0YWNrLCBpKTtcblxuICAgIGlmIChyb290SW5kZXggIT09IC0xKSB7XG4gICAgICBtb3N0TGlrZWx5QW5jZXN0b3JJbmRleCA9IGk7XG4gICAgICByZXR1cm4gcm9vdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gaXNSZWFjdFdyYXBwZXIoZnVuY3Rpb25OYW1lLCBwcmltaXRpdmVOYW1lKSB7XG4gIGlmICghZnVuY3Rpb25OYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV4cGVjdGVkUHJpbWl0aXZlTmFtZSA9ICd1c2UnICsgcHJpbWl0aXZlTmFtZTtcblxuICBpZiAoZnVuY3Rpb25OYW1lLmxlbmd0aCA8IGV4cGVjdGVkUHJpbWl0aXZlTmFtZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb25OYW1lLmxhc3RJbmRleE9mKGV4cGVjdGVkUHJpbWl0aXZlTmFtZSkgPT09IGZ1bmN0aW9uTmFtZS5sZW5ndGggLSBleHBlY3RlZFByaW1pdGl2ZU5hbWUubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBmaW5kUHJpbWl0aXZlSW5kZXgoaG9va1N0YWNrLCBob29rKSB7XG4gIHZhciBzdGFja0NhY2hlID0gZ2V0UHJpbWl0aXZlU3RhY2tDYWNoZSgpO1xuICB2YXIgcHJpbWl0aXZlU3RhY2sgPSBzdGFja0NhY2hlLmdldChob29rLnByaW1pdGl2ZSk7XG5cbiAgaWYgKHByaW1pdGl2ZVN0YWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW1pdGl2ZVN0YWNrLmxlbmd0aCAmJiBpIDwgaG9va1N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByaW1pdGl2ZVN0YWNrW2ldLnNvdXJjZSAhPT0gaG9va1N0YWNrW2ldLnNvdXJjZSkge1xuICAgICAgLy8gSWYgdGhlIG5leHQgdHdvIGZyYW1lcyBhcmUgZnVuY3Rpb25zIGNhbGxlZCBgdXNlWGAgdGhlbiB3ZSBhc3N1bWUgdGhhdCB0aGV5J3JlIHBhcnQgb2YgdGhlXG4gICAgICAvLyB3cmFwcGVycyB0aGF0IHRoZSBSZWFjdCBwYWNrYWdlciBvciBvdGhlciBwYWNrYWdlcyBhZGRzIGFyb3VuZCB0aGUgZGlzcGF0Y2hlci5cbiAgICAgIGlmIChpIDwgaG9va1N0YWNrLmxlbmd0aCAtIDEgJiYgaXNSZWFjdFdyYXBwZXIoaG9va1N0YWNrW2ldLmZ1bmN0aW9uTmFtZSwgaG9vay5wcmltaXRpdmUpKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBob29rU3RhY2subGVuZ3RoIC0gMSAmJiBpc1JlYWN0V3JhcHBlcihob29rU3RhY2tbaV0uZnVuY3Rpb25OYW1lLCBob29rLnByaW1pdGl2ZSkpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJpbW1lZFN0YWNrKHJvb3RTdGFjaywgaG9vaykge1xuICAvLyBHZXQgdGhlIHN0YWNrIHRyYWNlIGJldHdlZW4gdGhlIHByaW1pdGl2ZSBob29rIGZ1bmN0aW9uIGFuZFxuICAvLyB0aGUgcm9vdCBmdW5jdGlvbiBjYWxsLiBJLmUuIHRoZSBzdGFjayBmcmFtZXMgb2YgY3VzdG9tIGhvb2tzLlxuICB2YXIgaG9va1N0YWNrID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShob29rLnN0YWNrRXJyb3IpO1xuICB2YXIgcm9vdEluZGV4ID0gZmluZENvbW1vbkFuY2VzdG9ySW5kZXgocm9vdFN0YWNrLCBob29rU3RhY2spO1xuICB2YXIgcHJpbWl0aXZlSW5kZXggPSBmaW5kUHJpbWl0aXZlSW5kZXgoaG9va1N0YWNrLCBob29rKTtcblxuICBpZiAocm9vdEluZGV4ID09PSAtMSB8fCBwcmltaXRpdmVJbmRleCA9PT0gLTEgfHwgcm9vdEluZGV4IC0gcHJpbWl0aXZlSW5kZXggPCAyKSB7XG4gICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcuIEdpdmUgdXAuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9va1N0YWNrLnNsaWNlKHByaW1pdGl2ZUluZGV4LCByb290SW5kZXggLSAxKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDdXN0b21Ib29rTmFtZShmdW5jdGlvbk5hbWUpIHtcbiAgaWYgKCFmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgc3RhcnRJbmRleCA9IGZ1bmN0aW9uTmFtZS5sYXN0SW5kZXhPZignLicpO1xuXG4gIGlmIChzdGFydEluZGV4ID09PSAtMSkge1xuICAgIHN0YXJ0SW5kZXggPSAwO1xuICB9XG5cbiAgaWYgKGZ1bmN0aW9uTmFtZS5zdWJzdHIoc3RhcnRJbmRleCwgMykgPT09ICd1c2UnKSB7XG4gICAgc3RhcnRJbmRleCArPSAzO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZS5zdWJzdHIoc3RhcnRJbmRleCk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShyb290U3RhY2ssIHJlYWRIb29rTG9nLCBpbmNsdWRlSG9va3NTb3VyY2UpIHtcbiAgdmFyIHJvb3RDaGlsZHJlbiA9IFtdO1xuICB2YXIgcHJldlN0YWNrID0gbnVsbDtcbiAgdmFyIGxldmVsQ2hpbGRyZW4gPSByb290Q2hpbGRyZW47XG4gIHZhciBuYXRpdmVIb29rSUQgPSAwO1xuICB2YXIgc3RhY2tPZkNoaWxkcmVuID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWFkSG9va0xvZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gcmVhZEhvb2tMb2dbaV07XG4gICAgdmFyIHN0YWNrID0gcGFyc2VUcmltbWVkU3RhY2socm9vdFN0YWNrLCBob29rKTtcblxuICAgIGlmIChzdGFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gTm90ZTogVGhlIGluZGljZXMgMCA8PSBuIDwgbGVuZ3RoLTEgd2lsbCBjb250YWluIHRoZSBuYW1lcy5cbiAgICAgIC8vIFRoZSBpbmRpY2VzIDEgPD0gbiA8IGxlbmd0aCB3aWxsIGNvbnRhaW4gdGhlIHNvdXJjZSBsb2NhdGlvbnMuXG4gICAgICAvLyBUaGF0J3Mgd2h5IHdlIGdldCB0aGUgbmFtZSBmcm9tIG4gLSAxIGFuZCBkb24ndCBjaGVjayB0aGUgc291cmNlXG4gICAgICAvLyBvZiBpbmRleCAwLlxuICAgICAgdmFyIGNvbW1vblN0ZXBzID0gMDtcblxuICAgICAgaWYgKHByZXZTdGFjayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBjdXJyZW50IGxldmVsJ3Mgc3RhY2sgdG8gdGhlIG5ldyBzdGFjay5cbiAgICAgICAgd2hpbGUgKGNvbW1vblN0ZXBzIDwgc3RhY2subGVuZ3RoICYmIGNvbW1vblN0ZXBzIDwgcHJldlN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzdGFja1NvdXJjZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIGNvbW1vblN0ZXBzIC0gMV0uc291cmNlO1xuICAgICAgICAgIHZhciBwcmV2U291cmNlID0gcHJldlN0YWNrW3ByZXZTdGFjay5sZW5ndGggLSBjb21tb25TdGVwcyAtIDFdLnNvdXJjZTtcblxuICAgICAgICAgIGlmIChzdGFja1NvdXJjZSAhPT0gcHJldlNvdXJjZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbW9uU3RlcHMrKztcbiAgICAgICAgfSAvLyBQb3AgYmFjayB0aGUgc3RhY2sgYXMgbWFueSBzdGVwcyBhcyB3ZXJlIG5vdCBjb21tb24uXG5cblxuICAgICAgICBmb3IgKHZhciBqID0gcHJldlN0YWNrLmxlbmd0aCAtIDE7IGogPiBjb21tb25TdGVwczsgai0tKSB7XG4gICAgICAgICAgbGV2ZWxDaGlsZHJlbiA9IHN0YWNrT2ZDaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBUaGUgcmVtYWluaW5nIHBhcnQgb2YgdGhlIG5ldyBzdGFjayBhcmUgY3VzdG9tIGhvb2tzLiBQdXNoIHRoZW1cbiAgICAgIC8vIHRvIHRoZSB0cmVlLlxuXG5cbiAgICAgIGZvciAodmFyIF9qID0gc3RhY2subGVuZ3RoIC0gY29tbW9uU3RlcHMgLSAxOyBfaiA+PSAxOyBfai0tKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB2YXIgc3RhY2tGcmFtZSA9IHN0YWNrW19qXTtcbiAgICAgICAgdmFyIF9sZXZlbENoaWxkID0ge1xuICAgICAgICAgIGlkOiBudWxsLFxuICAgICAgICAgIGlzU3RhdGVFZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgbmFtZTogcGFyc2VDdXN0b21Ib29rTmFtZShzdGFja1tfaiAtIDFdLmZ1bmN0aW9uTmFtZSksXG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBzdWJIb29rczogY2hpbGRyZW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW5jbHVkZUhvb2tzU291cmNlKSB7XG4gICAgICAgICAgX2xldmVsQ2hpbGQuaG9va1NvdXJjZSA9IHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IHN0YWNrRnJhbWUubGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogc3RhY2tGcmFtZS5jb2x1bW5OdW1iZXIsXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IHN0YWNrRnJhbWUuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgZmlsZU5hbWU6IHN0YWNrRnJhbWUuZmlsZU5hbWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV2ZWxDaGlsZHJlbi5wdXNoKF9sZXZlbENoaWxkKTtcbiAgICAgICAgc3RhY2tPZkNoaWxkcmVuLnB1c2gobGV2ZWxDaGlsZHJlbik7XG4gICAgICAgIGxldmVsQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH1cblxuICAgICAgcHJldlN0YWNrID0gc3RhY2s7XG4gICAgfVxuXG4gICAgdmFyIHByaW1pdGl2ZSA9IGhvb2sucHJpbWl0aXZlOyAvLyBGb3Igbm93LCB0aGUgXCJpZFwiIG9mIHN0YXRlZnVsIGhvb2tzIGlzIGp1c3QgdGhlIHN0YXRlZnVsIGhvb2sgaW5kZXguXG4gICAgLy8gQ3VzdG9tIGhvb2tzIGhhdmUgbm8gaWRzLCBub3IgZG8gbm9uLXN0YXRlZnVsIG5hdGl2ZSBob29rcyAoZS5nLiBDb250ZXh0LCBEZWJ1Z1ZhbHVlKS5cblxuICAgIHZhciBpZCA9IHByaW1pdGl2ZSA9PT0gJ0NvbnRleHQnIHx8IHByaW1pdGl2ZSA9PT0gJ0RlYnVnVmFsdWUnID8gbnVsbCA6IG5hdGl2ZUhvb2tJRCsrOyAvLyBGb3IgdGhlIHRpbWUgYmVpbmcsIG9ubHkgU3RhdGUgYW5kIFJlZHVjZXIgaG9va3Mgc3VwcG9ydCBydW50aW1lIG92ZXJyaWRlcy5cblxuICAgIHZhciBpc1N0YXRlRWRpdGFibGUgPSBwcmltaXRpdmUgPT09ICdSZWR1Y2VyJyB8fCBwcmltaXRpdmUgPT09ICdTdGF0ZSc7XG4gICAgdmFyIGxldmVsQ2hpbGQgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBpc1N0YXRlRWRpdGFibGU6IGlzU3RhdGVFZGl0YWJsZSxcbiAgICAgIG5hbWU6IHByaW1pdGl2ZSxcbiAgICAgIHZhbHVlOiBob29rLnZhbHVlLFxuICAgICAgc3ViSG9va3M6IFtdXG4gICAgfTtcblxuICAgIGlmIChpbmNsdWRlSG9va3NTb3VyY2UpIHtcbiAgICAgIHZhciBob29rU291cmNlID0ge1xuICAgICAgICBsaW5lTnVtYmVyOiBudWxsLFxuICAgICAgICBmdW5jdGlvbk5hbWU6IG51bGwsXG4gICAgICAgIGZpbGVOYW1lOiBudWxsLFxuICAgICAgICBjb2x1bW5OdW1iZXI6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIGlmIChzdGFjayAmJiBzdGFjay5sZW5ndGggPj0gMSkge1xuICAgICAgICB2YXIgX3N0YWNrRnJhbWUgPSBzdGFja1swXTtcbiAgICAgICAgaG9va1NvdXJjZS5saW5lTnVtYmVyID0gX3N0YWNrRnJhbWUubGluZU51bWJlcjtcbiAgICAgICAgaG9va1NvdXJjZS5mdW5jdGlvbk5hbWUgPSBfc3RhY2tGcmFtZS5mdW5jdGlvbk5hbWU7XG4gICAgICAgIGhvb2tTb3VyY2UuZmlsZU5hbWUgPSBfc3RhY2tGcmFtZS5maWxlTmFtZTtcbiAgICAgICAgaG9va1NvdXJjZS5jb2x1bW5OdW1iZXIgPSBfc3RhY2tGcmFtZS5jb2x1bW5OdW1iZXI7XG4gICAgICB9XG5cbiAgICAgIGxldmVsQ2hpbGQuaG9va1NvdXJjZSA9IGhvb2tTb3VyY2U7XG4gICAgfVxuXG4gICAgbGV2ZWxDaGlsZHJlbi5wdXNoKGxldmVsQ2hpbGQpO1xuICB9IC8vIEFzc29jaWF0ZSBjdXN0b20gaG9vayB2YWx1ZXMgKHVzZURlYnVnVmFsdWUoKSBob29rIGVudHJpZXMpIHdpdGggdGhlIGNvcnJlY3QgaG9va3MuXG5cblxuICBwcm9jZXNzRGVidWdWYWx1ZXMocm9vdENoaWxkcmVuLCBudWxsKTtcbiAgcmV0dXJuIHJvb3RDaGlsZHJlbjtcbn0gLy8gQ3VzdG9tIGhvb2tzIHN1cHBvcnQgdXNlci1jb25maWd1cmFibGUgbGFiZWxzICh2aWEgdGhlIHNwZWNpYWwgdXNlRGVidWdWYWx1ZSgpIGhvb2spLlxuLy8gVGhhdCBob29rIGFkZHMgdXNlci1wcm92aWRlZCB2YWx1ZXMgdG8gdGhlIGhvb2tzIHRyZWUsXG4vLyBidXQgdGhlc2UgdmFsdWVzIGFyZW4ndCBpbnRlbmRlZCB0byBhcHBlYXIgYWxvbmdzaWRlIG9mIHRoZSBvdGhlciBob29rcy5cbi8vIEluc3RlYWQgdGhleSBzaG91bGQgYmUgYXR0cmlidXRlZCB0byB0aGVpciBwYXJlbnQgY3VzdG9tIGhvb2suXG4vLyBUaGlzIG1ldGhvZCB3YWxrcyB0aGUgdHJlZSBhbmQgYXNzaWducyBkZWJ1ZyB2YWx1ZXMgdG8gdGhlaXIgY3VzdG9tIGhvb2sgb3duZXJzLlxuXG5cbmZ1bmN0aW9uIHByb2Nlc3NEZWJ1Z1ZhbHVlcyhob29rc1RyZWUsIHBhcmVudEhvb2tzTm9kZSkge1xuICB2YXIgZGVidWdWYWx1ZUhvb2tzTm9kZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVHJlZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rc05vZGUgPSBob29rc1RyZWVbaV07XG5cbiAgICBpZiAoaG9va3NOb2RlLm5hbWUgPT09ICdEZWJ1Z1ZhbHVlJyAmJiBob29rc05vZGUuc3ViSG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBob29rc1RyZWUuc3BsaWNlKGksIDEpO1xuICAgICAgaS0tO1xuICAgICAgZGVidWdWYWx1ZUhvb2tzTm9kZXMucHVzaChob29rc05vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzRGVidWdWYWx1ZXMoaG9va3NOb2RlLnN1Ykhvb2tzLCBob29rc05vZGUpO1xuICAgIH1cbiAgfSAvLyBCdWJibGUgZGVidWcgdmFsdWUgbGFiZWxzIHRvIHRoZWlyIGN1c3RvbSBob29rIG93bmVyLlxuICAvLyBJZiB0aGVyZSBpcyBubyBwYXJlbnQgaG9vaywganVzdCBpZ25vcmUgdGhlbSBmb3Igbm93LlxuICAvLyAoV2UgbWF5IHdhcm4gYWJvdXQgdGhpcyBpbiB0aGUgZnV0dXJlLilcblxuXG4gIGlmIChwYXJlbnRIb29rc05vZGUgIT09IG51bGwpIHtcbiAgICBpZiAoZGVidWdWYWx1ZUhvb2tzTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBwYXJlbnRIb29rc05vZGUudmFsdWUgPSBkZWJ1Z1ZhbHVlSG9va3NOb2Rlc1swXS52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGRlYnVnVmFsdWVIb29rc05vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHBhcmVudEhvb2tzTm9kZS52YWx1ZSA9IGRlYnVnVmFsdWVIb29rc05vZGVzLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zcGVjdEhvb2tzKHJlbmRlckZ1bmN0aW9uLCBwcm9wcywgY3VycmVudERpc3BhdGNoZXIpIHtcbiAgdmFyIGluY2x1ZGVIb29rc1NvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgLy8gRGV2VG9vbHMgd2lsbCBwYXNzIHRoZSBjdXJyZW50IHJlbmRlcmVyJ3MgaW5qZWN0ZWQgZGlzcGF0Y2hlci5cbiAgLy8gT3RoZXIgYXBwcyBtaWdodCBjb21waWxlIGRlYnVnIGhvb2tzIGFzIHBhcnQgb2YgdGhlaXIgYXBwIHRob3VnaC5cbiAgaWYgKGN1cnJlbnREaXNwYXRjaGVyID09IG51bGwpIHtcbiAgICBjdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG4gIH1cblxuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gY3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgdmFyIHJlYWRIb29rTG9nO1xuICBjdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gRGlzcGF0Y2hlcjtcbiAgdmFyIGFuY2VzdG9yU3RhY2tFcnJvcjtcblxuICB0cnkge1xuICAgIGFuY2VzdG9yU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgIHJlbmRlckZ1bmN0aW9uKHByb3BzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWFkSG9va0xvZyA9IGhvb2tMb2c7XG4gICAgaG9va0xvZyA9IFtdO1xuICAgIGN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gIH1cblxuICB2YXIgcm9vdFN0YWNrID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShhbmNlc3RvclN0YWNrRXJyb3IpO1xuICByZXR1cm4gYnVpbGRUcmVlKHJvb3RTdGFjaywgcmVhZEhvb2tMb2csIGluY2x1ZGVIb29rc1NvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIHNldHVwQ29udGV4dHMoY29udGV4dE1hcCwgZmliZXIpIHtcbiAgdmFyIGN1cnJlbnQgPSBmaWJlcjtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIGlmIChjdXJyZW50LnRhZyA9PT0gQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICB2YXIgcHJvdmlkZXJUeXBlID0gY3VycmVudC50eXBlO1xuICAgICAgdmFyIGNvbnRleHQgPSBwcm92aWRlclR5cGUuX2NvbnRleHQ7XG5cbiAgICAgIGlmICghY29udGV4dE1hcC5oYXMoY29udGV4dCkpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdmFsdWUgdGhhdCB3ZSdyZSBnb2luZyB0byByZXN0b3JlIGxhdGVyLlxuICAgICAgICBjb250ZXh0TWFwLnNldChjb250ZXh0LCBjb250ZXh0Ll9jdXJyZW50VmFsdWUpOyAvLyBTZXQgdGhlIGlubmVyIG1vc3QgcHJvdmlkZXIgdmFsdWUgb24gdGhlIGNvbnRleHQuXG5cbiAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudC5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udGV4dHMoY29udGV4dE1hcCkge1xuICBjb250ZXh0TWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdEhvb2tzT2ZGb3J3YXJkUmVmKHJlbmRlckZ1bmN0aW9uLCBwcm9wcywgcmVmLCBjdXJyZW50RGlzcGF0Y2hlciwgaW5jbHVkZUhvb2tzU291cmNlKSB7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBjdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICB2YXIgcmVhZEhvb2tMb2c7XG4gIGN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBEaXNwYXRjaGVyO1xuICB2YXIgYW5jZXN0b3JTdGFja0Vycm9yO1xuXG4gIHRyeSB7XG4gICAgYW5jZXN0b3JTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgcmVuZGVyRnVuY3Rpb24ocHJvcHMsIHJlZik7XG4gIH0gZmluYWxseSB7XG4gICAgcmVhZEhvb2tMb2cgPSBob29rTG9nO1xuICAgIGhvb2tMb2cgPSBbXTtcbiAgICBjdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICB9XG5cbiAgdmFyIHJvb3RTdGFjayA9IEVycm9yU3RhY2tQYXJzZXIucGFyc2UoYW5jZXN0b3JTdGFja0Vycm9yKTtcbiAgcmV0dXJuIGJ1aWxkVHJlZShyb290U3RhY2ssIHJlYWRIb29rTG9nLCBpbmNsdWRlSG9va3NTb3VyY2UpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RIb29rc09mRmliZXIoZmliZXIsIGN1cnJlbnREaXNwYXRjaGVyKSB7XG4gIHZhciBpbmNsdWRlSG9va3NTb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIC8vIERldlRvb2xzIHdpbGwgcGFzcyB0aGUgY3VycmVudCByZW5kZXJlcidzIGluamVjdGVkIGRpc3BhdGNoZXIuXG4gIC8vIE90aGVyIGFwcHMgbWlnaHQgY29tcGlsZSBkZWJ1ZyBob29rcyBhcyBwYXJ0IG9mIHRoZWlyIGFwcCB0aG91Z2guXG4gIGlmIChjdXJyZW50RGlzcGF0Y2hlciA9PSBudWxsKSB7XG4gICAgY3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuICB9XG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgZmliZXIudGFnICE9PSBTaW1wbGVNZW1vQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gRm9yd2FyZFJlZikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBGaWJlci4gTmVlZHMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdG8gaW5zcGVjdCBob29rcy4nKTtcbiAgfSAvLyBXYXJtIHVwIHRoZSBjYWNoZSBzbyB0aGF0IGl0IGRvZXNuJ3QgY29uc3VtZSB0aGUgY3VycmVudEhvb2suXG5cblxuICBnZXRQcmltaXRpdmVTdGFja0NhY2hlKCk7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgdmFyIHByb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcztcblxuICBpZiAodHlwZSAhPT0gZmliZXIuZWxlbWVudFR5cGUpIHtcbiAgICBwcm9wcyA9IHJlc29sdmVEZWZhdWx0UHJvcHModHlwZSwgcHJvcHMpO1xuICB9IC8vIFNldCB1cCB0aGUgY3VycmVudCBob29rIHNvIHRoYXQgd2UgY2FuIHN0ZXAgdGhyb3VnaCBhbmQgcmVhZCB0aGVcbiAgLy8gY3VycmVudCBzdGF0ZSBmcm9tIHRoZW0uXG5cblxuICBjdXJyZW50SG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBjb250ZXh0TWFwID0gbmV3IE1hcCgpO1xuXG4gIHRyeSB7XG4gICAgc2V0dXBDb250ZXh0cyhjb250ZXh0TWFwLCBmaWJlcik7XG5cbiAgICBpZiAoZmliZXIudGFnID09PSBGb3J3YXJkUmVmKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdEhvb2tzT2ZGb3J3YXJkUmVmKHR5cGUucmVuZGVyLCBwcm9wcywgZmliZXIucmVmLCBjdXJyZW50RGlzcGF0Y2hlciwgaW5jbHVkZUhvb2tzU291cmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zcGVjdEhvb2tzKHR5cGUsIHByb3BzLCBjdXJyZW50RGlzcGF0Y2hlciwgaW5jbHVkZUhvb2tzU291cmNlKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50SG9vayA9IG51bGw7XG4gICAgcmVzdG9yZUNvbnRleHRzKGNvbnRleHRNYXApO1xuICB9XG59XG5cbmV4cG9ydHMuaW5zcGVjdEhvb2tzID0gaW5zcGVjdEhvb2tzO1xuZXhwb3J0cy5pbnNwZWN0SG9va3NPZkZpYmVyID0gaW5zcGVjdEhvb2tzT2ZGaWJlcjtcbiAgfSkoKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react-debug-tools/cjs/react-debug-tools.development.js\n");

/***/ }),

/***/ "../../build/oss-experimental/react-debug-tools/index.js":
/*!**********************************************************************************!*\
  !*** /home/pomber/p/dev/react/build/oss-experimental/react-debug-tools/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-debug-tools.development.js */ \"../../build/oss-experimental/react-debug-tools/cjs/react-debug-tools.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC1kZWJ1Zy10b29scy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9wb21iZXIvcC9kZXYvcmVhY3QvYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC1kZWJ1Zy10b29scy9pbmRleC5qcz9mZGUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kZWJ1Zy10b29scy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kZWJ1Zy10b29scy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react-debug-tools/index.js\n");

/***/ }),

/***/ "../../build/oss-experimental/react-is/cjs/react-is.development.js":
/*!********************************************************************************************!*\
  !*** /home/pomber/p/dev/react/build/oss-experimental/react-is/cjs/react-is.development.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React vundefined\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nif (true) {\n  (function () {\n    'use strict'; // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    var REACT_FRAGMENT_TYPE = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n    var REACT_CACHE_TYPE = 0xeae4;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      REACT_FRAGMENT_TYPE = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n      REACT_CACHE_TYPE = symbolFor('react.cache');\n    } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    var REACT_MODULE_REFERENCE = 0;\n\n    if (typeof Symbol === 'function') {\n      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n    }\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || type === REACT_CACHE_TYPE) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function typeOf(object) {\n      if (typeof object === 'object' && object !== null) {\n        var $$typeof = object.$$typeof;\n\n        switch ($$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = object.type;\n\n            switch (type) {\n              case REACT_FRAGMENT_TYPE:\n              case REACT_PROFILER_TYPE:\n              case REACT_STRICT_MODE_TYPE:\n              case REACT_SUSPENSE_TYPE:\n              case REACT_SUSPENSE_LIST_TYPE:\n                return type;\n\n              default:\n                var $$typeofType = type && type.$$typeof;\n\n                switch ($$typeofType) {\n                  case REACT_CONTEXT_TYPE:\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_LAZY_TYPE:\n                  case REACT_MEMO_TYPE:\n                  case REACT_PROVIDER_TYPE:\n                    return $$typeofType;\n\n                  default:\n                    return $$typeof;\n                }\n\n            }\n\n          case REACT_PORTAL_TYPE:\n            return $$typeof;\n        }\n      }\n\n      return undefined;\n    }\n\n    var ContextConsumer = REACT_CONTEXT_TYPE;\n    var ContextProvider = REACT_PROVIDER_TYPE;\n    var Element = REACT_ELEMENT_TYPE;\n    var ForwardRef = REACT_FORWARD_REF_TYPE;\n    var Fragment = REACT_FRAGMENT_TYPE;\n    var Lazy = REACT_LAZY_TYPE;\n    var Memo = REACT_MEMO_TYPE;\n    var Portal = REACT_PORTAL_TYPE;\n    var Profiler = REACT_PROFILER_TYPE;\n    var StrictMode = REACT_STRICT_MODE_TYPE;\n    var Suspense = REACT_SUSPENSE_TYPE;\n    var SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n    var hasWarnedAboutDeprecatedIsAsyncMode = false;\n    var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated\n\n    function isAsyncMode(object) {\n      {\n        if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n          hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n          console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n        }\n      }\n      return false;\n    }\n\n    function isConcurrentMode(object) {\n      {\n        if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n          hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint\n\n          console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n        }\n      }\n      return false;\n    }\n\n    function isContextConsumer(object) {\n      return typeOf(object) === REACT_CONTEXT_TYPE;\n    }\n\n    function isContextProvider(object) {\n      return typeOf(object) === REACT_PROVIDER_TYPE;\n    }\n\n    function isElement(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n\n    function isForwardRef(object) {\n      return typeOf(object) === REACT_FORWARD_REF_TYPE;\n    }\n\n    function isFragment(object) {\n      return typeOf(object) === REACT_FRAGMENT_TYPE;\n    }\n\n    function isLazy(object) {\n      return typeOf(object) === REACT_LAZY_TYPE;\n    }\n\n    function isMemo(object) {\n      return typeOf(object) === REACT_MEMO_TYPE;\n    }\n\n    function isPortal(object) {\n      return typeOf(object) === REACT_PORTAL_TYPE;\n    }\n\n    function isProfiler(object) {\n      return typeOf(object) === REACT_PROFILER_TYPE;\n    }\n\n    function isStrictMode(object) {\n      return typeOf(object) === REACT_STRICT_MODE_TYPE;\n    }\n\n    function isSuspense(object) {\n      return typeOf(object) === REACT_SUSPENSE_TYPE;\n    }\n\n    function isSuspenseList(object) {\n      return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n    }\n\n    exports.ContextConsumer = ContextConsumer;\n    exports.ContextProvider = ContextProvider;\n    exports.Element = Element;\n    exports.ForwardRef = ForwardRef;\n    exports.Fragment = Fragment;\n    exports.Lazy = Lazy;\n    exports.Memo = Memo;\n    exports.Portal = Portal;\n    exports.Profiler = Profiler;\n    exports.StrictMode = StrictMode;\n    exports.Suspense = Suspense;\n    exports.SuspenseList = SuspenseList;\n    exports.isAsyncMode = isAsyncMode;\n    exports.isConcurrentMode = isConcurrentMode;\n    exports.isContextConsumer = isContextConsumer;\n    exports.isContextProvider = isContextProvider;\n    exports.isElement = isElement;\n    exports.isForwardRef = isForwardRef;\n    exports.isFragment = isFragment;\n    exports.isLazy = isLazy;\n    exports.isMemo = isMemo;\n    exports.isPortal = isPortal;\n    exports.isProfiler = isProfiler;\n    exports.isStrictMode = isStrictMode;\n    exports.isSuspense = isSuspense;\n    exports.isSuspenseList = isSuspenseList;\n    exports.isValidElementType = isValidElementType;\n    exports.typeOf = typeOf;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvcG9tYmVyL3AvZGV2L3JlYWN0L2J1aWxkL29zcy1leHBlcmltZW50YWwvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzP2Y5MjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHZ1bmRlZmluZWRcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IDB4ZWFlNDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG4gIFJFQUNUX0NBQ0hFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNhY2hlJyk7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IDA7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgIHR5cGUgPT09IFJFQUNUX0NBQ0hFX1RZUEUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBTdXNwZW5zZUxpc3QgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0NvbmN1cnJlbnRNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUxpc3Qob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xufVxuXG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuU3VzcGVuc2VMaXN0ID0gU3VzcGVuc2VMaXN0O1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzU3VzcGVuc2VMaXN0ID0gaXNTdXNwZW5zZUxpc3Q7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVpBO0FBQ0E7QUF3QkE7QUFDQTtBQTlCQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react-is/cjs/react-is.development.js\n");

/***/ }),

/***/ "../../build/oss-experimental/react-is/index.js":
/*!*************************************************************************!*\
  !*** /home/pomber/p/dev/react/build/oss-experimental/react-is/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"../../build/oss-experimental/react-is/cjs/react-is.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC1pcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9wb21iZXIvcC9kZXYvcmVhY3QvYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC1pcy9pbmRleC5qcz84N2UzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react-is/index.js\n");

/***/ }),

/***/ "../../build/oss-experimental/react/cjs/react.development.js":
/*!**************************************************************************************!*\
  !*** /home/pomber/p/dev/react/build/oss-experimental/react/cjs/react.development.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {/** @license React vundefined\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n\n    var _assign = __webpack_require__(/*! object-assign */ \"../../node_modules/object-assign/index.js\"); // TODO: this is special because it gets imported during build.\n    //\n    // TODO: 17.0.3 has not been released to NPM;\n    // It exists as a placeholder so that DevTools can support work tag changes between releases.\n    // When we next publish a release (either 17.0.3 or 17.1.0), update the matching TODO in backend/renderer.js\n    // TODO: This module is used both by the release scripts and to expose a version\n    // at runtime. We should instead inject the version number as part of the build\n    // process, and use the ReactVersions.js module as the single source of truth.\n\n\n    var ReactVersion = '17.0.3'; // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    exports.Fragment = 0xeacb;\n    exports.StrictMode = 0xeacc;\n    exports.Profiler = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    exports.Suspense = 0xead1;\n    exports.SuspenseList = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_SCOPE_TYPE = 0xead7;\n    exports.unstable_DebugTracingMode = 0xeae1;\n    exports.unstable_Offscreen = 0xeae2;\n    exports.unstable_LegacyHidden = 0xeae3;\n    exports.unstable_Cache = 0xeae4;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      exports.Fragment = symbolFor('react.fragment');\n      exports.StrictMode = symbolFor('react.strict_mode');\n      exports.Profiler = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      exports.Suspense = symbolFor('react.suspense');\n      exports.SuspenseList = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      exports.unstable_DebugTracingMode = symbolFor('react.debug_trace_mode');\n      exports.unstable_Offscreen = symbolFor('react.offscreen');\n      exports.unstable_LegacyHidden = symbolFor('react.legacy_hidden');\n      exports.unstable_Cache = symbolFor('react.cache');\n    }\n\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n    /**\n     * Keeps track of the current dispatcher.\n     */\n\n\n    var ReactCurrentDispatcher = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    /**\n     * Keeps track of the current batch's configuration such as how long an update\n     * should suspend for if it needs to.\n     */\n\n    var ReactCurrentBatchConfig = {\n      transition: 0\n    };\n    {\n      ReactCurrentBatchConfig._updatedFibers = new Set();\n    }\n    var ReactCurrentActQueue = {\n      current: null,\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n      isBatchingLegacy: false,\n      didScheduleLegacyUpdate: false\n    };\n    /**\n     * Keeps track of the current owner.\n     *\n     * The current owner is the component who should own any components that are\n     * currently being constructed.\n     */\n\n    var ReactCurrentOwner = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    var ReactDebugCurrentFrame = {};\n    var currentExtraStackFrame = null;\n\n    function setExtraStackFrame(stack) {\n      {\n        currentExtraStackFrame = stack;\n      }\n    }\n\n    {\n      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n        {\n          currentExtraStackFrame = stack;\n        }\n      }; // Stack implementation injected by the current renderer.\n\n\n      ReactDebugCurrentFrame.getCurrentStack = null;\n\n      ReactDebugCurrentFrame.getStackAddendum = function () {\n        var stack = ''; // Add an extra top frame while an element is being validated\n\n        if (currentExtraStackFrame) {\n          stack += currentExtraStackFrame;\n        } // Delegate to the injected renderer-specific implementation\n\n\n        var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n        if (impl) {\n          stack += impl() || '';\n        }\n\n        return stack;\n      };\n    }\n    var ReactSharedInternals = {\n      ReactCurrentDispatcher: ReactCurrentDispatcher,\n      ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n      ReactCurrentOwner: ReactCurrentOwner,\n      // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n      assign: _assign\n    };\n    {\n      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n    } // by calls to these methods by a Babel plugin.\n    //\n    // In PROD (or in packages without access to React internals),\n    // they are left as they are instead.\n\n    function warn(format) {\n      {\n        {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          printWarning('warn', format, args);\n        }\n      }\n    }\n\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          printWarning('error', format, args);\n        }\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n\n    var didWarnStateUpdateForUnmountedComponent = {};\n\n    function warnNoop(publicInstance, callerName) {\n      {\n        var _constructor = publicInstance.constructor;\n        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n        var warningKey = componentName + \".\" + callerName;\n\n        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n          return;\n        }\n\n        error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n      }\n    }\n    /**\n     * This is the abstract API for an update queue.\n     */\n\n\n    var ReactNoopUpdateQueue = {\n      /**\n       * Checks whether or not this composite component is mounted.\n       * @param {ReactClass} publicInstance The instance we want to test.\n       * @return {boolean} True if mounted, false otherwise.\n       * @protected\n       * @final\n       */\n      isMounted: function (publicInstance) {\n        return false;\n      },\n\n      /**\n       * Forces an update. This should only be invoked when it is known with\n       * certainty that we are **not** in a DOM transaction.\n       *\n       * You may want to call this when you know that some deeper aspect of the\n       * component's state has changed but `setState` was not called.\n       *\n       * This will not invoke `shouldComponentUpdate`, but it will invoke\n       * `componentWillUpdate` and `componentDidUpdate`.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueForceUpdate: function (publicInstance, callback, callerName) {\n        warnNoop(publicInstance, 'forceUpdate');\n      },\n\n      /**\n       * Replaces all of the state. Always use this or `setState` to mutate state.\n       * You should treat `this.state` as immutable.\n       *\n       * There is no guarantee that `this.state` will be immediately updated, so\n       * accessing `this.state` after calling this method may return the old value.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} completeState Next state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n        warnNoop(publicInstance, 'replaceState');\n      },\n\n      /**\n       * Sets a subset of the state. This only exists because _pendingState is\n       * internal. This provides a merging strategy that is not available to deep\n       * properties which is confusing. TODO: Expose pendingState or don't use it\n       * during the merge.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} partialState Next partial state to be merged with state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} Name of the calling function in the public API.\n       * @internal\n       */\n      enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n        warnNoop(publicInstance, 'setState');\n      }\n    };\n    var emptyObject = {};\n    {\n      Object.freeze(emptyObject);\n    }\n    /**\n     * Base class helpers for the updating state of a component.\n     */\n\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n      // renderer.\n\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n\n    Component.prototype.isReactComponent = {};\n    /**\n     * Sets a subset of the state. Always use this to mutate\n     * state. You should treat `this.state` as immutable.\n     *\n     * There is no guarantee that `this.state` will be immediately updated, so\n     * accessing `this.state` after calling this method may return the old value.\n     *\n     * There is no guarantee that calls to `setState` will run synchronously,\n     * as they may eventually be batched together.  You can provide an optional\n     * callback that will be executed when the call to setState is actually\n     * completed.\n     *\n     * When a function is provided to setState, it will be called at some point in\n     * the future (not synchronously). It will be called with the up to date\n     * component arguments (state, props, context). These values can be different\n     * from this.* because your function may be called after receiveProps but before\n     * shouldComponentUpdate, and this new state, props, and context will not yet be\n     * assigned to this.\n     *\n     * @param {object|function} partialState Next partial state or function to\n     *        produce next partial state to be merged with current state.\n     * @param {?function} callback Called after state is updated.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.setState = function (partialState, callback) {\n      if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n      }\n\n      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n    };\n    /**\n     * Forces an update. This should only be invoked when it is known with\n     * certainty that we are **not** in a DOM transaction.\n     *\n     * You may want to call this when you know that some deeper aspect of the\n     * component's state has changed but `setState` was not called.\n     *\n     * This will not invoke `shouldComponentUpdate`, but it will invoke\n     * `componentWillUpdate` and `componentDidUpdate`.\n     *\n     * @param {?function} callback Called after update is complete.\n     * @final\n     * @protected\n     */\n\n\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n    };\n    /**\n     * Deprecated APIs. These APIs used to exist on classic React classes but since\n     * we would like to deprecate them, we're not going to move them over to this\n     * modern base class. Instead, we define a getter that warns if it's accessed.\n     */\n\n\n    {\n      var deprecatedAPIs = {\n        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n      };\n\n      var defineDeprecationWarning = function (methodName, info) {\n        Object.defineProperty(Component.prototype, methodName, {\n          get: function () {\n            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n            return undefined;\n          }\n        });\n      };\n\n      for (var fnName in deprecatedAPIs) {\n        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n        }\n      }\n    }\n\n    function ComponentDummy() {}\n\n    ComponentDummy.prototype = Component.prototype;\n    /**\n     * Convenience component with default shallow equality check for sCU.\n     */\n\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n\n    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n    _assign(pureComponentPrototype, Component.prototype);\n\n    pureComponentPrototype.isPureReactComponent = true; // an immutable object with a single mutable value\n\n    function createRef() {\n      var refObject = {\n        current: null\n      };\n      {\n        Object.seal(refObject);\n      }\n      return refObject;\n    }\n\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n\n      if (displayName) {\n        return displayName;\n      }\n\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case exports.Fragment:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case exports.Profiler:\n          return 'Profiler';\n\n        case exports.StrictMode:\n          return 'StrictMode';\n\n        case exports.Suspense:\n          return 'Suspense';\n\n        case exports.SuspenseList:\n          return 'SuspenseList';\n\n        case exports.unstable_Cache:\n          return 'Cache';\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n\n            if (outerName !== null) {\n              return outerName;\n            }\n\n            return getComponentNameFromType(type.type) || 'Memo';\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n        }\n      }\n\n      return null;\n    }\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      var warnAboutAccessingKey = function () {\n        {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n\n      warnAboutAccessingKey.isReactWarning = true;\n      Object.defineProperty(props, 'key', {\n        get: warnAboutAccessingKey,\n        configurable: true\n      });\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      var warnAboutAccessingRef = function () {\n        {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * Create and return a new ReactElement of the given type.\n     * See https://reactjs.org/docs/react-api.html#createelement\n     */\n\n\n    function createElement(type, config, children) {\n      var propName; // Reserved names are extracted\n\n      var props = {};\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          {\n            warnIfStringRefCannotBeAutoConverted(config);\n          }\n        }\n\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n\n      var childrenLength = arguments.length - 2;\n\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n\n        {\n          if (Object.freeze) {\n            Object.freeze(childArray);\n          }\n        }\n        props.children = childArray;\n      } // Resolve default props\n\n\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n\n      {\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n      }\n      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n    }\n\n    function cloneAndReplaceKey(oldElement, newKey) {\n      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n      return newElement;\n    }\n    /**\n     * Clone and return a new ReactElement using element as the starting point.\n     * See https://reactjs.org/docs/react-api.html#cloneelement\n     */\n\n\n    function cloneElement(element, config, children) {\n      if (element === null || element === undefined) {\n        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n      }\n\n      var propName; // Original props are copied\n\n      var props = _assign({}, element.props); // Reserved names are extracted\n\n\n      var key = element.key;\n      var ref = element.ref; // Self is preserved since the owner is preserved.\n\n      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n\n      var source = element._source; // Owner will be preserved, unless ref is overridden\n\n      var owner = element._owner;\n\n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        } // Remaining properties override existing props\n\n\n        var defaultProps;\n\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n\n      var childrenLength = arguments.length - 2;\n\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n\n        props.children = childArray;\n      }\n\n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n\n    function isValidElement(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n    /**\n     * Escape and wrap key so it is safe to use as a reactid\n     *\n     * @param {string} key to be escaped.\n     * @return {string} the escaped key.\n     */\n\n    function escape(key) {\n      var escapeRegex = /[=:]/g;\n      var escaperLookup = {\n        '=': '=0',\n        ':': '=2'\n      };\n      var escapedString = key.replace(escapeRegex, function (match) {\n        return escaperLookup[match];\n      });\n      return '$' + escapedString;\n    }\n    /**\n     * TODO: Test that a single child and an array with one item have the same key\n     * pattern.\n     */\n\n\n    var didWarnAboutMaps = false;\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n\n    function escapeUserProvidedKey(text) {\n      return text.replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n    /**\n     * Generate a key string that identifies a element within a set.\n     *\n     * @param {*} element A element that could contain a manual key.\n     * @param {number} index Index that is used if a manual key is not provided.\n     * @return {string}\n     */\n\n\n    function getElementKey(element, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if (typeof element === 'object' && element !== null && element.key != null) {\n        // Explicit key\n        {\n          checkKeyStringCoercion(element.key);\n        }\n        return escape('' + element.key);\n      } // Implicit key determined by the index in the set\n\n\n      return index.toString(36);\n    }\n\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = typeof children;\n\n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n\n      var invokeCallback = false;\n\n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n\n        }\n      }\n\n      if (invokeCallback) {\n        var _child = children;\n        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n        // so that it's consistent if the number of children grows:\n\n        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n\n        if (isArray(mappedChild)) {\n          var escapedChildKey = '';\n\n          if (childKey != null) {\n            escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n          }\n\n          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n            return c;\n          });\n        } else if (mappedChild != null) {\n          if (isValidElement(mappedChild)) {\n            {\n              // The `if` statement here prevents auto-disabling of the safe\n              // coercion ESLint rule, so we must manually disable it below.\n              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                checkKeyStringCoercion(mappedChild.key);\n              }\n            }\n            mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n          }\n\n          array.push(mappedChild);\n        }\n\n        return 1;\n      }\n\n      var child;\n      var nextName;\n      var subtreeCount = 0; // Count of children found in the current subtree.\n\n      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getElementKey(child, i);\n          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          var iterableChildren = children;\n          {\n            // Warn about using Maps as children\n            if (iteratorFn === iterableChildren.entries) {\n              if (!didWarnAboutMaps) {\n                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n              }\n\n              didWarnAboutMaps = true;\n            }\n          }\n          var iterator = iteratorFn.call(iterableChildren);\n          var step;\n          var ii = 0;\n\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getElementKey(child, ii++);\n            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n          }\n        } else if (type === 'object') {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          var childrenString = String(children);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n      }\n\n      return subtreeCount;\n    }\n    /**\n     * Maps children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n     *\n     * The provided mapFunction(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} func The map function.\n     * @param {*} context Context for mapFunction.\n     * @return {object} Object containing the ordered map of results.\n     */\n\n\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n\n      var result = [];\n      var count = 0;\n      mapIntoArray(children, result, '', '', function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    /**\n     * Count the number of children that are typically specified as\n     * `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n     *\n     * @param {?*} children Children tree container.\n     * @return {number} The number of children.\n     */\n\n\n    function countChildren(children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++; // Don't return anything\n      });\n      return n;\n    }\n    /**\n     * Iterates through children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n     *\n     * The provided forEachFunc(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} forEachFunc\n     * @param {*} forEachContext Context for forEachContext.\n     */\n\n\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      mapChildren(children, function () {\n        forEachFunc.apply(this, arguments); // Don't return anything.\n      }, forEachContext);\n    }\n    /**\n     * Flatten a children object (typically specified as `props.children`) and\n     * return an array with appropriately re-keyed children.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n     */\n\n\n    function toArray(children) {\n      return mapChildren(children, function (child) {\n        return child;\n      }) || [];\n    }\n    /**\n     * Returns the first child in a collection of children and verifies that there\n     * is only one child in the collection.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n     *\n     * The current implementation of this function assumes that a single child gets\n     * passed without a wrapper, but the purpose of this helper function is to\n     * abstract away the particular structure of children.\n     *\n     * @param {?object} children Child collection structure.\n     * @return {ReactElement} The first and only `ReactElement` contained in the\n     * structure.\n     */\n\n\n    function onlyChild(children) {\n      if (!isValidElement(children)) {\n        throw new Error('React.Children.only expected to receive a single React element child.');\n      }\n\n      return children;\n    }\n\n    function createContext(defaultValue) {\n      // TODO: Second argument used to be an optional `calculateChangedBits`\n      // function. Warn to reserve for future use?\n      var context = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        // As a workaround to support multiple concurrent renderers, we categorize\n        // some renderers as primary and others as secondary. We only expect\n        // there to be two concurrent renderers at most: React Native (primary) and\n        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n        // Secondary renderers store their context values on separate fields.\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        // Used to track how many concurrent renderers this context currently\n        // supports within in a single renderer. Such as parallel server rendering.\n        _threadCount: 0,\n        // These are circular\n        Provider: null,\n        Consumer: null\n      };\n      context.Provider = {\n        $$typeof: REACT_PROVIDER_TYPE,\n        _context: context\n      };\n      var hasWarnedAboutUsingNestedContextConsumers = false;\n      var hasWarnedAboutUsingConsumerProvider = false;\n      var hasWarnedAboutDisplayNameOnConsumer = false;\n      {\n        // A separate object, but proxies back to the original context object for\n        // backwards compatibility. It has a different $$typeof, so we can properly\n        // warn for the incorrect usage of Context as a Consumer.\n        var Consumer = {\n          $$typeof: REACT_CONTEXT_TYPE,\n          _context: context\n        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n        Object.defineProperties(Consumer, {\n          Provider: {\n            get: function () {\n              if (!hasWarnedAboutUsingConsumerProvider) {\n                hasWarnedAboutUsingConsumerProvider = true;\n                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n              }\n\n              return context.Provider;\n            },\n            set: function (_Provider) {\n              context.Provider = _Provider;\n            }\n          },\n          _currentValue: {\n            get: function () {\n              return context._currentValue;\n            },\n            set: function (_currentValue) {\n              context._currentValue = _currentValue;\n            }\n          },\n          _currentValue2: {\n            get: function () {\n              return context._currentValue2;\n            },\n            set: function (_currentValue2) {\n              context._currentValue2 = _currentValue2;\n            }\n          },\n          _threadCount: {\n            get: function () {\n              return context._threadCount;\n            },\n            set: function (_threadCount) {\n              context._threadCount = _threadCount;\n            }\n          },\n          Consumer: {\n            get: function () {\n              if (!hasWarnedAboutUsingNestedContextConsumers) {\n                hasWarnedAboutUsingNestedContextConsumers = true;\n                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n              }\n\n              return context.Consumer;\n            }\n          },\n          displayName: {\n            get: function () {\n              return context.displayName;\n            },\n            set: function (displayName) {\n              if (!hasWarnedAboutDisplayNameOnConsumer) {\n                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                hasWarnedAboutDisplayNameOnConsumer = true;\n              }\n            }\n          }\n        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n        context.Consumer = Consumer;\n      }\n      {\n        context._currentRenderer = null;\n        context._currentRenderer2 = null;\n      }\n      return context;\n    }\n\n    var Uninitialized = -1;\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n\n    function lazyInitializer(payload) {\n      if (payload._status === Uninitialized) {\n        var ctor = payload._result;\n        var thenable = ctor(); // Transition to the next state.\n        // This might throw either because it's missing or throws. If so, we treat it\n        // as still uninitialized and try again next time. Which is the same as what\n        // happens if the ctor or any wrappers processing the ctor throws. This might\n        // end up fixing it if the resolution was a concurrency bug.\n\n        thenable.then(function (moduleObject) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var resolved = payload;\n            resolved._status = Resolved;\n            resolved._result = moduleObject;\n          }\n        }, function (error) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var rejected = payload;\n            rejected._status = Rejected;\n            rejected._result = error;\n          }\n        });\n\n        if (payload._status === Uninitialized) {\n          // In case, we're still uninitialized, then we're waiting for the thenable\n          // to resolve. Set it as pending in the meantime.\n          var pending = payload;\n          pending._status = Pending;\n          pending._result = thenable;\n        }\n      }\n\n      if (payload._status === Resolved) {\n        var moduleObject = payload._result;\n        {\n          if (moduleObject === undefined) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n          }\n        }\n        {\n          if (!('default' in moduleObject)) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n          }\n        }\n        return moduleObject.default;\n      } else {\n        throw payload._result;\n      }\n    }\n\n    function lazy(ctor) {\n      var payload = {\n        // We use these fields to store the result.\n        _status: Uninitialized,\n        _result: ctor\n      };\n      var lazyType = {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: payload,\n        _init: lazyInitializer\n      };\n      {\n        // In production, this would just set it on the object.\n        var defaultProps;\n        var propTypes; // $FlowFixMe\n\n        Object.defineProperties(lazyType, {\n          defaultProps: {\n            configurable: true,\n            get: function () {\n              return defaultProps;\n            },\n            set: function (newDefaultProps) {\n              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              defaultProps = newDefaultProps; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'defaultProps', {\n                enumerable: true\n              });\n            }\n          },\n          propTypes: {\n            configurable: true,\n            get: function () {\n              return propTypes;\n            },\n            set: function (newPropTypes) {\n              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              propTypes = newPropTypes; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'propTypes', {\n                enumerable: true\n              });\n            }\n          }\n        });\n      }\n      return lazyType;\n    }\n\n    function forwardRef(render) {\n      {\n        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n        } else if (typeof render !== 'function') {\n          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n        } else {\n          if (render.length !== 0 && render.length !== 2) {\n            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n          }\n        }\n\n        if (render != null) {\n          if (render.defaultProps != null || render.propTypes != null) {\n            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n          }\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_FORWARD_REF_TYPE,\n        render: render\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function () {\n            return ownName;\n          },\n          set: function (name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.forwardRef((props, ref) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!render.name && !render.displayName) {\n              render.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    var warnOnSubscriptionInsideStartTransition = false;\n    var REACT_MODULE_REFERENCE = 0;\n\n    if (typeof Symbol === 'function') {\n      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n    }\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === exports.Fragment || type === exports.Profiler || type === exports.unstable_DebugTracingMode || type === exports.StrictMode || type === exports.Suspense || type === exports.SuspenseList || type === exports.unstable_LegacyHidden || type === exports.unstable_Offscreen || enableScopeAPI || type === exports.unstable_Cache) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function memo(type, compare) {\n      {\n        if (!isValidElementType(type)) {\n          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: compare === undefined ? null : compare\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function () {\n            return ownName;\n          },\n          set: function (name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.memo((props) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!type.name && !type.displayName) {\n              type.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n\n    function resolveDispatcher() {\n      var dispatcher = ReactCurrentDispatcher.current;\n      {\n        if (dispatcher === null) {\n          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n      } // Will result in a null access error if accessed outside render phase. We\n      // intentionally don't throw our own error because this is in a hot path.\n      // Also helps ensure this is inlined.\n\n      return dispatcher;\n    }\n\n    function getCacheSignal() {\n      var dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n      return dispatcher.getCacheSignal();\n    }\n\n    function getCacheForType(resourceType) {\n      var dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n      return dispatcher.getCacheForType(resourceType);\n    }\n\n    function useContext(Context) {\n      var dispatcher = resolveDispatcher();\n      {\n        // TODO: add a more generic warning for invalid values.\n        if (Context._context !== undefined) {\n          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n          // and nobody should be using this in existing code.\n\n          if (realContext.Consumer === Context) {\n            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n          } else if (realContext.Provider === Context) {\n            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n          }\n        }\n      }\n      return dispatcher.useContext(Context);\n    }\n\n    function useState(initialState) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useState(initialState);\n    }\n\n    function useReducer(reducer, initialArg, init) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useReducer(reducer, initialArg, init);\n    }\n\n    function useRef(initialValue) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useRef(initialValue);\n    }\n\n    function useEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useEffect(create, deps);\n    }\n\n    function useInsertionEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useInsertionEffect(create, deps);\n    }\n\n    function useLayoutEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useLayoutEffect(create, deps);\n    }\n\n    function useCallback(callback, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useCallback(callback, deps);\n    }\n\n    function useMemo(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useMemo(create, deps);\n    }\n\n    function useImperativeHandle(ref, create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useImperativeHandle(ref, create, deps);\n    }\n\n    function useDebugValue(value, formatterFn) {\n      {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useDebugValue(value, formatterFn);\n      }\n    }\n\n    function useTransition() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useTransition();\n    }\n\n    function useDeferredValue(value) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useDeferredValue(value);\n    }\n\n    function useId() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useId();\n    }\n\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n\n    function useCacheRefresh() {\n      var dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n      return dispatcher.useCacheRefresh();\n    } // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: _assign({}, props, {\n              value: prevLog\n            }),\n            info: _assign({}, props, {\n              value: prevInfo\n            }),\n            warn: _assign({}, props, {\n              value: prevWarn\n            }),\n            error: _assign({}, props, {\n              value: prevError\n            }),\n            group: _assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: _assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: _assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher$1.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher$1.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case exports.Suspense:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case exports.SuspenseList:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          setExtraStackFrame(stack);\n        } else {\n          setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n\n    function getDeclarationErrorAddendum() {\n      if (ReactCurrentOwner.current) {\n        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n        if (name) {\n          return '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n\n      return '';\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      if (source !== undefined) {\n        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n        var lineNumber = source.lineNumber;\n        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n      }\n\n      return '';\n    }\n\n    function getSourceInfoErrorAddendumForProps(elementProps) {\n      if (elementProps !== null && elementProps !== undefined) {\n        return getSourceInfoErrorAddendum(elementProps.__source);\n      }\n\n      return '';\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = getDeclarationErrorAddendum();\n\n      if (!info) {\n        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n        if (parentName) {\n          info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n        }\n      }\n\n      return info;\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      if (!element._store || element._store.validated || element.key != null) {\n        return;\n      }\n\n      element._store.validated = true;\n      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n        return;\n      }\n\n      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n      // property, it may be the creator of the child that's responsible for\n      // assigning it a key.\n\n      var childOwner = '';\n\n      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n        // Give the component that originally created this child.\n        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n      }\n\n      {\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      if (typeof node !== 'object') {\n        return;\n      }\n\n      if (isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          var child = node[i];\n\n          if (isValidElement(child)) {\n            validateExplicitKey(child, parentType);\n          }\n        }\n      } else if (isValidElement(node)) {\n        // This element was passed in a valid location.\n        if (node._store) {\n          node._store.validated = true;\n        }\n      } else if (node) {\n        var iteratorFn = getIteratorFn(node);\n\n        if (typeof iteratorFn === 'function') {\n          // Entry iterators used to provide implicit keys,\n          // but now we print a separate warning for them later.\n          if (iteratorFn !== node.entries) {\n            var iterator = iteratorFn.call(node);\n            var step;\n\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function createElementWithValidation(type, props, children) {\n      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n\n      if (!validType) {\n        var info = '';\n\n        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n        }\n\n        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n        if (sourceInfo) {\n          info += sourceInfo;\n        } else {\n          info += getDeclarationErrorAddendum();\n        }\n\n        var typeString;\n\n        if (type === null) {\n          typeString = 'null';\n        } else if (isArray(type)) {\n          typeString = 'array';\n        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n          typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n          info = ' Did you accidentally export a JSX literal instead of a component?';\n        } else {\n          typeString = typeof type;\n        }\n\n        {\n          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n      }\n\n      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n      // TODO: Drop this when these are no longer allowed as the type argument.\n\n      if (element == null) {\n        return element;\n      } // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing errors.\n      // We don't want exception behavior to differ between dev and prod.\n      // (Rendering will throw with a helpful message and as soon as the type is\n      // fixed, the key warnings will appear.)\n\n\n      if (validType) {\n        for (var i = 2; i < arguments.length; i++) {\n          validateChildKeys(arguments[i], type);\n        }\n      }\n\n      if (type === exports.Fragment) {\n        validateFragmentProps(element);\n      } else {\n        validatePropTypes(element);\n      }\n\n      return element;\n    }\n\n    var didWarnAboutDeprecatedCreateFactory = false;\n\n    function createFactoryWithValidation(type) {\n      var validatedFactory = createElementWithValidation.bind(null, type);\n      validatedFactory.type = type;\n      {\n        if (!didWarnAboutDeprecatedCreateFactory) {\n          didWarnAboutDeprecatedCreateFactory = true;\n          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n        } // Legacy hook: remove it\n\n\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function () {\n            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n      return validatedFactory;\n    }\n\n    function cloneElementWithValidation(element, props, children) {\n      var newElement = cloneElement.apply(this, arguments);\n\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], newElement.type);\n      }\n\n      validatePropTypes(newElement);\n      return newElement;\n    }\n\n    function createMutableSource(source, getVersion) {\n      var mutableSource = {\n        _getVersion: getVersion,\n        _source: source,\n        _workInProgressVersionPrimary: null,\n        _workInProgressVersionSecondary: null\n      };\n      {\n        mutableSource._currentPrimaryRenderer = null;\n        mutableSource._currentSecondaryRenderer = null; // Used to detect side effects that update a mutable source during render.\n        // See https://github.com/facebook/react/issues/19948\n\n        mutableSource._currentlyRenderingFiber = null;\n        mutableSource._initialVersionAsOfFirstRender = null;\n      }\n      return mutableSource;\n    }\n\n    function startTransition(scope) {\n      var prevTransition = ReactCurrentBatchConfig.transition;\n      ReactCurrentBatchConfig.transition = 1;\n\n      try {\n        scope();\n      } finally {\n        ReactCurrentBatchConfig.transition = prevTransition;\n        {\n          if (prevTransition !== 1 && warnOnSubscriptionInsideStartTransition && ReactCurrentBatchConfig._updatedFibers) {\n            var updatedFibersCount = ReactCurrentBatchConfig._updatedFibers.size;\n\n            if (updatedFibersCount > 10) {\n              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n            }\n\n            ReactCurrentBatchConfig._updatedFibers.clear();\n          }\n        }\n      }\n    }\n\n    var didWarnAboutMessageChannel = false;\n    var enqueueTaskImpl = null;\n\n    function enqueueTask(task) {\n      if (enqueueTaskImpl === null) {\n        try {\n          // read require off the module object to get around the bundlers.\n          // we don't want them to detect a require and bundle a Node polyfill.\n          var requireString = ('require' + Math.random()).slice(0, 7);\n          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n          // version of setImmediate, bypassing fake timers if any.\n\n          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n        } catch (_err) {\n          // we're in a browser\n          // we can't use regular timers because they may still be faked\n          // so we try MessageChannel+postMessage instead\n          enqueueTaskImpl = function (callback) {\n            {\n              if (didWarnAboutMessageChannel === false) {\n                didWarnAboutMessageChannel = true;\n\n                if (typeof MessageChannel === 'undefined') {\n                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n                }\n              }\n            }\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(undefined);\n          };\n        }\n      }\n\n      return enqueueTaskImpl(task);\n    }\n\n    var actScopeDepth = 0;\n    var didWarnNoAwaitAct = false;\n\n    function act(callback) {\n      {\n        // `act` calls can be nested, so we track the depth. This represents the\n        // number of `act` scopes on the stack.\n        var prevActScopeDepth = actScopeDepth;\n        actScopeDepth++;\n\n        if (ReactCurrentActQueue.current === null) {\n          // This is the outermost `act` scope. Initialize the queue. The reconciler\n          // will detect the queue and use it instead of Scheduler.\n          ReactCurrentActQueue.current = [];\n        }\n\n        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n        var result;\n\n        try {\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n          // set to `true` while the given callback is executed, not for updates\n          // triggered during an async event, because this is how the legacy\n          // implementation of `act` behaved.\n          ReactCurrentActQueue.isBatchingLegacy = true;\n          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n          // which flushed updates immediately after the scope function exits, even\n          // if it's an async function.\n\n          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n            var queue = ReactCurrentActQueue.current;\n\n            if (queue !== null) {\n              ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n              flushActQueue(queue);\n            }\n          }\n        } catch (error) {\n          popActScope(prevActScopeDepth);\n          throw error;\n        } finally {\n          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n        }\n\n        if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n          // for it to resolve before exiting the current scope.\n\n          var wasAwaited = false;\n          var thenable = {\n            then: function (resolve, reject) {\n              wasAwaited = true;\n              thenableResult.then(function (returnValue) {\n                popActScope(prevActScopeDepth);\n\n                if (actScopeDepth === 0) {\n                  // We've exited the outermost act scope. Recursively flush the\n                  // queue until there's no remaining work.\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }, function (error) {\n                // The callback threw an error.\n                popActScope(prevActScopeDepth);\n                reject(error);\n              });\n            }\n          };\n          {\n            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n              // eslint-disable-next-line no-undef\n              Promise.resolve().then(function () {}).then(function () {\n                if (!wasAwaited) {\n                  didWarnNoAwaitAct = true;\n                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n                }\n              });\n            }\n          }\n          return thenable;\n        } else {\n          var returnValue = result; // The callback is not an async function. Exit the current scope\n          // immediately, without awaiting.\n\n          popActScope(prevActScopeDepth);\n\n          if (actScopeDepth === 0) {\n            // Exiting the outermost act scope. Flush the queue.\n            var _queue = ReactCurrentActQueue.current;\n\n            if (_queue !== null) {\n              flushActQueue(_queue);\n              ReactCurrentActQueue.current = null;\n            } // Return a thenable. If the user awaits it, we'll flush again in\n            // case additional work was scheduled by a microtask.\n\n\n            var _thenable = {\n              then: function (resolve, reject) {\n                // Confirm we haven't re-entered another `act` scope, in case\n                // the user does something weird like await the thenable\n                // multiple times.\n                if (ReactCurrentActQueue.current === null) {\n                  // Recursively flush the queue until there's no remaining work.\n                  ReactCurrentActQueue.current = [];\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }\n            };\n            return _thenable;\n          } else {\n            // Since we're inside a nested `act` scope, the returned thenable\n            // immediately resolves. The outer scope will flush the queue.\n            var _thenable2 = {\n              then: function (resolve, reject) {\n                resolve(returnValue);\n              }\n            };\n            return _thenable2;\n          }\n        }\n      }\n    }\n\n    function popActScope(prevActScopeDepth) {\n      {\n        if (prevActScopeDepth !== actScopeDepth - 1) {\n          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n        }\n\n        actScopeDepth = prevActScopeDepth;\n      }\n    }\n\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      {\n        var queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              if (queue.length === 0) {\n                // No additional work was scheduled. Finish.\n                ReactCurrentActQueue.current = null;\n                resolve(returnValue);\n              } else {\n                // Keep flushing work until there's none left.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n              }\n            });\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          resolve(returnValue);\n        }\n      }\n    }\n\n    var isFlushing = false;\n\n    function flushActQueue(queue) {\n      {\n        if (!isFlushing) {\n          // Prevent re-entrance.\n          isFlushing = true;\n          var i = 0;\n\n          try {\n            for (; i < queue.length; i++) {\n              var callback = queue[i];\n\n              do {\n                callback = callback(true);\n              } while (callback !== null);\n            }\n\n            queue.length = 0;\n          } catch (error) {\n            // If something throws, leave the remaining callbacks on the queue.\n            queue = queue.slice(i + 1);\n            throw error;\n          } finally {\n            isFlushing = false;\n          }\n        }\n      }\n    }\n\n    var createElement$1 = createElementWithValidation;\n    var cloneElement$1 = cloneElementWithValidation;\n    var createFactory = createFactoryWithValidation;\n    var Children = {\n      map: mapChildren,\n      forEach: forEachChildren,\n      count: countChildren,\n      toArray: toArray,\n      only: onlyChild\n    };\n    exports.Children = Children;\n    exports.Component = Component;\n    exports.PureComponent = PureComponent;\n    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n    exports.cloneElement = cloneElement$1;\n    exports.createContext = createContext;\n    exports.createElement = createElement$1;\n    exports.createFactory = createFactory;\n    exports.createRef = createRef;\n    exports.forwardRef = forwardRef;\n    exports.isValidElement = isValidElement;\n    exports.lazy = lazy;\n    exports.memo = memo;\n    exports.startTransition = startTransition;\n    exports.unstable_act = act;\n    exports.unstable_createMutableSource = createMutableSource;\n    exports.unstable_getCacheForType = getCacheForType;\n    exports.unstable_getCacheSignal = getCacheSignal;\n    exports.unstable_useCacheRefresh = useCacheRefresh;\n    exports.useCallback = useCallback;\n    exports.useContext = useContext;\n    exports.useDebugValue = useDebugValue;\n    exports.useDeferredValue = useDeferredValue;\n    exports.useEffect = useEffect;\n    exports.useId = useId;\n    exports.useImperativeHandle = useImperativeHandle;\n    exports.useInsertionEffect = useInsertionEffect;\n    exports.useLayoutEffect = useLayoutEffect;\n    exports.useMemo = useMemo;\n    exports.useReducer = useReducer;\n    exports.useRef = useRef;\n    exports.useState = useState;\n    exports.useSyncExternalStore = useSyncExternalStore;\n    exports.useTransition = useTransition;\n    exports.version = ReactVersion;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ \"../../node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvcG9tYmVyL3AvZGV2L3JlYWN0L2J1aWxkL29zcy1leHBlcmltZW50YWwvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzP2UzMTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHZ1bmRlZmluZWRcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgICAgdmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuLy9cbi8vIFRPRE86IDE3LjAuMyBoYXMgbm90IGJlZW4gcmVsZWFzZWQgdG8gTlBNO1xuLy8gSXQgZXhpc3RzIGFzIGEgcGxhY2Vob2xkZXIgc28gdGhhdCBEZXZUb29scyBjYW4gc3VwcG9ydCB3b3JrIHRhZyBjaGFuZ2VzIGJldHdlZW4gcmVsZWFzZXMuXG4vLyBXaGVuIHdlIG5leHQgcHVibGlzaCBhIHJlbGVhc2UgKGVpdGhlciAxNy4wLjMgb3IgMTcuMS4wKSwgdXBkYXRlIHRoZSBtYXRjaGluZyBUT0RPIGluIGJhY2tlbmQvcmVuZGVyZXIuanNcbi8vIFRPRE86IFRoaXMgbW9kdWxlIGlzIHVzZWQgYm90aCBieSB0aGUgcmVsZWFzZSBzY3JpcHRzIGFuZCB0byBleHBvc2UgYSB2ZXJzaW9uXG4vLyBhdCBydW50aW1lLiBXZSBzaG91bGQgaW5zdGVhZCBpbmplY3QgdGhlIHZlcnNpb24gbnVtYmVyIGFzIHBhcnQgb2YgdGhlIGJ1aWxkXG4vLyBwcm9jZXNzLCBhbmQgdXNlIHRoZSBSZWFjdFZlcnNpb25zLmpzIG1vZHVsZSBhcyB0aGUgc2luZ2xlIHNvdXJjZSBvZiB0cnV0aC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4zJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG5leHBvcnRzLlN0cmljdE1vZGUgPSAweGVhY2M7XG5leHBvcnRzLlByb2ZpbGVyID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnRzLlN1c3BlbnNlID0gMHhlYWQxO1xuZXhwb3J0cy5TdXNwZW5zZUxpc3QgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xuZXhwb3J0cy51bnN0YWJsZV9EZWJ1Z1RyYWNpbmdNb2RlID0gMHhlYWUxO1xuZXhwb3J0cy51bnN0YWJsZV9PZmZzY3JlZW4gPSAweGVhZTI7XG5leHBvcnRzLnVuc3RhYmxlX0xlZ2FjeUhpZGRlbiA9IDB4ZWFlMztcbmV4cG9ydHMudW5zdGFibGVfQ2FjaGUgPSAweGVhZTQ7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIGV4cG9ydHMuU3RyaWN0TW9kZSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgZXhwb3J0cy5Qcm9maWxlciA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2VMaXN0ID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgZXhwb3J0cy51bnN0YWJsZV9EZWJ1Z1RyYWNpbmdNb2RlID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIGV4cG9ydHMudW5zdGFibGVfT2Zmc2NyZWVuID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgZXhwb3J0cy51bnN0YWJsZV9MZWdhY3lIaWRkZW4gPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbiAgZXhwb3J0cy51bnN0YWJsZV9DYWNoZSA9IHN5bWJvbEZvcigncmVhY3QuY2FjaGUnKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiAwXG59O1xuXG57XG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xufVxuXG52YXIgUmVhY3RDdXJyZW50QWN0UXVldWUgPSB7XG4gIGN1cnJlbnQ6IG51bGwsXG4gIC8vIFVzZWQgdG8gcmVwcm9kdWNlIGJlaGF2aW9yIG9mIGBiYXRjaGVkVXBkYXRlc2AgaW4gbGVnYWN5IG1vZGUuXG4gIGlzQmF0Y2hpbmdMZWdhY3k6IGZhbHNlLFxuICBkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZTogZmFsc2Vcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgIT09ICdmdW5jdGlvbicgJiYgcGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgJyArICdmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJyk7XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIGV4cG9ydHMuUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlTGlzdDpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgZXhwb3J0cy51bnN0YWJsZV9DYWNoZTpcbiAgICAgIHJldHVybiAnQ2FjaGUnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiKTtcbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHtcbiAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oZWxlbWVudC5rZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoZSBgaWZgIHN0YXRlbWVudCBoZXJlIHByZXZlbnRzIGF1dG8tZGlzYWJsaW5nIG9mIHRoZSBzYWZlXG4gICAgICAgICAgLy8gY29lcmNpb24gRVNMaW50IHJ1bGUsIHNvIHdlIG11c3QgbWFudWFsbHkgZGlzYWJsZSBpdCBiZWxvdy5cbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgICBpZiAobWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkpIHtcbiAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWFwcGVkQ2hpbGQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgZXhpc3RpbmcgZWxlbWVudCdzIGtleSBjYW4gYmUgYSBudW1iZXJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gXCIgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgLy8gVE9ETzogU2Vjb25kIGFyZ3VtZW50IHVzZWQgdG8gYmUgYW4gb3B0aW9uYWwgYGNhbGN1bGF0ZUNoYW5nZWRCaXRzYFxuICAvLyBmdW5jdGlvbi4gV2FybiB0byByZXNlcnZlIGZvciBmdXR1cmUgdXNlP1xuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0XG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAvLyBUaGlzIG1pZ2h0IHRocm93IGVpdGhlciBiZWNhdXNlIGl0J3MgbWlzc2luZyBvciB0aHJvd3MuIElmIHNvLCB3ZSB0cmVhdCBpdFxuICAgIC8vIGFzIHN0aWxsIHVuaW5pdGlhbGl6ZWQgYW5kIHRyeSBhZ2FpbiBuZXh0IHRpbWUuIFdoaWNoIGlzIHRoZSBzYW1lIGFzIHdoYXRcbiAgICAvLyBoYXBwZW5zIGlmIHRoZSBjdG9yIG9yIGFueSB3cmFwcGVycyBwcm9jZXNzaW5nIHRoZSBjdG9yIHRocm93cy4gVGhpcyBtaWdodFxuICAgIC8vIGVuZCB1cCBmaXhpbmcgaXQgaWYgdGhlIHJlc29sdXRpb24gd2FzIGEgY29uY3VycmVuY3kgYnVnLlxuXG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBtb2R1bGVPYmplY3Q7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIC8vIEluIGNhc2UsIHdlJ3JlIHN0aWxsIHVuaW5pdGlhbGl6ZWQsIHRoZW4gd2UncmUgd2FpdGluZyBmb3IgdGhlIHRoZW5hYmxlXG4gICAgICAvLyB0byByZXNvbHZlLiBTZXQgaXQgYXMgcGVuZGluZyBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICB2YXIgbW9kdWxlT2JqZWN0ID0gcGF5bG9hZC5fcmVzdWx0O1xuXG4gICAge1xuICAgICAgaWYgKG1vZHVsZU9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5cIiArICdEaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0PycsIG1vZHVsZU9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKCEoJ2RlZmF1bHQnIGluIG1vZHVsZU9iamVjdCkpIHtcbiAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcCcgKyAnb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGVPYmplY3QuZGVmYXVsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiBVbmluaXRpYWxpemVkLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7IC8vIFRoZSBpbm5lciBjb21wb25lbnQgc2hvdWxkbid0IGluaGVyaXQgdGhpcyBkaXNwbGF5IG5hbWUgaW4gbW9zdCBjYXNlcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cbiAgICAgICAgLy8gQnV0IGl0J3MgbmljZSBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB0byBpbmhlcml0IHRoZSBuYW1lLFxuICAgICAgICAvLyBzbyB0aGF0IG91ciBjb21wb25lbnQtc3RhY2sgZ2VuZXJhdGlvbiBsb2dpYyB3aWxsIGRpc3BsYXkgdGhlaXIgZnJhbWVzLlxuICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAvLyAgIFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHsuLi59KTtcbiAgICAgICAgLy8gVGhpcyBraW5kIG9mIGlubmVyIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIGVsc2V3aGVyZSBzbyB0aGUgc2lkZSBlZmZlY3QgaXMgb2theS5cblxuICAgICAgICBpZiAoIXJlbmRlci5uYW1lICYmICFyZW5kZXIuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIHdhcm5PblN1YnNjcmlwdGlvbkluc2lkZVN0YXJ0VHJhbnNpdGlvbiA9IGZhbHNlO1xuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IDA7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gZXhwb3J0cy5Qcm9maWxlciB8fCB0eXBlID09PSBleHBvcnRzLnVuc3RhYmxlX0RlYnVnVHJhY2luZ01vZGUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdHJpY3RNb2RlIHx8IHR5cGUgPT09IGV4cG9ydHMuU3VzcGVuc2UgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdXNwZW5zZUxpc3QgfHwgdHlwZSA9PT0gZXhwb3J0cy51bnN0YWJsZV9MZWdhY3lIaWRkZW4gfHwgdHlwZSA9PT0gZXhwb3J0cy51bnN0YWJsZV9PZmZzY3JlZW4gfHwgZW5hYmxlU2NvcGVBUEkgIHx8ICB0eXBlID09PSBleHBvcnRzLnVuc3RhYmxlX0NhY2hlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBSZWFjdC5tZW1vKChwcm9wcykgPT4gey4uLn0pO1xuICAgICAgICAvLyBUaGlzIGtpbmQgb2YgaW5uZXIgZnVuY3Rpb24gaXMgbm90IHVzZWQgZWxzZXdoZXJlIHNvIHRoZSBzaWRlIGVmZmVjdCBpcyBva2F5LlxuXG4gICAgICAgIGlmICghdHlwZS5uYW1lICYmICF0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoZGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbiAgICB9XG4gIH0gLy8gV2lsbCByZXN1bHQgaW4gYSBudWxsIGFjY2VzcyBlcnJvciBpZiBhY2Nlc3NlZCBvdXRzaWRlIHJlbmRlciBwaGFzZS4gV2VcbiAgLy8gaW50ZW50aW9uYWxseSBkb24ndCB0aHJvdyBvdXIgb3duIGVycm9yIGJlY2F1c2UgdGhpcyBpcyBpbiBhIGhvdCBwYXRoLlxuICAvLyBBbHNvIGhlbHBzIGVuc3VyZSB0aGlzIGlzIGlubGluZWQuXG5cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGVTaWduYWwoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTsgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIHVuc3RhYmxlLCB0aHVzIG9wdGlvbmFsXG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIuZ2V0Q2FjaGVTaWduYWwoKTtcbn1cbmZ1bmN0aW9uIGdldENhY2hlRm9yVHlwZShyZXNvdXJjZVR5cGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpOyAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgdW5zdGFibGUsIHRodXMgb3B0aW9uYWxcblxuICByZXR1cm4gZGlzcGF0Y2hlci5nZXRDYWNoZUZvclR5cGUocmVzb3VyY2VUeXBlKTtcbn1cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VUcmFuc2l0aW9uKCk7XG59XG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJZCgpO1xufVxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTsgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIHVuc3RhYmxlLCB0aHVzIG9wdGlvbmFsXG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FjaGVSZWZyZXNoKCk7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2VMaXN0OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRWZXJzaW9uKSB7XG4gIHZhciBtdXRhYmxlU291cmNlID0ge1xuICAgIF9nZXRWZXJzaW9uOiBnZXRWZXJzaW9uLFxuICAgIF9zb3VyY2U6IHNvdXJjZSxcbiAgICBfd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeTogbnVsbCxcbiAgICBfd29ya0luUHJvZ3Jlc3NWZXJzaW9uU2Vjb25kYXJ5OiBudWxsXG4gIH07XG5cbiAge1xuICAgIG11dGFibGVTb3VyY2UuX2N1cnJlbnRQcmltYXJ5UmVuZGVyZXIgPSBudWxsO1xuICAgIG11dGFibGVTb3VyY2UuX2N1cnJlbnRTZWNvbmRhcnlSZW5kZXJlciA9IG51bGw7IC8vIFVzZWQgdG8gZGV0ZWN0IHNpZGUgZWZmZWN0cyB0aGF0IHVwZGF0ZSBhIG11dGFibGUgc291cmNlIGR1cmluZyByZW5kZXIuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTk5NDhcblxuICAgIG11dGFibGVTb3VyY2UuX2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgICBtdXRhYmxlU291cmNlLl9pbml0aWFsVmVyc2lvbkFzT2ZGaXJzdFJlbmRlciA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gbXV0YWJsZVNvdXJjZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKHNjb3BlKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSAxO1xuXG4gIHRyeSB7XG4gICAgc2NvcGUoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICB7XG4gICAgICBpZiAocHJldlRyYW5zaXRpb24gIT09IDEgJiYgd2Fybk9uU3Vic2NyaXB0aW9uSW5zaWRlU3RhcnRUcmFuc2l0aW9uICYmIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9IGZhbHNlO1xudmFyIGVucXVldWVUYXNrSW1wbCA9IG51bGw7XG5mdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gIGlmIChlbnF1ZXVlVGFza0ltcGwgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgLy8gcmVhZCByZXF1aXJlIG9mZiB0aGUgbW9kdWxlIG9iamVjdCB0byBnZXQgYXJvdW5kIHRoZSBidW5kbGVycy5cbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlbSB0byBkZXRlY3QgYSByZXF1aXJlIGFuZCBidW5kbGUgYSBOb2RlIHBvbHlmaWxsLlxuICAgICAgdmFyIHJlcXVpcmVTdHJpbmcgPSAoJ3JlcXVpcmUnICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMCwgNyk7XG4gICAgICB2YXIgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddOyAvLyBhc3N1bWluZyB3ZSdyZSBpbiBub2RlLCBsZXQncyB0cnkgdG8gZ2V0IG5vZGUnc1xuICAgICAgLy8gdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUsIGJ5cGFzc2luZyBmYWtlIHRpbWVycyBpZiBhbnkuXG5cbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAndGltZXJzJykuc2V0SW1tZWRpYXRlO1xuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgIC8vIHdlJ3JlIGluIGEgYnJvd3NlclxuICAgICAgLy8gd2UgY2FuJ3QgdXNlIHJlZ3VsYXIgdGltZXJzIGJlY2F1c2UgdGhleSBtYXkgc3RpbGwgYmUgZmFrZWRcbiAgICAgIC8vIHNvIHdlIHRyeSBNZXNzYWdlQ2hhbm5lbCtwb3N0TWVzc2FnZSBpbnN0ZWFkXG4gICAgICBlbnF1ZXVlVGFza0ltcGwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgTWVzc2FnZUNoYW5uZWwgaW1wbGVtZW50YXRpb24sICcgKyAnc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3VlcyAnICsgJ2lmIHlvdSBlbmNvdW50ZXIgdGhpcyB3YXJuaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVucXVldWVUYXNrSW1wbCh0YXNrKTtcbn1cblxudmFyIGFjdFNjb3BlRGVwdGggPSAwO1xudmFyIGRpZFdhcm5Ob0F3YWl0QWN0ID0gZmFsc2U7XG5mdW5jdGlvbiBhY3QoY2FsbGJhY2spIHtcbiAge1xuICAgIC8vIGBhY3RgIGNhbGxzIGNhbiBiZSBuZXN0ZWQsIHNvIHdlIHRyYWNrIHRoZSBkZXB0aC4gVGhpcyByZXByZXNlbnRzIHRoZVxuICAgIC8vIG51bWJlciBvZiBgYWN0YCBzY29wZXMgb24gdGhlIHN0YWNrLlxuICAgIHZhciBwcmV2QWN0U2NvcGVEZXB0aCA9IGFjdFNjb3BlRGVwdGg7XG4gICAgYWN0U2NvcGVEZXB0aCsrO1xuXG4gICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIG91dGVybW9zdCBgYWN0YCBzY29wZS4gSW5pdGlhbGl6ZSB0aGUgcXVldWUuIFRoZSByZWNvbmNpbGVyXG4gICAgICAvLyB3aWxsIGRldGVjdCB0aGUgcXVldWUgYW5kIHVzZSBpdCBpbnN0ZWFkIG9mIFNjaGVkdWxlci5cbiAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgcHJldklzQmF0Y2hpbmdMZWdhY3kgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5O1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgLy8gVXNlZCB0byByZXByb2R1Y2UgYmVoYXZpb3Igb2YgYGJhdGNoZWRVcGRhdGVzYCBpbiBsZWdhY3kgbW9kZS4gT25seVxuICAgICAgLy8gc2V0IHRvIGB0cnVlYCB3aGlsZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgaXMgZXhlY3V0ZWQsIG5vdCBmb3IgdXBkYXRlc1xuICAgICAgLy8gdHJpZ2dlcmVkIGR1cmluZyBhbiBhc3luYyBldmVudCwgYmVjYXVzZSB0aGlzIGlzIGhvdyB0aGUgbGVnYWN5XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBgYWN0YCBiZWhhdmVkLlxuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHRydWU7XG4gICAgICByZXN1bHQgPSBjYWxsYmFjaygpOyAvLyBSZXBsaWNhdGUgYmVoYXZpb3Igb2Ygb3JpZ2luYWwgYGFjdGAgaW1wbGVtZW50YXRpb24gaW4gbGVnYWN5IG1vZGUsXG4gICAgICAvLyB3aGljaCBmbHVzaGVkIHVwZGF0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHNjb3BlIGZ1bmN0aW9uIGV4aXRzLCBldmVuXG4gICAgICAvLyBpZiBpdCdzIGFuIGFzeW5jIGZ1bmN0aW9uLlxuXG4gICAgICBpZiAoIXByZXZJc0JhdGNoaW5nTGVnYWN5ICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHByZXZJc0JhdGNoaW5nTGVnYWN5O1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGhlbmFibGVSZXN1bHQgPSByZXN1bHQ7IC8vIFRoZSBjYWxsYmFjayBpcyBhbiBhc3luYyBmdW5jdGlvbiAoaS5lLiByZXR1cm5lZCBhIHByb21pc2UpLiBXYWl0XG4gICAgICAvLyBmb3IgaXQgdG8gcmVzb2x2ZSBiZWZvcmUgZXhpdGluZyB0aGUgY3VycmVudCBzY29wZS5cblxuICAgICAgdmFyIHdhc0F3YWl0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciB0aGVuYWJsZSA9IHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHdhc0F3YWl0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoZW5hYmxlUmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG5cbiAgICAgICAgICAgIGlmIChhY3RTY29wZURlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aXRlZCB0aGUgb3V0ZXJtb3N0IGFjdCBzY29wZS4gUmVjdXJzaXZlbHkgZmx1c2ggdGhlXG4gICAgICAgICAgICAgIC8vIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayB0aHJldyBhbiBlcnJvci5cbiAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuTm9Bd2FpdEFjdCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHt9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghd2FzQXdhaXRlZCkge1xuICAgICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ1lvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gJyArICdUaGlzIGNvdWxkIGxlYWQgdG8gdW5leHBlY3RlZCB0ZXN0aW5nIGJlaGF2aW91ciwgJyArICdpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgJyArICdzY29wZXMuICcgKyAnWW91IHNob3VsZCAtIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVzdWx0OyAvLyBUaGUgY2FsbGJhY2sgaXMgbm90IGFuIGFzeW5jIGZ1bmN0aW9uLiBFeGl0IHRoZSBjdXJyZW50IHNjb3BlXG4gICAgICAvLyBpbW1lZGlhdGVseSwgd2l0aG91dCBhd2FpdGluZy5cblxuICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuXG4gICAgICBpZiAoYWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAvLyBFeGl0aW5nIHRoZSBvdXRlcm1vc3QgYWN0IHNjb3BlLiBGbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIHZhciBfcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuXG4gICAgICAgIGlmIChfcXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBmbHVzaEFjdFF1ZXVlKF9xdWV1ZSk7XG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH0gLy8gUmV0dXJuIGEgdGhlbmFibGUuIElmIHRoZSB1c2VyIGF3YWl0cyBpdCwgd2UnbGwgZmx1c2ggYWdhaW4gaW5cbiAgICAgICAgLy8gY2FzZSBhZGRpdGlvbmFsIHdvcmsgd2FzIHNjaGVkdWxlZCBieSBhIG1pY3JvdGFzay5cblxuXG4gICAgICAgIHZhciBfdGhlbmFibGUgPSB7XG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gQ29uZmlybSB3ZSBoYXZlbid0IHJlLWVudGVyZWQgYW5vdGhlciBgYWN0YCBzY29wZSwgaW4gY2FzZVxuICAgICAgICAgICAgLy8gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgd2VpcmQgbGlrZSBhd2FpdCB0aGUgdGhlbmFibGVcbiAgICAgICAgICAgIC8vIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICAgICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmx1c2ggdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG4gICAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGVuYWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIGluc2lkZSBhIG5lc3RlZCBgYWN0YCBzY29wZSwgdGhlIHJldHVybmVkIHRoZW5hYmxlXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmVzLiBUaGUgb3V0ZXIgc2NvcGUgd2lsbCBmbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIHZhciBfdGhlbmFibGUyID0ge1xuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGVuYWJsZTI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKSB7XG4gIHtcbiAgICBpZiAocHJldkFjdFNjb3BlRGVwdGggIT09IGFjdFNjb3BlRGVwdGggLSAxKSB7XG4gICAgICBlcnJvcignWW91IHNlZW0gdG8gaGF2ZSBvdmVybGFwcGluZyBhY3QoKSBjYWxscywgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0JlIHN1cmUgdG8gYXdhaXQgcHJldmlvdXMgYWN0KCkgY2FsbHMgYmVmb3JlIG1ha2luZyBhIG5ldyBvbmUuICcpO1xuICAgIH1cblxuICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpIHtcbiAge1xuICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpO1xuICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gYWRkaXRpb25hbCB3b3JrIHdhcyBzY2hlZHVsZWQuIEZpbmlzaC5cbiAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEtlZXAgZmx1c2hpbmcgd29yayB1bnRpbCB0aGVyZSdzIG5vbmUgbGVmdC5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNGbHVzaGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSB7XG4gIHtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG4gICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIHRocm93cywgbGVhdmUgdGhlIHJlbWFpbmluZyBjYWxsYmFja3Mgb24gdGhlIHF1ZXVlLlxuICAgICAgICBxdWV1ZSA9IHF1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy5zdGFydFRyYW5zaXRpb24gPSBzdGFydFRyYW5zaXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2FjdCA9IGFjdDtcbmV4cG9ydHMudW5zdGFibGVfY3JlYXRlTXV0YWJsZVNvdXJjZSA9IGNyZWF0ZU11dGFibGVTb3VyY2U7XG5leHBvcnRzLnVuc3RhYmxlX2dldENhY2hlRm9yVHlwZSA9IGdldENhY2hlRm9yVHlwZTtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Q2FjaGVTaWduYWwgPSBnZXRDYWNoZVNpZ25hbDtcbmV4cG9ydHMudW5zdGFibGVfdXNlQ2FjaGVSZWZyZXNoID0gdXNlQ2FjaGVSZWZyZXNoO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZURlZmVycmVkVmFsdWUgPSB1c2VEZWZlcnJlZFZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUlkID0gdXNlSWQ7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3Q7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmU7XG5leHBvcnRzLnVzZVRyYW5zaXRpb24gPSB1c2VUcmFuc2l0aW9uO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTs7OztBQUlBO0FBTEE7QUFRQTs7Ozs7QUFJQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTs7Ozs7OztBQU1BO0FBQ0E7Ozs7QUFJQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBOURBO0FBaUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBQ0E7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFSQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVZBO0FBbERBO0FBQ0E7QUErREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQWRBO0FBakJBO0FBa0NBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBbkJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBVEE7QUFXQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react/cjs/react.development.js\n");

/***/ }),

/***/ "../../build/oss-experimental/react/index.js":
/*!**********************************************************************!*\
  !*** /home/pomber/p/dev/react/build/oss-experimental/react/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"../../build/oss-experimental/react/cjs/react.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9wb21iZXIvcC9kZXYvcmVhY3QvYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC9pbmRleC5qcz84YTA0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react/index.js\n");

/***/ }),

/***/ "../../node_modules/clipboard-js/clipboard.js":
/*!***********************************************************************!*\
  !*** /home/pomber/p/dev/react/node_modules/clipboard-js/clipboard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//  Import support https://stackoverflow.com/questions/13673346/supporting-both-commonjs-and-amd\n(function (name, definition) {\n  if (true) {\n    module.exports = definition();\n  } else {}\n})(\"clipboard\", function () {\n  if (typeof document === 'undefined' || !document.addEventListener) {\n    return null;\n  }\n\n  var clipboard = {};\n\n  clipboard.copy = function () {\n    var _intercept = false;\n    var _data = null; // Map from data type (e.g. \"text/html\") to value.\n\n    var _bogusSelection = false;\n\n    function cleanup() {\n      _intercept = false;\n      _data = null;\n\n      if (_bogusSelection) {\n        window.getSelection().removeAllRanges();\n      }\n\n      _bogusSelection = false;\n    }\n\n    document.addEventListener(\"copy\", function (e) {\n      if (_intercept) {\n        for (var key in _data) {\n          e.clipboardData.setData(key, _data[key]);\n        }\n\n        e.preventDefault();\n      }\n    }); // Workaround for Safari: https://bugs.webkit.org/show_bug.cgi?id=156529\n\n    function bogusSelect() {\n      var sel = document.getSelection(); // If \"nothing\" is selected...\n\n      if (!document.queryCommandEnabled(\"copy\") && sel.isCollapsed) {\n        // ... temporarily select the entire body.\n        //\n        // We select the entire body because:\n        // - it's guaranteed to exist,\n        // - it works (unlike, say, document.head, or phantom element that is\n        //   not inserted into the DOM),\n        // - it doesn't seem to flicker (due to the synchronous copy event), and\n        // - it avoids modifying the DOM (can trigger mutation observers).\n        //\n        // Because we can't do proper feature detection (we already checked\n        // document.queryCommandEnabled(\"copy\") , which actually gives a false\n        // negative for Blink when nothing is selected) and UA sniffing is not\n        // reliable (a lot of UA strings contain \"Safari\"), this will also\n        // happen for some browsers other than Safari. :-()\n        var range = document.createRange();\n        range.selectNodeContents(document.body);\n        sel.removeAllRanges();\n        sel.addRange(range);\n        _bogusSelection = true;\n      }\n    }\n\n    ;\n    return function (data) {\n      return new Promise(function (resolve, reject) {\n        _intercept = true;\n\n        if (typeof data === \"string\") {\n          _data = {\n            \"text/plain\": data\n          };\n        } else if (data instanceof Node) {\n          _data = {\n            \"text/html\": new XMLSerializer().serializeToString(data)\n          };\n        } else if (data instanceof Object) {\n          _data = data;\n        } else {\n          reject(\"Invalid data type. Must be string, DOM node, or an object mapping MIME types to strings.\");\n        }\n\n        function triggerCopy(tryBogusSelect) {\n          try {\n            if (document.execCommand(\"copy\")) {\n              // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis\n              // So we can call resolve() back here.\n              cleanup();\n              resolve();\n            } else {\n              if (!tryBogusSelect) {\n                bogusSelect();\n                triggerCopy(true);\n              } else {\n                cleanup();\n                throw new Error(\"Unable to copy. Perhaps it's not available in your browser?\");\n              }\n            }\n          } catch (e) {\n            cleanup();\n            reject(e);\n          }\n        }\n\n        triggerCopy(false);\n      });\n    };\n  }();\n\n  clipboard.paste = function () {\n    var _intercept = false;\n\n    var _resolve;\n\n    var _dataType;\n\n    document.addEventListener(\"paste\", function (e) {\n      if (_intercept) {\n        _intercept = false;\n        e.preventDefault();\n        var resolve = _resolve;\n        _resolve = null;\n        resolve(e.clipboardData.getData(_dataType));\n      }\n    });\n    return function (dataType) {\n      return new Promise(function (resolve, reject) {\n        _intercept = true;\n        _resolve = resolve;\n        _dataType = dataType || \"text/plain\";\n\n        try {\n          if (!document.execCommand(\"paste\")) {\n            _intercept = false;\n            reject(new Error(\"Unable to paste. Pasting only works in Internet Explorer at the moment.\"));\n          }\n        } catch (e) {\n          _intercept = false;\n          reject(new Error(e));\n        }\n      });\n    };\n  }(); // Handle IE behaviour.\n\n\n  if (typeof ClipboardEvent === \"undefined\" && typeof window.clipboardData !== \"undefined\" && typeof window.clipboardData.setData !== \"undefined\") {\n    /*! promise-polyfill 2.0.1 */\n    (function (a) {\n      function b(a, b) {\n        return function () {\n          a.apply(b, arguments);\n        };\n      }\n\n      function c(a) {\n        if (\"object\" != typeof this) throw new TypeError(\"Promises must be constructed via new\");\n        if (\"function\" != typeof a) throw new TypeError(\"not a function\");\n        this._state = null, this._value = null, this._deferreds = [], i(a, b(e, this), b(f, this));\n      }\n\n      function d(a) {\n        var b = this;\n        return null === this._state ? void this._deferreds.push(a) : void j(function () {\n          var c = b._state ? a.onFulfilled : a.onRejected;\n          if (null === c) return void (b._state ? a.resolve : a.reject)(b._value);\n          var d;\n\n          try {\n            d = c(b._value);\n          } catch (e) {\n            return void a.reject(e);\n          }\n\n          a.resolve(d);\n        });\n      }\n\n      function e(a) {\n        try {\n          if (a === this) throw new TypeError(\"A promise cannot be resolved with itself.\");\n\n          if (a && (\"object\" == typeof a || \"function\" == typeof a)) {\n            var c = a.then;\n            if (\"function\" == typeof c) return void i(b(c, a), b(e, this), b(f, this));\n          }\n\n          this._state = !0, this._value = a, g.call(this);\n        } catch (d) {\n          f.call(this, d);\n        }\n      }\n\n      function f(a) {\n        this._state = !1, this._value = a, g.call(this);\n      }\n\n      function g() {\n        for (var a = 0, b = this._deferreds.length; b > a; a++) d.call(this, this._deferreds[a]);\n\n        this._deferreds = null;\n      }\n\n      function h(a, b, c, d) {\n        this.onFulfilled = \"function\" == typeof a ? a : null, this.onRejected = \"function\" == typeof b ? b : null, this.resolve = c, this.reject = d;\n      }\n\n      function i(a, b, c) {\n        var d = !1;\n\n        try {\n          a(function (a) {\n            d || (d = !0, b(a));\n          }, function (a) {\n            d || (d = !0, c(a));\n          });\n        } catch (e) {\n          if (d) return;\n          d = !0, c(e);\n        }\n      }\n\n      var j = c.immediateFn || \"function\" == typeof setImmediate && setImmediate || function (a) {\n        setTimeout(a, 1);\n      },\n          k = Array.isArray || function (a) {\n        return \"[object Array]\" === Object.prototype.toString.call(a);\n      };\n\n      c.prototype[\"catch\"] = function (a) {\n        return this.then(null, a);\n      }, c.prototype.then = function (a, b) {\n        var e = this;\n        return new c(function (c, f) {\n          d.call(e, new h(a, b, c, f));\n        });\n      }, c.all = function () {\n        var a = Array.prototype.slice.call(1 === arguments.length && k(arguments[0]) ? arguments[0] : arguments);\n        return new c(function (b, c) {\n          function d(f, g) {\n            try {\n              if (g && (\"object\" == typeof g || \"function\" == typeof g)) {\n                var h = g.then;\n                if (\"function\" == typeof h) return void h.call(g, function (a) {\n                  d(f, a);\n                }, c);\n              }\n\n              a[f] = g, 0 === --e && b(a);\n            } catch (i) {\n              c(i);\n            }\n          }\n\n          if (0 === a.length) return b([]);\n\n          for (var e = a.length, f = 0; f < a.length; f++) d(f, a[f]);\n        });\n      }, c.resolve = function (a) {\n        return a && \"object\" == typeof a && a.constructor === c ? a : new c(function (b) {\n          b(a);\n        });\n      }, c.reject = function (a) {\n        return new c(function (b, c) {\n          c(a);\n        });\n      }, c.race = function (a) {\n        return new c(function (b, c) {\n          for (var d = 0, e = a.length; e > d; d++) a[d].then(b, c);\n        });\n      },  true && module.exports ? module.exports = c : a.Promise || (a.Promise = c);\n    })(this);\n\n    clipboard.copy = function (data) {\n      return new Promise(function (resolve, reject) {\n        // IE supports string and URL types: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx\n        // We only support the string type for now.\n        if (typeof data !== \"string\" && !(\"text/plain\" in data)) {\n          throw new Error(\"You must provide a text/plain type.\");\n        }\n\n        var strData = typeof data === \"string\" ? data : data[\"text/plain\"];\n        var copySucceeded = window.clipboardData.setData(\"Text\", strData);\n\n        if (copySucceeded) {\n          resolve();\n        } else {\n          reject(new Error(\"Copying was rejected.\"));\n        }\n      });\n    };\n\n    clipboard.paste = function () {\n      return new Promise(function (resolve, reject) {\n        var strData = window.clipboardData.getData(\"Text\");\n\n        if (strData) {\n          resolve(strData);\n        } else {\n          // The user rejected the paste request.\n          reject(new Error(\"Pasting was rejected.\"));\n        }\n      });\n    };\n  }\n\n  return clipboard;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2NsaXBib2FyZC1qcy9jbGlwYm9hcmQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvcG9tYmVyL3AvZGV2L3JlYWN0L25vZGVfbW9kdWxlcy9jbGlwYm9hcmQtanMvY2xpcGJvYXJkLmpzP2Q0ZDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gIEltcG9ydCBzdXBwb3J0IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNjczMzQ2L3N1cHBvcnRpbmctYm90aC1jb21tb25qcy1hbmQtYW1kXG4oZnVuY3Rpb24obmFtZSwgZGVmaW5pdGlvbikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7IG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpOyB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiKSB7IGRlZmluZShkZWZpbml0aW9uKTsgfVxuICAgIGVsc2UgeyB0aGlzW25hbWVdID0gZGVmaW5pdGlvbigpOyB9XG59KFwiY2xpcGJvYXJkXCIsIGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNsaXBib2FyZCA9IHt9O1xuXG4gIGNsaXBib2FyZC5jb3B5ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBfaW50ZXJjZXB0ID0gZmFsc2U7XG4gICAgdmFyIF9kYXRhID0gbnVsbDsgLy8gTWFwIGZyb20gZGF0YSB0eXBlIChlLmcuIFwidGV4dC9odG1sXCIpIHRvIHZhbHVlLlxuICAgIHZhciBfYm9ndXNTZWxlY3Rpb24gPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICBfaW50ZXJjZXB0ID0gZmFsc2U7XG4gICAgICBfZGF0YSA9IG51bGw7XG4gICAgICBpZiAoX2JvZ3VzU2VsZWN0aW9uKSB7XG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICAgIF9ib2d1c1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChfaW50ZXJjZXB0KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBfZGF0YSkge1xuICAgICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKGtleSwgX2RhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgU2FmYXJpOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2NTI5XG4gICAgZnVuY3Rpb24gYm9ndXNTZWxlY3QoKSB7XG4gICAgICB2YXIgc2VsID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAvLyBJZiBcIm5vdGhpbmdcIiBpcyBzZWxlY3RlZC4uLlxuICAgICAgaWYgKCFkb2N1bWVudC5xdWVyeUNvbW1hbmRFbmFibGVkKFwiY29weVwiKSAmJiBzZWwuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgLy8gLi4uIHRlbXBvcmFyaWx5IHNlbGVjdCB0aGUgZW50aXJlIGJvZHkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHNlbGVjdCB0aGUgZW50aXJlIGJvZHkgYmVjYXVzZTpcbiAgICAgICAgLy8gLSBpdCdzIGd1YXJhbnRlZWQgdG8gZXhpc3QsXG4gICAgICAgIC8vIC0gaXQgd29ya3MgKHVubGlrZSwgc2F5LCBkb2N1bWVudC5oZWFkLCBvciBwaGFudG9tIGVsZW1lbnQgdGhhdCBpc1xuICAgICAgICAvLyAgIG5vdCBpbnNlcnRlZCBpbnRvIHRoZSBET00pLFxuICAgICAgICAvLyAtIGl0IGRvZXNuJ3Qgc2VlbSB0byBmbGlja2VyIChkdWUgdG8gdGhlIHN5bmNocm9ub3VzIGNvcHkgZXZlbnQpLCBhbmRcbiAgICAgICAgLy8gLSBpdCBhdm9pZHMgbW9kaWZ5aW5nIHRoZSBET00gKGNhbiB0cmlnZ2VyIG11dGF0aW9uIG9ic2VydmVycykuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJlY2F1c2Ugd2UgY2FuJ3QgZG8gcHJvcGVyIGZlYXR1cmUgZGV0ZWN0aW9uICh3ZSBhbHJlYWR5IGNoZWNrZWRcbiAgICAgICAgLy8gZG9jdW1lbnQucXVlcnlDb21tYW5kRW5hYmxlZChcImNvcHlcIikgLCB3aGljaCBhY3R1YWxseSBnaXZlcyBhIGZhbHNlXG4gICAgICAgIC8vIG5lZ2F0aXZlIGZvciBCbGluayB3aGVuIG5vdGhpbmcgaXMgc2VsZWN0ZWQpIGFuZCBVQSBzbmlmZmluZyBpcyBub3RcbiAgICAgICAgLy8gcmVsaWFibGUgKGEgbG90IG9mIFVBIHN0cmluZ3MgY29udGFpbiBcIlNhZmFyaVwiKSwgdGhpcyB3aWxsIGFsc29cbiAgICAgICAgLy8gaGFwcGVuIGZvciBzb21lIGJyb3dzZXJzIG90aGVyIHRoYW4gU2FmYXJpLiA6LSgpXG4gICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICBfYm9ndXNTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfaW50ZXJjZXB0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgX2RhdGEgPSB7XCJ0ZXh0L3BsYWluXCI6IGRhdGF9O1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgX2RhdGEgPSB7XCJ0ZXh0L2h0bWxcIjogbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhkYXRhKX07XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCl7XG4gICAgICAgICAgX2RhdGEgPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChcIkludmFsaWQgZGF0YSB0eXBlLiBNdXN0IGJlIHN0cmluZywgRE9NIG5vZGUsIG9yIGFuIG9iamVjdCBtYXBwaW5nIE1JTUUgdHlwZXMgdG8gc3RyaW5ncy5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJDb3B5KHRyeUJvZ3VzU2VsZWN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIikpIHtcbiAgICAgICAgICAgICAgLy8gZG9jdW1lbnQuZXhlY0NvbW1hbmQgaXMgc3luY2hyb25vdXM6IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTUvV0QtY2xpcGJvYXJkLWFwaXMtMjAxNTA0MjEvI2ludGVncmF0aW9uLXdpdGgtcmljaC10ZXh0LWVkaXRpbmctYXBpc1xuICAgICAgICAgICAgICAvLyBTbyB3ZSBjYW4gY2FsbCByZXNvbHZlKCkgYmFjayBoZXJlLlxuICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXRyeUJvZ3VzU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgYm9ndXNTZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQ29weSh0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkuIFBlcmhhcHMgaXQncyBub3QgYXZhaWxhYmxlIGluIHlvdXIgYnJvd3Nlcj9cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJDb3B5KGZhbHNlKTtcblxuICAgICAgfSk7XG4gICAgfTtcbiAgfSkoKTtcblxuICBjbGlwYm9hcmQucGFzdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9pbnRlcmNlcHQgPSBmYWxzZTtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgdmFyIF9kYXRhVHlwZTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoX2ludGVyY2VwdCkge1xuICAgICAgICBfaW50ZXJjZXB0ID0gZmFsc2U7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICAgICAgX3Jlc29sdmUgPSBudWxsO1xuICAgICAgICByZXNvbHZlKGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKF9kYXRhVHlwZSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGFUeXBlKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF9pbnRlcmNlcHQgPSB0cnVlO1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIF9kYXRhVHlwZSA9IGRhdGFUeXBlIHx8IFwidGV4dC9wbGFpblwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJwYXN0ZVwiKSkge1xuICAgICAgICAgICAgX2ludGVyY2VwdCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlVuYWJsZSB0byBwYXN0ZS4gUGFzdGluZyBvbmx5IHdvcmtzIGluIEludGVybmV0IEV4cGxvcmVyIGF0IHRoZSBtb21lbnQuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBfaW50ZXJjZXB0ID0gZmFsc2U7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLy8gSGFuZGxlIElFIGJlaGF2aW91ci5cbiAgaWYgKHR5cGVvZiBDbGlwYm9hcmRFdmVudCA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgdHlwZW9mIHdpbmRvdy5jbGlwYm9hcmREYXRhICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICB0eXBlb2Ygd2luZG93LmNsaXBib2FyZERhdGEuc2V0RGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgLyohIHByb21pc2UtcG9seWZpbGwgMi4wLjEgKi9cbiAgICAoZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIpe3JldHVybiBmdW5jdGlvbigpe2EuYXBwbHkoYixhcmd1bWVudHMpfX1mdW5jdGlvbiBjKGEpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0aGlzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXdcIik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgZnVuY3Rpb25cIik7dGhpcy5fc3RhdGU9bnVsbCx0aGlzLl92YWx1ZT1udWxsLHRoaXMuX2RlZmVycmVkcz1bXSxpKGEsYihlLHRoaXMpLGIoZix0aGlzKSl9ZnVuY3Rpb24gZChhKXt2YXIgYj10aGlzO3JldHVybiBudWxsPT09dGhpcy5fc3RhdGU/dm9pZCB0aGlzLl9kZWZlcnJlZHMucHVzaChhKTp2b2lkIGooZnVuY3Rpb24oKXt2YXIgYz1iLl9zdGF0ZT9hLm9uRnVsZmlsbGVkOmEub25SZWplY3RlZDtpZihudWxsPT09YylyZXR1cm4gdm9pZChiLl9zdGF0ZT9hLnJlc29sdmU6YS5yZWplY3QpKGIuX3ZhbHVlKTt2YXIgZDt0cnl7ZD1jKGIuX3ZhbHVlKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBhLnJlamVjdChlKX1hLnJlc29sdmUoZCl9KX1mdW5jdGlvbiBlKGEpe3RyeXtpZihhPT09dGhpcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi5cIik7aWYoYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBhKSl7dmFyIGM9YS50aGVuO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGMpcmV0dXJuIHZvaWQgaShiKGMsYSksYihlLHRoaXMpLGIoZix0aGlzKSl9dGhpcy5fc3RhdGU9ITAsdGhpcy5fdmFsdWU9YSxnLmNhbGwodGhpcyl9Y2F0Y2goZCl7Zi5jYWxsKHRoaXMsZCl9fWZ1bmN0aW9uIGYoYSl7dGhpcy5fc3RhdGU9ITEsdGhpcy5fdmFsdWU9YSxnLmNhbGwodGhpcyl9ZnVuY3Rpb24gZygpe2Zvcih2YXIgYT0wLGI9dGhpcy5fZGVmZXJyZWRzLmxlbmd0aDtiPmE7YSsrKWQuY2FsbCh0aGlzLHRoaXMuX2RlZmVycmVkc1thXSk7dGhpcy5fZGVmZXJyZWRzPW51bGx9ZnVuY3Rpb24gaChhLGIsYyxkKXt0aGlzLm9uRnVsZmlsbGVkPVwiZnVuY3Rpb25cIj09dHlwZW9mIGE/YTpudWxsLHRoaXMub25SZWplY3RlZD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBiP2I6bnVsbCx0aGlzLnJlc29sdmU9Yyx0aGlzLnJlamVjdD1kfWZ1bmN0aW9uIGkoYSxiLGMpe3ZhciBkPSExO3RyeXthKGZ1bmN0aW9uKGEpe2R8fChkPSEwLGIoYSkpfSxmdW5jdGlvbihhKXtkfHwoZD0hMCxjKGEpKX0pfWNhdGNoKGUpe2lmKGQpcmV0dXJuO2Q9ITAsYyhlKX19dmFyIGo9Yy5pbW1lZGlhdGVGbnx8XCJmdW5jdGlvblwiPT10eXBlb2Ygc2V0SW1tZWRpYXRlJiZzZXRJbW1lZGlhdGV8fGZ1bmN0aW9uKGEpe3NldFRpbWVvdXQoYSwxKX0saz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihhKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSl9O2MucHJvdG90eXBlW1wiY2F0Y2hcIl09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudGhlbihudWxsLGEpfSxjLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKGEsYil7dmFyIGU9dGhpcztyZXR1cm4gbmV3IGMoZnVuY3Rpb24oYyxmKXtkLmNhbGwoZSxuZXcgaChhLGIsYyxmKSl9KX0sYy5hbGw9ZnVuY3Rpb24oKXt2YXIgYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCgxPT09YXJndW1lbnRzLmxlbmd0aCYmayhhcmd1bWVudHNbMF0pP2FyZ3VtZW50c1swXTphcmd1bWVudHMpO3JldHVybiBuZXcgYyhmdW5jdGlvbihiLGMpe2Z1bmN0aW9uIGQoZixnKXt0cnl7aWYoZyYmKFwib2JqZWN0XCI9PXR5cGVvZiBnfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBnKSl7dmFyIGg9Zy50aGVuO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGgpcmV0dXJuIHZvaWQgaC5jYWxsKGcsZnVuY3Rpb24oYSl7ZChmLGEpfSxjKX1hW2ZdPWcsMD09PS0tZSYmYihhKX1jYXRjaChpKXtjKGkpfX1pZigwPT09YS5sZW5ndGgpcmV0dXJuIGIoW10pO2Zvcih2YXIgZT1hLmxlbmd0aCxmPTA7ZjxhLmxlbmd0aDtmKyspZChmLGFbZl0pfSl9LGMucmVzb2x2ZT1mdW5jdGlvbihhKXtyZXR1cm4gYSYmXCJvYmplY3RcIj09dHlwZW9mIGEmJmEuY29uc3RydWN0b3I9PT1jP2E6bmV3IGMoZnVuY3Rpb24oYil7YihhKX0pfSxjLnJlamVjdD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoZnVuY3Rpb24oYixjKXtjKGEpfSl9LGMucmFjZT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoZnVuY3Rpb24oYixjKXtmb3IodmFyIGQ9MCxlPWEubGVuZ3RoO2U+ZDtkKyspYVtkXS50aGVuKGIsYyl9KX0sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9YzphLlByb21pc2V8fChhLlByb21pc2U9Yyl9KSh0aGlzKTtcblxuICAgIGNsaXBib2FyZC5jb3B5ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBJRSBzdXBwb3J0cyBzdHJpbmcgYW5kIFVSTCB0eXBlczogaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjc0NCh2PXZzLjg1KS5hc3B4XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgc3RyaW5nIHR5cGUgZm9yIG5vdy5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICYmICEoXCJ0ZXh0L3BsYWluXCIgaW4gZGF0YSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwcm92aWRlIGEgdGV4dC9wbGFpbiB0eXBlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJEYXRhID0gKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZGF0YSA6IGRhdGFbXCJ0ZXh0L3BsYWluXCJdKTtcbiAgICAgICAgdmFyIGNvcHlTdWNjZWVkZWQgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiVGV4dFwiLCBzdHJEYXRhKTtcbiAgICAgICAgaWYgKGNvcHlTdWNjZWVkZWQpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvcHlpbmcgd2FzIHJlamVjdGVkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjbGlwYm9hcmQucGFzdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHN0ckRhdGEgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICAgICAgaWYgKHN0ckRhdGEpIHtcbiAgICAgICAgICByZXNvbHZlKHN0ckRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSB1c2VyIHJlamVjdGVkIHRoZSBwYXN0ZSByZXF1ZXN0LlxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJQYXN0aW5nIHdhcyByZWplY3RlZC5cIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGNsaXBib2FyZDtcbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQSxXQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/clipboard-js/clipboard.js\n");

/***/ }),

/***/ "../../node_modules/error-stack-parser/error-stack-parser.js":
/*!**************************************************************************************!*\
  !*** /home/pomber/p/dev/react/node_modules/error-stack-parser/error-stack-parser.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ \"../../node_modules/stackframe/stackframe.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function ErrorStackParser(StackFrame) {\n  'use strict';\n\n  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error('Cannot parse given Error object');\n      }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n        }\n\n        var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '('); // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n\n        var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/); // remove the parenthesized location from the line, if it was matched\n\n        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n        var tokens = sanitizedLine.split(/\\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token\n\n        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n        return new StackFrame({\n          functionName: functionName,\n          fileName: fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame({\n            functionName: line\n          });\n        } else {\n          var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          var matches = line.match(functionNameRegex);\n          var functionName = matches && matches[1] ? matches[1] : undefined;\n          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n          return new StackFrame({\n            functionName: functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      var lines = e.message.split('\\n');\n      var result = [];\n\n      for (var i = 2, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      var lines = e.stacktrace.split('\\n');\n      var result = [];\n\n      for (var i = 0, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n      return filtered.map(function (line) {\n        var tokens = line.split('@');\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionCall = tokens.shift() || '';\n        var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^)]*\\)/g, '') || undefined;\n        var argsRaw;\n\n        if (functionCall.match(/\\(([^)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n        }\n\n        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return new StackFrame({\n          functionName: functionName,\n          args: args,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    }\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Vycm9yLXN0YWNrLXBhcnNlci9lcnJvci1zdGFjay1wYXJzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvcG9tYmVyL3AvZGV2L3JlYWN0L25vZGVfbW9kdWxlcy9lcnJvci1zdGFjay1wYXJzZXIvZXJyb3Itc3RhY2stcGFyc2VyLmpzPzgyMTMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnZXJyb3Itc3RhY2stcGFyc2VyJywgWydzdGFja2ZyYW1lJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzdGFja2ZyYW1lJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuRXJyb3JTdGFja1BhcnNlciA9IGZhY3Rvcnkocm9vdC5TdGFja0ZyYW1lKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIoU3RhY2tGcmFtZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrOlxcZCsvO1xuICAgIHZhciBDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQID0gL15cXHMqYXQgLiooXFxTKzpcXGQrfFxcKG5hdGl2ZVxcKSkvbTtcbiAgICB2YXIgU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCA9IC9eKGV2YWxAKT8oXFxbbmF0aXZlIGNvZGVdKT8kLztcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIGV4dHJhY3QgdGhlIG1vc3QgaW5mb3JtYXRpb24gZnJvbSBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBvZiBTdGFja0ZyYW1lc1xuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrICYmIGVycm9yLnN0YWNrLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWOE9ySUUoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRkZPclNhZmFyaShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGdpdmVuIEVycm9yIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFNlcGFyYXRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIGZyb20gYSBzdHJpbmcgb2YgdGhlIGZvcm06IChVUkk6TGluZTpDb2x1bW4pXG4gICAgICAgIGV4dHJhY3RMb2NhdGlvbjogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkZXh0cmFjdExvY2F0aW9uKHVybExpa2UpIHtcbiAgICAgICAgICAgIC8vIEZhaWwtZmFzdCBidXQgcmV0dXJuIGxvY2F0aW9ucyBsaWtlIFwiKG5hdGl2ZSlcIlxuICAgICAgICAgICAgaWYgKHVybExpa2UuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdXJsTGlrZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdFeHAgPSAvKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLztcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHJlZ0V4cC5leGVjKHVybExpa2UucmVwbGFjZSgvWygpXS9nLCAnJykpO1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJ0c1sxXSwgcGFydHNbMl0gfHwgdW5kZWZpbmVkLCBwYXJ0c1szXSB8fCB1bmRlZmluZWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlVjhPcklFOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZVY4T3JJRShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcoZXZhbCAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvZXZhbCBjb2RlL2csICdldmFsJykucmVwbGFjZSgvKFxcKGV2YWwgYXQgW14oKV0qKXwoXFwpLC4qJCkvZywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkTGluZSA9IGxpbmUucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csICcoJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIGFuZCBwcmVzZXZlIHRoZSBwYXJlbnRoZXNpemVkIGxvY2F0aW9uIFwiKC9mb28vbXkgYmFyLmpzOjEyOjg3KVwiIGluXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBpdCBoYXMgc3BhY2VzIGluIGl0LCBhcyB0aGUgc3RyaW5nIGlzIHNwbGl0IG9uIFxccysgbGF0ZXIgb25cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzYW5pdGl6ZWRMaW5lLm1hdGNoKC8gKFxcKCguKyk6KFxcZCspOihcXGQrKVxcKSQpLyk7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHBhcmVudGhlc2l6ZWQgbG9jYXRpb24gZnJvbSB0aGUgbGluZSwgaWYgaXQgd2FzIG1hdGNoZWRcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZWRMaW5lID0gbG9jYXRpb24gPyBzYW5pdGl6ZWRMaW5lLnJlcGxhY2UobG9jYXRpb25bMF0sICcnKSA6IHNhbml0aXplZExpbmU7XG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gc2FuaXRpemVkTGluZS5zcGxpdCgvXFxzKy8pLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgbG9jYXRpb24gd2FzIG1hdGNoZWQsIHBhc3MgaXQgdG8gZXh0cmFjdExvY2F0aW9uKCkgb3RoZXJ3aXNlIHBvcCB0aGUgbGFzdCB0b2tlblxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obG9jYXRpb24gPyBsb2NhdGlvblsxXSA6IHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRva2Vucy5qb2luKCcgJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IFsnZXZhbCcsICc8YW5vbnltb3VzPiddLmluZGV4T2YobG9jYXRpb25QYXJ0c1swXSkgPiAtMSA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uUGFydHNbMF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VGRk9yU2FmYXJpOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZUZGT3JTYWZhcmkoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignID4gZXZhbCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWw6XFxkKzpcXGQrL2csICc6JDEnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCdAJykgPT09IC0xICYmIGxpbmUuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZXZhbCBmcmFtZXMgb25seSBoYXZlIGZ1bmN0aW9uIG5hbWVzIGFuZCBub3RoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbGluZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lUmVnZXggPSAvKCguKlwiLitcIlteQF0qKT9bXkBdKikoPzpAKS87XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChmdW5jdGlvbk5hbWVSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV0gPyBtYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKGxpbmUucmVwbGFjZShmdW5jdGlvbk5hbWVSZWdleCwgJycpKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYShlKSB7XG4gICAgICAgICAgICBpZiAoIWUuc3RhY2t0cmFjZSB8fCAoZS5tZXNzYWdlLmluZGV4T2YoJ1xcbicpID4gLTEgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCA+IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJykubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmE5KGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZS5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTExKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmE5OiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhOShlKSB7XG4gICAgICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykvaTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGUubWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTEwOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTAoZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspKD86OiBJbiBmdW5jdGlvbiAoXFxTKykpPyQvaTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBtYXRjaFszXSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE9wZXJhIDEwLjY1KyBFcnJvci5zdGFjayB2ZXJ5IHNpbWlsYXIgdG8gRkYvU2FmYXJpXG4gICAgICAgIHBhcnNlT3BlcmExMTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTExKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFsaW5lLm1hdGNoKEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCkgJiYgIWxpbmUubWF0Y2goL15FcnJvciBjcmVhdGVkIGF0Lyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmUuc3BsaXQoJ0AnKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQ2FsbCA9ICh0b2tlbnMuc2hpZnQoKSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPGFub255bW91cyBmdW5jdGlvbig6IChcXHcrKSk/Pi8sICckMicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXChbXildKlxcKS9nLCAnJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzUmF3O1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGwubWF0Y2goL1xcKChbXildKilcXCkvKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzUmF3ID0gZnVuY3Rpb25DYWxsLnJlcGxhY2UoL15bXihdK1xcKChbXildKilcXCkkLywgJyQxJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gKGFyZ3NSYXcgPT09IHVuZGVmaW5lZCB8fCBhcmdzUmF3ID09PSAnW2FyZ3VtZW50cyBub3QgYXZhaWxhYmxlXScpID9cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDogYXJnc1Jhdy5zcGxpdCgnLCcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQXBMQTtBQXNMQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/error-stack-parser/error-stack-parser.js\n");

/***/ }),

/***/ "../../node_modules/lru-cache/index.js":
/*!****************************************************************!*\
  !*** /home/pomber/p/dev/react/node_modules/lru-cache/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // A linked list to keep track of recently-used-ness\n\nconst Yallist = __webpack_require__(/*! yallist */ \"../../node_modules/lru-cache/node_modules/yallist/yallist.js\");\n\nconst MAX = Symbol('max');\nconst LENGTH = Symbol('length');\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator');\nconst ALLOW_STALE = Symbol('allowStale');\nconst MAX_AGE = Symbol('maxAge');\nconst DISPOSE = Symbol('dispose');\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');\nconst LRU_LIST = Symbol('lruList');\nconst CACHE = Symbol('cache');\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');\n\nconst naiveLength = () => 1; // lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\n\n\nclass LRUCache {\n  constructor(options) {\n    if (typeof options === 'number') options = {\n      max: options\n    };\n    if (!options) options = {};\n    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.\n\n    const max = this[MAX] = options.max || Infinity;\n    const lc = options.length || naiveLength;\n    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;\n    this[ALLOW_STALE] = options.stale || false;\n    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');\n    this[MAX_AGE] = options.maxAge || 0;\n    this[DISPOSE] = options.dispose;\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;\n    this.reset();\n  } // resize the cache when the max changes.\n\n\n  set max(mL) {\n    if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');\n    this[MAX] = mL || Infinity;\n    trim(this);\n  }\n\n  get max() {\n    return this[MAX];\n  }\n\n  set allowStale(allowStale) {\n    this[ALLOW_STALE] = !!allowStale;\n  }\n\n  get allowStale() {\n    return this[ALLOW_STALE];\n  }\n\n  set maxAge(mA) {\n    if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');\n    this[MAX_AGE] = mA;\n    trim(this);\n  }\n\n  get maxAge() {\n    return this[MAX_AGE];\n  } // resize the cache when the lengthCalculator changes.\n\n\n  set lengthCalculator(lC) {\n    if (typeof lC !== 'function') lC = naiveLength;\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC;\n      this[LENGTH] = 0;\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n        this[LENGTH] += hit.length;\n      });\n    }\n\n    trim(this);\n  }\n\n  get lengthCalculator() {\n    return this[LENGTH_CALCULATOR];\n  }\n\n  get length() {\n    return this[LENGTH];\n  }\n\n  get itemCount() {\n    return this[LRU_LIST].length;\n  }\n\n  rforEach(fn, thisp) {\n    thisp = thisp || this;\n\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev;\n      forEachStep(this, fn, walker, thisp);\n      walker = prev;\n    }\n  }\n\n  forEach(fn, thisp) {\n    thisp = thisp || this;\n\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next;\n      forEachStep(this, fn, walker, thisp);\n      walker = next;\n    }\n  }\n\n  keys() {\n    return this[LRU_LIST].toArray().map(k => k.key);\n  }\n\n  values() {\n    return this[LRU_LIST].toArray().map(k => k.value);\n  }\n\n  reset() {\n    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));\n    }\n\n    this[CACHE] = new Map(); // hash of items by key\n\n    this[LRU_LIST] = new Yallist(); // list of items in order of use recency\n\n    this[LENGTH] = 0; // length of items in the list\n  }\n\n  dump() {\n    return this[LRU_LIST].map(hit => isStale(this, hit) ? false : {\n      k: hit.key,\n      v: hit.value,\n      e: hit.now + (hit.maxAge || 0)\n    }).toArray().filter(h => h);\n  }\n\n  dumpLru() {\n    return this[LRU_LIST];\n  }\n\n  set(key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE];\n    if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');\n    const now = maxAge ? Date.now() : 0;\n    const len = this[LENGTH_CALCULATOR](value, key);\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key));\n        return false;\n      }\n\n      const node = this[CACHE].get(key);\n      const item = node.value; // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);\n      }\n\n      item.now = now;\n      item.maxAge = maxAge;\n      item.value = value;\n      this[LENGTH] += len - item.length;\n      item.length = len;\n      this.get(key);\n      trim(this);\n      return true;\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.\n\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE]) this[DISPOSE](key, value);\n      return false;\n    }\n\n    this[LENGTH] += hit.length;\n    this[LRU_LIST].unshift(hit);\n    this[CACHE].set(key, this[LRU_LIST].head);\n    trim(this);\n    return true;\n  }\n\n  has(key) {\n    if (!this[CACHE].has(key)) return false;\n    const hit = this[CACHE].get(key).value;\n    return !isStale(this, hit);\n  }\n\n  get(key) {\n    return get(this, key, true);\n  }\n\n  peek(key) {\n    return get(this, key, false);\n  }\n\n  pop() {\n    const node = this[LRU_LIST].tail;\n    if (!node) return null;\n    del(this, node);\n    return node.value;\n  }\n\n  del(key) {\n    del(this, this[CACHE].get(key));\n  }\n\n  load(arr) {\n    // reset the cache\n    this.reset();\n    const now = Date.now(); // A previous serialized cache has the most recent items first\n\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l];\n      const expiresAt = hit.e || 0;\n      if (expiresAt === 0) // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v);else {\n        const maxAge = expiresAt - now; // dont add already expired items\n\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge);\n        }\n      }\n    }\n  }\n\n  prune() {\n    this[CACHE].forEach((value, key) => get(this, key, false));\n  }\n\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key);\n\n  if (node) {\n    const hit = node.value;\n\n    if (isStale(self, hit)) {\n      del(self, node);\n      if (!self[ALLOW_STALE]) return undefined;\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();\n        self[LRU_LIST].unshiftNode(node);\n      }\n    }\n\n    return hit.value;\n  }\n};\n\nconst isStale = (self, hit) => {\n  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;\n  const diff = Date.now() - hit.now;\n  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];\n};\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev;\n      del(self, walker);\n      walker = prev;\n    }\n  }\n};\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value;\n    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);\n    self[LENGTH] -= hit.length;\n    self[CACHE].delete(hit.key);\n    self[LRU_LIST].removeNode(node);\n  }\n};\n\nclass Entry {\n  constructor(key, value, length, now, maxAge) {\n    this.key = key;\n    this.value = value;\n    this.length = length;\n    this.now = now;\n    this.maxAge = maxAge || 0;\n  }\n\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value;\n\n  if (isStale(self, hit)) {\n    del(self, node);\n    if (!self[ALLOW_STALE]) hit = undefined;\n  }\n\n  if (hit) fn.call(thisp, hit.value, hit.key, self);\n};\n\nmodule.exports = LRUCache;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9wb21iZXIvcC9kZXYvcmVhY3Qvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcz9lNDI0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5cbmNvbnN0IE1BWCA9IFN5bWJvbCgnbWF4JylcbmNvbnN0IExFTkdUSCA9IFN5bWJvbCgnbGVuZ3RoJylcbmNvbnN0IExFTkdUSF9DQUxDVUxBVE9SID0gU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJylcbmNvbnN0IEFMTE9XX1NUQUxFID0gU3ltYm9sKCdhbGxvd1N0YWxlJylcbmNvbnN0IE1BWF9BR0UgPSBTeW1ib2woJ21heEFnZScpXG5jb25zdCBESVNQT1NFID0gU3ltYm9sKCdkaXNwb3NlJylcbmNvbnN0IE5PX0RJU1BPU0VfT05fU0VUID0gU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpXG5jb25zdCBMUlVfTElTVCA9IFN5bWJvbCgnbHJ1TGlzdCcpXG5jb25zdCBDQUNIRSA9IFN5bWJvbCgnY2FjaGUnKVxuY29uc3QgVVBEQVRFX0FHRV9PTl9HRVQgPSBTeW1ib2woJ3VwZGF0ZUFnZU9uR2V0JylcblxuY29uc3QgbmFpdmVMZW5ndGggPSAoKSA9PiAxXG5cbi8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuXG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgb3B0aW9ucyA9IHt9XG5cbiAgICBpZiAob3B0aW9ucy5tYXggJiYgKHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXggPCAwKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG4gICAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICAgIGNvbnN0IG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4IHx8IEluZmluaXR5XG5cbiAgICBjb25zdCBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSA/IG5haXZlTGVuZ3RoIDogbGNcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcbiAgICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMFxuICAgIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2VcbiAgICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgICB0aGlzW1VQREFURV9BR0VfT05fR0VUXSA9IG9wdGlvbnMudXBkYXRlQWdlT25HZXQgfHwgZmFsc2VcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG4gIHNldCBtYXggKG1MKSB7XG4gICAgaWYgKHR5cGVvZiBtTCAhPT0gJ251bWJlcicgfHwgbUwgPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXggKCkge1xuICAgIHJldHVybiB0aGlzW01BWF1cbiAgfVxuXG4gIHNldCBhbGxvd1N0YWxlIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfVxuICBnZXQgYWxsb3dTdGFsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH1cblxuICBzZXQgbWF4QWdlIChtQSkge1xuICAgIGlmICh0eXBlb2YgbUEgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4QWdlICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhfQUdFXVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG4gIHNldCBsZW5ndGhDYWxjdWxhdG9yIChsQykge1xuICAgIGlmICh0eXBlb2YgbEMgIT09ICdmdW5jdGlvbicpXG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG5cbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwXG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB7XG4gICAgICAgIGhpdC5sZW5ndGggPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpXG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgICB9KVxuICAgIH1cbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IGxlbmd0aENhbGN1bGF0b3IgKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gfVxuXG4gIGdldCBsZW5ndGggKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH1cbiAgZ2V0IGl0ZW1Db3VudCAoKSB7IHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGggfVxuXG4gIHJmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IG5leHQgPSB3YWxrZXIubmV4dFxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBuZXh0XG4gICAgfVxuICB9XG5cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLmtleSlcbiAgfVxuXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLnZhbHVlKVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICh0aGlzW0RJU1BPU0VdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4gdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpKVxuICAgIH1cblxuICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gICAgdGhpc1tMUlVfTElTVF0gPSBuZXcgWWFsbGlzdCgpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgICB0aGlzW0xFTkdUSF0gPSAwIC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICB9XG5cbiAgZHVtcCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLm1hcChoaXQgPT5cbiAgICAgIGlzU3RhbGUodGhpcywgaGl0KSA/IGZhbHNlIDoge1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfSkudG9BcnJheSgpLmZpbHRlcihoID0+IGgpXG4gIH1cblxuICBkdW1wTHJ1ICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF1cbiAgfVxuXG4gIHNldCAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gICAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICAgIGlmIChtYXhBZ2UgJiYgdHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG5cbiAgICBjb25zdCBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICAgIGNvbnN0IGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpXG4gICAgICBjb25zdCBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSlcbiAgICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgaXRlbS5ub3cgPSBub3dcbiAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlXG4gICAgICBpdGVtLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgICAgaXRlbS5sZW5ndGggPSBsZW5cbiAgICAgIHRoaXMuZ2V0KGtleSlcbiAgICAgIHRyaW0odGhpcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICAgIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgICBpZiAodGhpc1tESVNQT1NFXSlcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KVxuICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpXG4gICAgdHJpbSh0aGlzKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBoYXMgKGtleSkge1xuICAgIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdClcbiAgfVxuXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG4gIH1cblxuICBwZWVrIChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG4gIH1cblxuICBwb3AgKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGRlbCh0aGlzLCBub2RlKVxuICAgIHJldHVybiBub2RlLnZhbHVlXG4gIH1cblxuICBkZWwgKGtleSkge1xuICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgfVxuXG4gIGxvYWQgKGFycikge1xuICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgIHRoaXMucmVzZXQoKVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gICAgZm9yIChsZXQgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgY29uc3QgaGl0ID0gYXJyW2xdXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgICBpZiAoZXhwaXJlc0F0ID09PSAwKVxuICAgICAgICAvLyB0aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJ1bmUgKCkge1xuICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IGdldCh0aGlzLCBrZXksIGZhbHNlKSlcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoc2VsZiwga2V5LCBkb1VzZSkgPT4ge1xuICBjb25zdCBub2RlID0gc2VsZltDQUNIRV0uZ2V0KGtleSlcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkge1xuICAgICAgICBpZiAoc2VsZltVUERBVEVfQUdFX09OX0dFVF0pXG4gICAgICAgICAgbm9kZS52YWx1ZS5ub3cgPSBEYXRlLm5vdygpXG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaXQudmFsdWVcbiAgfVxufVxuXG5jb25zdCBpc1N0YWxlID0gKHNlbGYsIGhpdCkgPT4ge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICByZXR1cm4gaGl0Lm1heEFnZSA/IGRpZmYgPiBoaXQubWF4QWdlXG4gICAgOiBzZWxmW01BWF9BR0VdICYmIChkaWZmID4gc2VsZltNQVhfQUdFXSlcbn1cblxuY29uc3QgdHJpbSA9IHNlbGYgPT4ge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDtcbiAgICAgIHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZGVsKHNlbGYsIHdhbGtlcilcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZGVsID0gKHNlbGYsIG5vZGUpID0+IHtcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKHNlbGZbRElTUE9TRV0pXG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcblxuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpXG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKVxuICB9XG59XG5cbmNsYXNzIEVudHJ5IHtcbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhpcy5ub3cgPSBub3dcbiAgICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwXG4gIH1cbn1cblxuY29uc3QgZm9yRWFjaFN0ZXAgPSAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSA9PiB7XG4gIGxldCBoaXQgPSBub2RlLnZhbHVlXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgaGl0ID0gdW5kZWZpbmVkXG4gIH1cbiAgaWYgKGhpdClcbiAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHNlbGYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdE9BO0FBQ0E7QUF1T0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/lru-cache/index.js\n");

/***/ }),

/***/ "../../node_modules/lru-cache/node_modules/yallist/iterator.js":
/*!****************************************************************************************!*\
  !*** /home/pomber/p/dev/react/node_modules/lru-cache/node_modules/yallist/iterator.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value;\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9ub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9wb21iZXIvcC9kZXYvcmVhY3Qvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9ub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qcz8wNjJhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWWFsbGlzdCkge1xuICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlcjsgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgIHlpZWxkIHdhbGtlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/lru-cache/node_modules/yallist/iterator.js\n");

/***/ }),

/***/ "../../node_modules/lru-cache/node_modules/yallist/yallist.js":
/*!***************************************************************************************!*\
  !*** /home/pomber/p/dev/react/node_modules/lru-cache/node_modules/yallist/yallist.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = Yallist;\nYallist.Node = Node;\nYallist.create = Yallist;\n\nfunction Yallist(list) {\n  var self = this;\n\n  if (!(self instanceof Yallist)) {\n    self = new Yallist();\n  }\n\n  self.tail = null;\n  self.head = null;\n  self.length = 0;\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item);\n    });\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i]);\n    }\n  }\n\n  return self;\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list');\n  }\n\n  var next = node.next;\n  var prev = node.prev;\n\n  if (next) {\n    next.prev = prev;\n  }\n\n  if (prev) {\n    prev.next = next;\n  }\n\n  if (node === this.head) {\n    this.head = next;\n  }\n\n  if (node === this.tail) {\n    this.tail = prev;\n  }\n\n  node.list.length--;\n  node.next = null;\n  node.prev = null;\n  node.list = null;\n  return next;\n};\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var head = this.head;\n  node.list = this;\n  node.next = head;\n\n  if (head) {\n    head.prev = node;\n  }\n\n  this.head = node;\n\n  if (!this.tail) {\n    this.tail = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var tail = this.tail;\n  node.list = this;\n  node.prev = tail;\n\n  if (tail) {\n    tail.next = node;\n  }\n\n  this.tail = node;\n\n  if (!this.head) {\n    this.head = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined;\n  }\n\n  var res = this.tail.value;\n  this.tail = this.tail.prev;\n\n  if (this.tail) {\n    this.tail.next = null;\n  } else {\n    this.head = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined;\n  }\n\n  var res = this.head.value;\n  this.head = this.head.next;\n\n  if (this.head) {\n    this.head.prev = null;\n  } else {\n    this.tail = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.next;\n  }\n};\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.prev;\n  }\n};\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.next;\n  }\n\n  return res;\n};\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.prev;\n  }\n\n  return res;\n};\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc;\n  var walker = this.head;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.head) {\n    walker = this.head.next;\n    acc = this.head.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.next;\n  }\n\n  return acc;\n};\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc;\n  var walker = this.tail;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.tail) {\n    walker = this.tail.prev;\n    acc = this.tail.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.prev;\n  }\n\n  return acc;\n};\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.next;\n  }\n\n  return arr;\n};\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.prev;\n  }\n\n  return arr;\n};\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next;\n  }\n\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev;\n  }\n\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.splice = function (start, deleteCount\n/*, ...nodes */\n) {\n  if (start > this.length) {\n    start = this.length - 1;\n  }\n\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next;\n  }\n\n  var ret = [];\n\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value);\n    walker = this.removeNode(walker);\n  }\n\n  if (walker === null) {\n    walker = this.tail;\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev;\n  }\n\n  for (var i = 2; i < arguments.length; i++) {\n    walker = insert(this, walker, arguments[i]);\n  }\n\n  return ret;\n};\n\nYallist.prototype.reverse = function () {\n  var head = this.head;\n  var tail = this.tail;\n\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev;\n    walker.prev = walker.next;\n    walker.next = p;\n  }\n\n  this.head = tail;\n  this.tail = head;\n  return this;\n};\n\nfunction insert(self, node, value) {\n  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);\n\n  if (inserted.next === null) {\n    self.tail = inserted;\n  }\n\n  if (inserted.prev === null) {\n    self.head = inserted;\n  }\n\n  self.length++;\n  return inserted;\n}\n\nfunction push(self, item) {\n  self.tail = new Node(item, self.tail, null, self);\n\n  if (!self.head) {\n    self.head = self.tail;\n  }\n\n  self.length++;\n}\n\nfunction unshift(self, item) {\n  self.head = new Node(item, null, self.head, self);\n\n  if (!self.tail) {\n    self.tail = self.head;\n  }\n\n  self.length++;\n}\n\nfunction Node(value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list);\n  }\n\n  this.list = list;\n  this.value = value;\n\n  if (prev) {\n    prev.next = this;\n    this.prev = prev;\n  } else {\n    this.prev = null;\n  }\n\n  if (next) {\n    next.prev = this;\n    this.next = next;\n  } else {\n    this.next = null;\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"../../node_modules/lru-cache/node_modules/yallist/iterator.js\")(Yallist);\n} catch (er) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3BvbWJlci9wL2Rldi9yZWFjdC9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL25vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanM/M2FhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG5cbiAgcmV0dXJuIG5leHRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQgLyosIC4uLm5vZGVzICovKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDFcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHZhciByZXQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpXG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbFxuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gaW5zZXJ0KHRoaXMsIHdhbGtlciwgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2XG4gICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dFxuICAgIHdhbGtlci5uZXh0ID0gcFxuICB9XG4gIHRoaXMuaGVhZCA9IHRhaWxcbiAgdGhpcy50YWlsID0gaGVhZFxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBpbnNlcnQgKHNlbGYsIG5vZGUsIHZhbHVlKSB7XG4gIHZhciBpbnNlcnRlZCA9IG5vZGUgPT09IHNlbGYuaGVhZCA/XG4gICAgbmV3IE5vZGUodmFsdWUsIG51bGwsIG5vZGUsIHNlbGYpIDpcbiAgICBuZXcgTm9kZSh2YWx1ZSwgbm9kZSwgbm9kZS5uZXh0LCBzZWxmKVxuXG4gIGlmIChpbnNlcnRlZC5uZXh0ID09PSBudWxsKSB7XG4gICAgc2VsZi50YWlsID0gaW5zZXJ0ZWRcbiAgfVxuICBpZiAoaW5zZXJ0ZWQucHJldiA9PT0gbnVsbCkge1xuICAgIHNlbGYuaGVhZCA9IGluc2VydGVkXG4gIH1cblxuICBzZWxmLmxlbmd0aCsrXG5cbiAgcmV0dXJuIGluc2VydGVkXG59XG5cbmZ1bmN0aW9uIHB1c2ggKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi50YWlsID0gbmV3IE5vZGUoaXRlbSwgc2VsZi50YWlsLCBudWxsLCBzZWxmKVxuICBpZiAoIXNlbGYuaGVhZCkge1xuICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gdW5zaGlmdCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLmhlYWQgPSBuZXcgTm9kZShpdGVtLCBudWxsLCBzZWxmLmhlYWQsIHNlbGYpXG4gIGlmICghc2VsZi50YWlsKSB7XG4gICAgc2VsZi50YWlsID0gc2VsZi5oZWFkXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiBOb2RlICh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpXG4gIH1cblxuICB0aGlzLmxpc3QgPSBsaXN0XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gdGhpc1xuICAgIHRoaXMucHJldiA9IHByZXZcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByZXYgPSBudWxsXG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHRoaXNcbiAgICB0aGlzLm5leHQgPSBuZXh0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5uZXh0ID0gbnVsbFxuICB9XG59XG5cbnRyeSB7XG4gIC8vIGFkZCBpZiBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3IgaXMgcHJlc2VudFxuICByZXF1aXJlKCcuL2l0ZXJhdG9yLmpzJykoWWFsbGlzdClcbn0gY2F0Y2ggKGVyKSB7fVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/lru-cache/node_modules/yallist/yallist.js\n");

/***/ }),

/***/ "../../node_modules/object-assign/index.js":
/*!********************************************************************!*\
  !*** /home/pomber/p/dev/react/node_modules/object-assign/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n/* eslint-disable no-unused-vars */\n\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n  if (val === null || val === undefined) {\n    throw new TypeError('Object.assign cannot be called with null or undefined');\n  }\n\n  return Object(val);\n}\n\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign) {\n      return false;\n    } // Detect buggy property enumeration order in older V8 versions.\n    // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\n\n    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\n\n    test1[5] = 'de';\n\n    if (Object.getOwnPropertyNames(test1)[0] === '5') {\n      return false;\n    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n    var test2 = {};\n\n    for (var i = 0; i < 10; i++) {\n      test2['_' + String.fromCharCode(i)] = i;\n    }\n\n    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n      return test2[n];\n    });\n\n    if (order2.join('') !== '0123456789') {\n      return false;\n    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n    var test3 = {};\n    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n      test3[letter] = letter;\n    });\n\n    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    // We don't expect any of the above to throw, but better to be safe.\n    return false;\n  }\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n  var from;\n  var to = toObject(target);\n  var symbols;\n\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n\n    if (getOwnPropertySymbols) {\n      symbols = getOwnPropertySymbols(from);\n\n      for (var i = 0; i < symbols.length; i++) {\n        if (propIsEnumerable.call(from, symbols[i])) {\n          to[symbols[i]] = from[symbols[i]];\n        }\n      }\n    }\n  }\n\n  return to;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvcG9tYmVyL3AvZGV2L3JlYWN0L25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzP2E0NTIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/object-assign/index.js\n");

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!****************************************************************!*\
  !*** /home/pomber/p/dev/react/node_modules/process/browser.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9wb21iZXIvcC9kZXYvcmVhY3Qvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz8wYzc1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/process/browser.js\n");

/***/ }),

/***/ "../../node_modules/stackframe/stackframe.js":
/*!**********************************************************************!*\
  !*** /home/pomber/p/dev/react/node_modules/stackframe/stackframe.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  'use strict';\n\n  function _isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  }\n\n  function _getter(p) {\n    return function () {\n      return this[p];\n    };\n  }\n\n  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n  var numericProps = ['columnNumber', 'lineNumber'];\n  var stringProps = ['fileName', 'functionName', 'source'];\n  var arrayProps = ['args'];\n  var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n  function StackFrame(obj) {\n    if (!obj) return;\n\n    for (var i = 0; i < props.length; i++) {\n      if (obj[props[i]] !== undefined) {\n        this['set' + _capitalize(props[i])](obj[props[i]]);\n      }\n    }\n  }\n\n  StackFrame.prototype = {\n    getArgs: function () {\n      return this.args;\n    },\n    setArgs: function (v) {\n      if (Object.prototype.toString.call(v) !== '[object Array]') {\n        throw new TypeError('Args must be an Array');\n      }\n\n      this.args = v;\n    },\n    getEvalOrigin: function () {\n      return this.evalOrigin;\n    },\n    setEvalOrigin: function (v) {\n      if (v instanceof StackFrame) {\n        this.evalOrigin = v;\n      } else if (v instanceof Object) {\n        this.evalOrigin = new StackFrame(v);\n      } else {\n        throw new TypeError('Eval Origin must be an Object or StackFrame');\n      }\n    },\n    toString: function () {\n      var fileName = this.getFileName() || '';\n      var lineNumber = this.getLineNumber() || '';\n      var columnNumber = this.getColumnNumber() || '';\n      var functionName = this.getFunctionName() || '';\n\n      if (this.getIsEval()) {\n        if (fileName) {\n          return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n        }\n\n        return '[eval]:' + lineNumber + ':' + columnNumber;\n      }\n\n      if (functionName) {\n        return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n      }\n\n      return fileName + ':' + lineNumber + ':' + columnNumber;\n    }\n  };\n\n  StackFrame.fromString = function StackFrame$$fromString(str) {\n    var argsStartIndex = str.indexOf('(');\n    var argsEndIndex = str.lastIndexOf(')');\n    var functionName = str.substring(0, argsStartIndex);\n    var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');\n    var locationString = str.substring(argsEndIndex + 1);\n\n    if (locationString.indexOf('@') === 0) {\n      var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, '');\n      var fileName = parts[1];\n      var lineNumber = parts[2];\n      var columnNumber = parts[3];\n    }\n\n    return new StackFrame({\n      functionName: functionName,\n      args: args || undefined,\n      fileName: fileName,\n      lineNumber: lineNumber || undefined,\n      columnNumber: columnNumber || undefined\n    });\n  };\n\n  for (var i = 0; i < booleanProps.length; i++) {\n    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\n    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {\n      return function (v) {\n        this[p] = Boolean(v);\n      };\n    }(booleanProps[i]);\n  }\n\n  for (var j = 0; j < numericProps.length; j++) {\n    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\n    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {\n      return function (v) {\n        if (!_isNumber(v)) {\n          throw new TypeError(p + ' must be a Number');\n        }\n\n        this[p] = Number(v);\n      };\n    }(numericProps[j]);\n  }\n\n  for (var k = 0; k < stringProps.length; k++) {\n    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\n    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {\n      return function (v) {\n        this[p] = String(v);\n      };\n    }(stringProps[k]);\n  }\n\n  return StackFrame;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3N0YWNrZnJhbWUvc3RhY2tmcmFtZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9wb21iZXIvcC9kZXYvcmVhY3Qvbm9kZV9tb2R1bGVzL3N0YWNrZnJhbWUvc3RhY2tmcmFtZS5qcz8yOWZhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3N0YWNrZnJhbWUnLCBbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja0ZyYW1lID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIF9pc051bWJlcihuKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXR0ZXIocCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1twXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYm9vbGVhblByb3BzID0gWydpc0NvbnN0cnVjdG9yJywgJ2lzRXZhbCcsICdpc05hdGl2ZScsICdpc1RvcGxldmVsJ107XG4gICAgdmFyIG51bWVyaWNQcm9wcyA9IFsnY29sdW1uTnVtYmVyJywgJ2xpbmVOdW1iZXInXTtcbiAgICB2YXIgc3RyaW5nUHJvcHMgPSBbJ2ZpbGVOYW1lJywgJ2Z1bmN0aW9uTmFtZScsICdzb3VyY2UnXTtcbiAgICB2YXIgYXJyYXlQcm9wcyA9IFsnYXJncyddO1xuXG4gICAgdmFyIHByb3BzID0gYm9vbGVhblByb3BzLmNvbmNhdChudW1lcmljUHJvcHMsIHN0cmluZ1Byb3BzLCBhcnJheVByb3BzKTtcblxuICAgIGZ1bmN0aW9uIFN0YWNrRnJhbWUob2JqKSB7XG4gICAgICAgIGlmICghb2JqKSByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvYmpbcHJvcHNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzWydzZXQnICsgX2NhcGl0YWxpemUocHJvcHNbaV0pXShvYmpbcHJvcHNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlID0ge1xuICAgICAgICBnZXRBcmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFyZ3M6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmdzIG11c3QgYmUgYW4gQXJyYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXJncyA9IHY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RXZhbE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsT3JpZ2luO1xuICAgICAgICB9LFxuICAgICAgICBzZXRFdmFsT3JpZ2luOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIFN0YWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSB2O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsT3JpZ2luID0gbmV3IFN0YWNrRnJhbWUodik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V2YWwgT3JpZ2luIG11c3QgYmUgYW4gT2JqZWN0IG9yIFN0YWNrRnJhbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHRoaXMuZ2V0TGluZU51bWJlcigpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKSB8fCAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmdldElzRXZhbCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW2V2YWxdICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tldmFsXTonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICsgJyAoJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlciArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3RhY2tGcmFtZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gU3RhY2tGcmFtZSQkZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIGFyZ3NTdGFydEluZGV4ID0gc3RyLmluZGV4T2YoJygnKTtcbiAgICAgICAgdmFyIGFyZ3NFbmRJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignKScpO1xuXG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBzdHIuc3Vic3RyaW5nKDAsIGFyZ3NTdGFydEluZGV4KTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzdHIuc3Vic3RyaW5nKGFyZ3NTdGFydEluZGV4ICsgMSwgYXJnc0VuZEluZGV4KS5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgbG9jYXRpb25TdHJpbmcgPSBzdHIuc3Vic3RyaW5nKGFyZ3NFbmRJbmRleCArIDEpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvblN0cmluZy5pbmRleE9mKCdAJykgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IC9AKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLy5leGVjKGxvY2F0aW9uU3RyaW5nLCAnJyk7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gcGFydHNbMl07XG4gICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gcGFydHNbM107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBjb2x1bW5OdW1iZXIgfHwgdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xlYW5Qcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gX2dldHRlcihib29sZWFuUHJvcHNbaV0pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IEJvb2xlYW4odik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShib29sZWFuUHJvcHNbaV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtZXJpY1Byb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSBfZ2V0dGVyKG51bWVyaWNQcm9wc1tqXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pc051bWJlcih2KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHAgKyAnIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IE51bWJlcih2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKG51bWVyaWNQcm9wc1tqXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJpbmdQcm9wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSBfZ2V0dGVyKHN0cmluZ1Byb3BzW2tdKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IFN0cmluZyh2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHN0cmluZ1Byb3BzW2tdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RhY2tGcmFtZTtcbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxXQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUF2Q0E7QUFDQTtBQXlDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/stackframe/stackframe.js\n");

/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "../../node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = []; // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, \"loaded\", {\n      enumerable: true,\n      get: function () {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, \"id\", {\n      enumerable: true,\n      get: function () {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "../react-devtools-shared/node_modules/semver/semver.js":
/*!**************************************************************!*\
  !*** ../react-devtools-shared/node_modules/semver/semver.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer;\nvar debug;\n/* istanbul ignore next */\n\nif (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n  debug = function () {\n    var args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('SEMVER');\n    console.log.apply(console, args);\n  };\n} else {\n  debug = function () {};\n} // Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\n\n\nexports.SEMVER_SPEC_VERSION = '2.0.0';\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */\n9007199254740991; // Max safe segment length for coercion.\n\nvar MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re\n\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar t = exports.tokens = {};\nvar R = 0;\n\nfunction tok(n) {\n  t[n] = R++;\n} // The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\n\ntok('NUMERICIDENTIFIER');\nsrc[t.NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\ntok('NUMERICIDENTIFIERLOOSE');\nsrc[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ntok('NONNUMERICIDENTIFIER');\nsrc[t.NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version\n// Three dot-separated numeric identifiers.\n\ntok('MAINVERSION');\nsrc[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';\ntok('MAINVERSIONLOOSE');\nsrc[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ntok('PRERELEASEIDENTIFIER');\nsrc[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';\ntok('PRERELEASEIDENTIFIERLOOSE');\nsrc[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ntok('PRERELEASE');\nsrc[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';\ntok('PRERELEASELOOSE');\nsrc[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ntok('BUILDIDENTIFIER');\nsrc[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ntok('BUILD');\nsrc[t.BUILD] = '(?:\\\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\\\.' + src[t.BUILDIDENTIFIER] + ')*))'; // ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ntok('FULL');\ntok('FULLPLAIN');\nsrc[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';\nsrc[t.FULL] = '^' + src[t.FULLPLAIN] + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\n\ntok('LOOSEPLAIN');\nsrc[t.LOOSEPLAIN] = '[v=\\\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';\ntok('LOOSE');\nsrc[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';\ntok('GTLT');\nsrc[t.GTLT] = '((?:<|>)?=?)'; // Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\n\ntok('XRANGEIDENTIFIERLOOSE');\nsrc[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\ntok('XRANGEIDENTIFIER');\nsrc[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\\\*';\ntok('XRANGEPLAIN');\nsrc[t.XRANGEPLAIN] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';\ntok('XRANGEPLAINLOOSE');\nsrc[t.XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';\ntok('XRANGE');\nsrc[t.XRANGE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAIN] + '$';\ntok('XRANGELOOSE');\nsrc[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAINLOOSE] + '$'; // Coercion.\n// Extract anything that could conceivably be a part of a valid semver\n\ntok('COERCE');\nsrc[t.COERCE] = '(^|[^\\\\d])' + '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\\\d])';\ntok('COERCERTL');\nre[t.COERCERTL] = new RegExp(src[t.COERCE], 'g'); // Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\n\ntok('LONETILDE');\nsrc[t.LONETILDE] = '(?:~>?)';\ntok('TILDETRIM');\nsrc[t.TILDETRIM] = '(\\\\s*)' + src[t.LONETILDE] + '\\\\s+';\nre[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\ntok('TILDE');\nsrc[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';\ntok('TILDELOOSE');\nsrc[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'; // Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\n\ntok('LONECARET');\nsrc[t.LONECARET] = '(?:\\\\^)';\ntok('CARETTRIM');\nsrc[t.CARETTRIM] = '(\\\\s*)' + src[t.LONECARET] + '\\\\s+';\nre[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\ntok('CARET');\nsrc[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';\ntok('CARETLOOSE');\nsrc[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\n\ntok('COMPARATORLOOSE');\nsrc[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';\ntok('COMPARATOR');\nsrc[t.COMPARATOR] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.FULLPLAIN] + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\n\ntok('COMPARATORTRIM');\nsrc[t.COMPARATORTRIM] = '(\\\\s*)' + src[t.GTLT] + '\\\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'; // this one has to use the /g flag\n\nre[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\n\ntok('HYPHENRANGE');\nsrc[t.HYPHENRANGE] = '^\\\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\\\s+-\\\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\\\s*$';\ntok('HYPHENRANGELOOSE');\nsrc[t.HYPHENRANGELOOSE] = '^\\\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\\\s+-\\\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\\\s*$'; // Star ranges basically just allow anything at all.\n\ntok('STAR');\nsrc[t.STAR] = '(<|>)?=?\\\\s*\\\\*'; // Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\n\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n\n  if (!re[i]) {\n    re[i] = new RegExp(src[i]);\n  }\n}\n\nexports.parse = parse;\n\nfunction parse(version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n\n  if (version instanceof SemVer) {\n    return version;\n  }\n\n  if (typeof version !== 'string') {\n    return null;\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null;\n  }\n\n  var r = options.loose ? re[t.LOOSE] : re[t.FULL];\n\n  if (!r.test(version)) {\n    return null;\n  }\n\n  try {\n    return new SemVer(version, options);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\n\nfunction valid(version, options) {\n  var v = parse(version, options);\n  return v ? v.version : null;\n}\n\nexports.clean = clean;\n\nfunction clean(version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose) {\n      return version;\n    } else {\n      version = version.version;\n    }\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH) {\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');\n  }\n\n  if (!(this instanceof SemVer)) {\n    return new SemVer(version, options);\n  }\n\n  debug('SemVer', version, options);\n  this.options = options;\n  this.loose = !!options.loose;\n  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n\n  if (!m) {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  this.raw = version; // these are actually numbers\n\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n    throw new TypeError('Invalid major version');\n  }\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n    throw new TypeError('Invalid minor version');\n  }\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n    throw new TypeError('Invalid patch version');\n  } // numberify any prerelease numeric ids\n\n\n  if (!m[4]) {\n    this.prerelease = [];\n  } else {\n    this.prerelease = m[4].split('.').map(function (id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n\n        if (num >= 0 && num < MAX_SAFE_INTEGER) {\n          return num;\n        }\n      }\n\n      return id;\n    });\n  }\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function () {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n\n  if (this.prerelease.length) {\n    this.version += '-' + this.prerelease.join('.');\n  }\n\n  return this.version;\n};\n\nSemVer.prototype.toString = function () {\n  return this.version;\n};\n\nSemVer.prototype.compare = function (other) {\n  debug('SemVer.compare', this.version, this.options, other);\n\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options);\n  }\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options);\n  }\n\n  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options);\n  } // NOT having a prerelease is > having one\n\n\n  if (this.prerelease.length && !other.prerelease.length) {\n    return -1;\n  } else if (!this.prerelease.length && other.prerelease.length) {\n    return 1;\n  } else if (!this.prerelease.length && !other.prerelease.length) {\n    return 0;\n  }\n\n  var i = 0;\n\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n\n    if (a === undefined && b === undefined) {\n      return 0;\n    } else if (b === undefined) {\n      return 1;\n    } else if (a === undefined) {\n      return -1;\n    } else if (a === b) {\n      continue;\n    } else {\n      return compareIdentifiers(a, b);\n    }\n  } while (++i);\n};\n\nSemVer.prototype.compareBuild = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options);\n  }\n\n  var i = 0;\n\n  do {\n    var a = this.build[i];\n    var b = other.build[i];\n    debug('prerelease compare', i, a, b);\n\n    if (a === undefined && b === undefined) {\n      return 0;\n    } else if (b === undefined) {\n      return 1;\n    } else if (a === undefined) {\n      return -1;\n    } else if (a === b) {\n      continue;\n    } else {\n      return compareIdentifiers(a, b);\n    }\n  } while (++i);\n}; // preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\n\n\nSemVer.prototype.inc = function (release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n\n    case 'prerelease':\n      if (this.prerelease.length === 0) {\n        this.inc('patch', identifier);\n      }\n\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n        this.major++;\n      }\n\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0) {\n        this.minor++;\n      }\n\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0) {\n        this.patch++;\n      }\n\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n\n    case 'pre':\n      if (this.prerelease.length === 0) {\n        this.prerelease = [0];\n      } else {\n        var i = this.prerelease.length;\n\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n\n        if (i === -1) {\n          // didn't increment anything\n          this.prerelease.push(0);\n        }\n      }\n\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [identifier, 0];\n          }\n        } else {\n          this.prerelease = [identifier, 0];\n        }\n      }\n\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\n\nfunction inc(version, release, loose, identifier) {\n  if (typeof loose === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\n\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    var prefix = '';\n\n    if (v1.prerelease.length || v2.prerelease.length) {\n      prefix = 'pre';\n      var defaultResult = 'prerelease';\n    }\n\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key;\n        }\n      }\n    }\n\n    return defaultResult; // may be undefined\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\nvar numeric = /^[0-9]+$/;\n\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\n\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\n\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\n\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\n\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\n\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose));\n}\n\nexports.compareLoose = compareLoose;\n\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.compareBuild = compareBuild;\n\nfunction compareBuild(a, b, loose) {\n  var versionA = new SemVer(a, loose);\n  var versionB = new SemVer(b, loose);\n  return versionA.compare(versionB) || versionA.compareBuild(versionB);\n}\n\nexports.rcompare = rcompare;\n\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\n\nfunction sort(list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compareBuild(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\n\nfunction rsort(list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compareBuild(b, a, loose);\n  });\n}\n\nexports.gt = gt;\n\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\n\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\n\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\n\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\n\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\n\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\n\nfunction cmp(a, op, b, loose) {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      return a === b;\n\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      return a !== b;\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose);\n\n    case '!=':\n      return neq(a, b, loose);\n\n    case '>':\n      return gt(a, b, loose);\n\n    case '>=':\n      return gte(a, b, loose);\n\n    case '<':\n      return lt(a, b, loose);\n\n    case '<=':\n      return lte(a, b, loose);\n\n    default:\n      throw new TypeError('Invalid operator: ' + op);\n  }\n}\n\nexports.Comparator = Comparator;\n\nfunction Comparator(comp, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose) {\n      return comp;\n    } else {\n      comp = comp.value;\n    }\n  }\n\n  if (!(this instanceof Comparator)) {\n    return new Comparator(comp, options);\n  }\n\n  debug('comparator', comp, options);\n  this.options = options;\n  this.loose = !!options.loose;\n  this.parse(comp);\n\n  if (this.semver === ANY) {\n    this.value = '';\n  } else {\n    this.value = this.operator + this.semver.version;\n  }\n\n  debug('comp', this);\n}\n\nvar ANY = {};\n\nComparator.prototype.parse = function (comp) {\n  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m) {\n    throw new TypeError('Invalid comparator: ' + comp);\n  }\n\n  this.operator = m[1] !== undefined ? m[1] : '';\n\n  if (this.operator === '=') {\n    this.operator = '';\n  } // if it literally is just '>' or '' then allow anything.\n\n\n  if (!m[2]) {\n    this.semver = ANY;\n  } else {\n    this.semver = new SemVer(m[2], this.options.loose);\n  }\n};\n\nComparator.prototype.toString = function () {\n  return this.value;\n};\n\nComparator.prototype.test = function (version) {\n  debug('Comparator.test', version, this.options.loose);\n\n  if (this.semver === ANY || version === ANY) {\n    return true;\n  }\n\n  if (typeof version === 'string') {\n    try {\n      version = new SemVer(version, this.options);\n    } catch (er) {\n      return false;\n    }\n  }\n\n  return cmp(version, this.operator, this.semver, this.options);\n};\n\nComparator.prototype.intersects = function (comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required');\n  }\n\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n\n  var rangeTmp;\n\n  if (this.operator === '') {\n    if (this.value === '') {\n      return true;\n    }\n\n    rangeTmp = new Range(comp.value, options);\n    return satisfies(this.value, rangeTmp, options);\n  } else if (comp.operator === '') {\n    if (comp.value === '') {\n      return true;\n    }\n\n    rangeTmp = new Range(this.value, options);\n    return satisfies(comp.semver, rangeTmp, options);\n  }\n\n  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');\n  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');\n  var sameSemVer = this.semver.version === comp.semver.version;\n  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');\n  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');\n  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');\n  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n};\n\nexports.Range = Range;\n\nfunction Range(range, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n      return range;\n    } else {\n      return new Range(range.raw, options);\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, options);\n  }\n\n  if (!(this instanceof Range)) {\n    return new Range(range, options);\n  }\n\n  this.options = options;\n  this.loose = !!options.loose;\n  this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||\n\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function (c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function () {\n  this.range = this.set.map(function (comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function () {\n  return this.range;\n};\n\nRange.prototype.parseRange = function (range) {\n  var loose = this.options.loose;\n  range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n\n  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n\n  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[t.COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`\n\n  range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`\n\n  range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces\n\n  range = range.split(/\\s+/).join(' '); // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n  var set = range.split(' ').map(function (comp) {\n    return parseComparator(comp, this.options);\n  }, this).join(' ').split(/\\s+/);\n\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function (comp) {\n      return !!comp.match(compRe);\n    });\n  }\n\n  set = set.map(function (comp) {\n    return new Comparator(comp, this.options);\n  }, this);\n  return set;\n};\n\nRange.prototype.intersects = function (range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required');\n  }\n\n  return this.set.some(function (thisComparators) {\n    return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {\n      return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {\n        return rangeComparators.every(function (rangeComparator) {\n          return thisComparator.intersects(rangeComparator, options);\n        });\n      });\n    });\n  });\n}; // take a set of comparators and determine whether there\n// exists a version which can satisfy it\n\n\nfunction isSatisfiable(comparators, options) {\n  var result = true;\n  var remainingComparators = comparators.slice();\n  var testComparator = remainingComparators.pop();\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every(function (otherComparator) {\n      return testComparator.intersects(otherComparator, options);\n    });\n    testComparator = remainingComparators.pop();\n  }\n\n  return result;\n} // Mostly just for testing and legacy API reasons\n\n\nexports.toComparators = toComparators;\n\nfunction toComparators(range, options) {\n  return new Range(range, options).set.map(function (comp) {\n    return comp.map(function (c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n} // comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\n\n\nfunction parseComparator(comp, options) {\n  debug('comp', comp, options);\n  comp = replaceCarets(comp, options);\n  debug('caret', comp);\n  comp = replaceTildes(comp, options);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, options);\n  debug('xrange', comp);\n  comp = replaceStars(comp, options);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n} // ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\n\n\nfunction replaceTildes(comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceTilde(comp, options);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, options) {\n  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M)) {\n      ret = '';\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    } else if (pr) {\n      debug('replaceTilde pr', pr);\n      ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('tilde return', ret);\n    return ret;\n  });\n} // ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\n\n\nfunction replaceCarets(comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceCaret(comp, options);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, options) {\n  debug('caret', comp, options);\n  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M)) {\n      ret = '';\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      } else {\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';\n      }\n    } else {\n      debug('no pr');\n\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';\n      }\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, options) {\n  debug('replaceXRanges', comp, options);\n  return comp.split(/\\s+/).map(function (comp) {\n    return replaceXRange(comp, options);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, options) {\n  comp = comp.trim();\n  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];\n  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX) {\n      gtlt = '';\n    } // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n\n\n    pr = options.includePrerelease ? '-0' : '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0;\n      }\n\n      p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n\n        if (xm) {\n          M = +M + 1;\n        } else {\n          m = +m + 1;\n        }\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p + pr;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;\n    }\n\n    debug('xRange return', ret);\n    return ret;\n  });\n} // Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\n\n\nfunction replaceStars(comp, options) {\n  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!\n\n  return comp.trim().replace(re[t.STAR], '');\n} // This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\n\n\nfunction hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {\n  if (isX(fM)) {\n    from = '';\n  } else if (isX(fm)) {\n    from = '>=' + fM + '.0.0';\n  } else if (isX(fp)) {\n    from = '>=' + fM + '.' + fm + '.0';\n  } else {\n    from = '>=' + from;\n  }\n\n  if (isX(tM)) {\n    to = '';\n  } else if (isX(tm)) {\n    to = '<' + (+tM + 1) + '.0.0';\n  } else if (isX(tp)) {\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  } else if (tpr) {\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  } else {\n    to = '<=' + to;\n  }\n\n  return (from + ' ' + to).trim();\n} // if ANY of the sets match ALL of its comparators, then pass\n\n\nRange.prototype.test = function (version) {\n  if (!version) {\n    return false;\n  }\n\n  if (typeof version === 'string') {\n    try {\n      version = new SemVer(version, this.options);\n    } catch (er) {\n      return false;\n    }\n  }\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nfunction testSet(set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false;\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n\n      if (set[i].semver === ANY) {\n        continue;\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n\n        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n          return true;\n        }\n      }\n    } // Version has a -pre, but it's not one of the ones we like.\n\n\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\n\nfunction satisfies(version, range, options) {\n  try {\n    range = new Range(range, options);\n  } catch (er) {\n    return false;\n  }\n\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\n\nfunction maxSatisfying(versions, range, options) {\n  var max = null;\n  var maxSV = null;\n\n  try {\n    var rangeObj = new Range(range, options);\n  } catch (er) {\n    return null;\n  }\n\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v;\n        maxSV = new SemVer(max, options);\n      }\n    }\n  });\n  return max;\n}\n\nexports.minSatisfying = minSatisfying;\n\nfunction minSatisfying(versions, range, options) {\n  var min = null;\n  var minSV = null;\n\n  try {\n    var rangeObj = new Range(range, options);\n  } catch (er) {\n    return null;\n  }\n\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v;\n        minSV = new SemVer(min, options);\n      }\n    }\n  });\n  return min;\n}\n\nexports.minVersion = minVersion;\n\nfunction minVersion(range, loose) {\n  range = new Range(range, loose);\n  var minver = new SemVer('0.0.0');\n\n  if (range.test(minver)) {\n    return minver;\n  }\n\n  minver = new SemVer('0.0.0-0');\n\n  if (range.test(minver)) {\n    return minver;\n  }\n\n  minver = null;\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n    comparators.forEach(function (comparator) {\n      // Clone to avoid manipulating the comparator's semver object.\n      var compver = new SemVer(comparator.semver.version);\n\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++;\n          } else {\n            compver.prerelease.push(0);\n          }\n\n          compver.raw = compver.format();\n\n        /* fallthrough */\n\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver;\n          }\n\n          break;\n\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error('Unexpected operation: ' + comparator.operator);\n      }\n    });\n  }\n\n  if (minver && range.test(minver)) {\n    return minver;\n  }\n\n  return null;\n}\n\nexports.validRange = validRange;\n\nfunction validRange(range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*';\n  } catch (er) {\n    return null;\n  }\n} // Determine if version is less than all the versions possible in the range\n\n\nexports.ltr = ltr;\n\nfunction ltr(version, range, options) {\n  return outside(version, range, '<', options);\n} // Determine if version is greater than all the versions possible in the range.\n\n\nexports.gtr = gtr;\n\nfunction gtr(version, range, options) {\n  return outside(version, range, '>', options);\n}\n\nexports.outside = outside;\n\nfunction outside(version, range, hilo, options) {\n  version = new SemVer(version, options);\n  range = new Range(range, options);\n  var gtfn, ltefn, ltfn, comp, ecomp;\n\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  } // If it satisifes the range it is not outside\n\n\n  if (satisfies(version, range, options)) {\n    return false;\n  } // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n    var high = null;\n    var low = null;\n    comparators.forEach(function (comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0');\n      }\n\n      high = high || comparator;\n      low = low || comparator;\n\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator;\n      }\n    }); // If the edge version comparator has a operator then our version\n    // isn't outside it\n\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    } // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n\n\n    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.prerelease = prerelease;\n\nfunction prerelease(version, options) {\n  var parsed = parse(version, options);\n  return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n}\n\nexports.intersects = intersects;\n\nfunction intersects(r1, r2, options) {\n  r1 = new Range(r1, options);\n  r2 = new Range(r2, options);\n  return r1.intersects(r2);\n}\n\nexports.coerce = coerce;\n\nfunction coerce(version, options) {\n  if (version instanceof SemVer) {\n    return version;\n  }\n\n  if (typeof version === 'number') {\n    version = String(version);\n  }\n\n  if (typeof version !== 'string') {\n    return null;\n  }\n\n  options = options || {};\n  var match = null;\n\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE]);\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    var next;\n\n    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n      if (!match || next.index + next[0].length !== match.index + match[0].length) {\n        match = next;\n      }\n\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;\n    } // leave it in a clean state\n\n\n    re[t.COERCERTL].lastIndex = -1;\n  }\n\n  if (match === null) {\n    return null;\n  }\n\n  return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ \"../../node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9ub2RlX21vZHVsZXMvc2VtdmVyL3NlbXZlci5qcz8yNzZiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNlbVZlclxuXG52YXIgZGVidWdcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgcHJvY2Vzcy5lbnYgJiZcbiAgICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gICAgL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykpIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG4gICAgYXJncy51bnNoaWZ0KCdTRU1WRVInKVxuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpXG4gIH1cbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge31cbn1cblxuLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuZXhwb3J0cy5TRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG52YXIgTUFYX0xFTkdUSCA9IDI1NlxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbnZhciBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTZcblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbnZhciByZSA9IGV4cG9ydHMucmUgPSBbXVxudmFyIHNyYyA9IGV4cG9ydHMuc3JjID0gW11cbnZhciB0ID0gZXhwb3J0cy50b2tlbnMgPSB7fVxudmFyIFIgPSAwXG5cbmZ1bmN0aW9uIHRvayAobikge1xuICB0W25dID0gUisrXG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbnRvaygnTlVNRVJJQ0lERU5USUZJRVInKVxuc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdID0gJzB8WzEtOV1cXFxcZConXG50b2soJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnKVxuc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gPSAnWzAtOV0rJ1xuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG50b2soJ05PTk5VTUVSSUNJREVOVElGSUVSJylcbnNyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXSA9ICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJ1xuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxudG9rKCdNQUlOVkVSU0lPTicpXG5zcmNbdC5NQUlOVkVSU0lPTl0gPSAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSArICcpJ1xuXG50b2soJ01BSU5WRVJTSU9OTE9PU0UnKVxuc3JjW3QuTUFJTlZFUlNJT05MT09TRV0gPSAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKSdcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG50b2soJ1BSRVJFTEVBU0VJREVOVElGSUVSJylcbnNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXSA9ICcoPzonICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSdcblxudG9rKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJylcbnNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdID0gJyg/OicgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSdcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG50b2soJ1BSRVJFTEVBU0UnKVxuc3JjW3QuUFJFUkVMRUFTRV0gPSAnKD86LSgnICsgc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl0gKyAnKSopKSdcblxudG9rKCdQUkVSRUxFQVNFTE9PU0UnKVxuc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSA9ICcoPzotPygnICsgc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gKyAnKSopKSdcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxudG9rKCdCVUlMRElERU5USUZJRVInKVxuc3JjW3QuQlVJTERJREVOVElGSUVSXSA9ICdbMC05QS1aYS16LV0rJ1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxudG9rKCdCVUlMRCcpXG5zcmNbdC5CVUlMRF0gPSAnKD86XFxcXCsoJyArIHNyY1t0LkJVSUxESURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbdC5CVUlMRElERU5USUZJRVJdICsgJykqKSknXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG50b2soJ0ZVTEwnKVxudG9rKCdGVUxMUExBSU4nKVxuc3JjW3QuRlVMTFBMQUlOXSA9ICd2PycgKyBzcmNbdC5NQUlOVkVSU0lPTl0gK1xuICAgICAgICAgICAgICAgICAgc3JjW3QuUFJFUkVMRUFTRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdICsgJz8nXG5cbnNyY1t0LkZVTExdID0gJ14nICsgc3JjW3QuRlVMTFBMQUlOXSArICckJ1xuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG50b2soJ0xPT1NFUExBSU4nKVxuc3JjW3QuTE9PU0VQTEFJTl0gPSAnW3Y9XFxcXHNdKicgKyBzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICBzcmNbdC5QUkVSRUxFQVNFTE9PU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXSArICc/J1xuXG50b2soJ0xPT1NFJylcbnNyY1t0LkxPT1NFXSA9ICdeJyArIHNyY1t0LkxPT1NFUExBSU5dICsgJyQnXG5cbnRvaygnR1RMVCcpXG5zcmNbdC5HVExUXSA9ICcoKD86PHw+KT89PyknXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbnRvaygnWFJBTkdFSURFTlRJRklFUkxPT1NFJylcbnNyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV0gPSBzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSArICd8eHxYfFxcXFwqJ1xudG9rKCdYUkFOR0VJREVOVElGSUVSJylcbnNyY1t0LlhSQU5HRUlERU5USUZJRVJdID0gc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdICsgJ3x4fFh8XFxcXConXG5cbnRvaygnWFJBTkdFUExBSU4nKVxuc3JjW3QuWFJBTkdFUExBSU5dID0gJ1t2PVxcXFxzXSooJyArIHNyY1t0LlhSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1t0LlhSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1t0LlhSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1t0LlBSRVJFTEVBU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgICAnKT8pPydcblxudG9rKCdYUkFOR0VQTEFJTkxPT1NFJylcbnNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdID0gJ1t2PVxcXFxzXSooJyArIHNyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1t0LlBSRVJFTEVBU0VMT09TRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKT8pPydcblxudG9rKCdYUkFOR0UnKVxuc3JjW3QuWFJBTkdFXSA9ICdeJyArIHNyY1t0LkdUTFRdICsgJ1xcXFxzKicgKyBzcmNbdC5YUkFOR0VQTEFJTl0gKyAnJCdcbnRvaygnWFJBTkdFTE9PU0UnKVxuc3JjW3QuWFJBTkdFTE9PU0VdID0gJ14nICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqJyArIHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdICsgJyQnXG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxudG9rKCdDT0VSQ0UnKVxuc3JjW3QuQ09FUkNFXSA9ICcoXnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pJyArXG4gICAgICAgICAgICAgICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICtcbiAgICAgICAgICAgICAgJyg/OlxcXFwuKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSkpPycgK1xuICAgICAgICAgICAgICAnKD86JHxbXlxcXFxkXSknXG50b2soJ0NPRVJDRVJUTCcpXG5yZVt0LkNPRVJDRVJUTF0gPSBuZXcgUmVnRXhwKHNyY1t0LkNPRVJDRV0sICdnJylcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbnRvaygnTE9ORVRJTERFJylcbnNyY1t0LkxPTkVUSUxERV0gPSAnKD86fj4/KSdcblxudG9rKCdUSUxERVRSSU0nKVxuc3JjW3QuVElMREVUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbdC5MT05FVElMREVdICsgJ1xcXFxzKydcbnJlW3QuVElMREVUUklNXSA9IG5ldyBSZWdFeHAoc3JjW3QuVElMREVUUklNXSwgJ2cnKVxudmFyIHRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG50b2soJ1RJTERFJylcbnNyY1t0LlRJTERFXSA9ICdeJyArIHNyY1t0LkxPTkVUSUxERV0gKyBzcmNbdC5YUkFOR0VQTEFJTl0gKyAnJCdcbnRvaygnVElMREVMT09TRScpXG5zcmNbdC5USUxERUxPT1NFXSA9ICdeJyArIHNyY1t0LkxPTkVUSUxERV0gKyBzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSArICckJ1xuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxudG9rKCdMT05FQ0FSRVQnKVxuc3JjW3QuTE9ORUNBUkVUXSA9ICcoPzpcXFxcXiknXG5cbnRvaygnQ0FSRVRUUklNJylcbnNyY1t0LkNBUkVUVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW3QuTE9ORUNBUkVUXSArICdcXFxccysnXG5yZVt0LkNBUkVUVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1t0LkNBUkVUVFJJTV0sICdnJylcbnZhciBjYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxudG9rKCdDQVJFVCcpXG5zcmNbdC5DQVJFVF0gPSAnXicgKyBzcmNbdC5MT05FQ0FSRVRdICsgc3JjW3QuWFJBTkdFUExBSU5dICsgJyQnXG50b2soJ0NBUkVUTE9PU0UnKVxuc3JjW3QuQ0FSRVRMT09TRV0gPSAnXicgKyBzcmNbdC5MT05FQ0FSRVRdICsgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gKyAnJCdcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbnRvaygnQ09NUEFSQVRPUkxPT1NFJylcbnNyY1t0LkNPTVBBUkFUT1JMT09TRV0gPSAnXicgKyBzcmNbdC5HVExUXSArICdcXFxccyooJyArIHNyY1t0LkxPT1NFUExBSU5dICsgJykkfF4kJ1xudG9rKCdDT01QQVJBVE9SJylcbnNyY1t0LkNPTVBBUkFUT1JdID0gJ14nICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqKCcgKyBzcmNbdC5GVUxMUExBSU5dICsgJykkfF4kJ1xuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxudG9rKCdDT01QQVJBVE9SVFJJTScpXG5zcmNbdC5DT01QQVJBVE9SVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW3QuR1RMVF0gK1xuICAgICAgICAgICAgICAgICAgICAgICdcXFxccyooJyArIHNyY1t0LkxPT1NFUExBSU5dICsgJ3wnICsgc3JjW3QuWFJBTkdFUExBSU5dICsgJyknXG5cbi8vIHRoaXMgb25lIGhhcyB0byB1c2UgdGhlIC9nIGZsYWdcbnJlW3QuQ09NUEFSQVRPUlRSSU1dID0gbmV3IFJlZ0V4cChzcmNbdC5DT01QQVJBVE9SVFJJTV0sICdnJylcbnZhciBjb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxudG9rKCdIWVBIRU5SQU5HRScpXG5zcmNbdC5IWVBIRU5SQU5HRV0gPSAnXlxcXFxzKignICsgc3JjW3QuWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnXG5cbnRvaygnSFlQSEVOUkFOR0VMT09TRScpXG5zcmNbdC5IWVBIRU5SQU5HRUxPT1NFXSA9ICdeXFxcXHMqKCcgKyBzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnXG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbnRvaygnU1RBUicpXG5zcmNbdC5TVEFSXSA9ICcoPHw+KT89P1xcXFxzKlxcXFwqJ1xuXG4vLyBDb21waWxlIHRvIGFjdHVhbCByZWdleHAgb2JqZWN0cy5cbi8vIEFsbCBhcmUgZmxhZy1mcmVlLCB1bmxlc3MgdGhleSB3ZXJlIGNyZWF0ZWQgYWJvdmUgd2l0aCBhIGZsYWcuXG5mb3IgKHZhciBpID0gMDsgaSA8IFI7IGkrKykge1xuICBkZWJ1ZyhpLCBzcmNbaV0pXG4gIGlmICghcmVbaV0pIHtcbiAgICByZVtpXSA9IG5ldyBSZWdFeHAoc3JjW2ldKVxuICB9XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZVxuZnVuY3Rpb24gcGFyc2UgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuTE9PU0VdIDogcmVbdC5GVUxMXVxuICBpZiAoIXIudGVzdCh2ZXJzaW9uKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5leHBvcnRzLnZhbGlkID0gdmFsaWRcbmZ1bmN0aW9uIHZhbGlkICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHZhciB2ID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsXG59XG5cbmV4cG9ydHMuY2xlYW4gPSBjbGVhblxuZnVuY3Rpb24gY2xlYW4gKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxuXG5leHBvcnRzLlNlbVZlciA9IFNlbVZlclxuXG5mdW5jdGlvbiBTZW1WZXIgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgfVxuICB9XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgaWYgKHZlcnNpb24ubG9vc2UgPT09IG9wdGlvbnMubG9vc2UpIHtcbiAgICAgIHJldHVybiB2ZXJzaW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbilcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJylcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfVxuXG4gIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBvcHRpb25zKVxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcblxuICB2YXIgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pXG5cbiAgaWYgKCFtKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbilcbiAgfVxuXG4gIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gIC8vIHRoZXNlIGFyZSBhY3R1YWxseSBudW1iZXJzXG4gIHRoaXMubWFqb3IgPSArbVsxXVxuICB0aGlzLm1pbm9yID0gK21bMl1cbiAgdGhpcy5wYXRjaCA9ICttWzNdXG5cbiAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgfVxuXG4gIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gIH1cblxuICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICB9XG5cbiAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gIGlmICghbVs0XSkge1xuICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgIHZhciBudW0gPSAraWRcbiAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZFxuICAgIH0pXG4gIH1cblxuICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gIHRoaXMuZm9ybWF0KClcbn1cblxuU2VtVmVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudmVyc2lvbiA9IHRoaXMubWFqb3IgKyAnLicgKyB0aGlzLm1pbm9yICsgJy4nICsgdGhpcy5wYXRjaFxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgIHRoaXMudmVyc2lvbiArPSAnLScgKyB0aGlzLnByZXJlbGVhc2Uuam9pbignLicpXG4gIH1cbiAgcmV0dXJuIHRoaXMudmVyc2lvblxufVxuXG5TZW1WZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52ZXJzaW9uXG59XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbn1cblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlTWFpbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG59XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZVByZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTFcbiAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgIHJldHVybiAxXG4gIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIHZhciBpID0gMFxuICBkbyB7XG4gICAgdmFyIGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICB2YXIgYiA9IG90aGVyLnByZXJlbGVhc2VbaV1cbiAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgfVxuICB9IHdoaWxlICgrK2kpXG59XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZUJ1aWxkID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIGRvIHtcbiAgICB2YXIgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICB2YXIgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgIH1cbiAgfSB3aGlsZSAoKytpKVxufVxuXG4vLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4vLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG5TZW1WZXIucHJvdG90eXBlLmluYyA9IGZ1bmN0aW9uIChyZWxlYXNlLCBpZGVudGlmaWVyKSB7XG4gIHN3aXRjaCAocmVsZWFzZSkge1xuICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgdGhpcy5taW5vcisrXG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpXG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgIGJyZWFrXG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgLy8gcHJlcGF0Y2guXG4gICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgfVxuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnbWFqb3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgIGlmICh0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICB9XG4gICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICBicmVha1xuICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgfVxuICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICB9XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgYnJlYWtcbiAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgIC8vIDEuMC4wIFwicHJlXCIgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICBjYXNlICdwcmUnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAnICsgcmVsZWFzZSlcbiAgfVxuICB0aGlzLmZvcm1hdCgpXG4gIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uXG4gIHJldHVybiB0aGlzXG59XG5cbmV4cG9ydHMuaW5jID0gaW5jXG5mdW5jdGlvbiBpbmMgKHZlcnNpb24sIHJlbGVhc2UsIGxvb3NlLCBpZGVudGlmaWVyKSB7XG4gIGlmICh0eXBlb2YgKGxvb3NlKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gbG9vc2VcbiAgICBsb29zZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmV4cG9ydHMuZGlmZiA9IGRpZmZcbmZ1bmN0aW9uIGRpZmYgKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkge1xuICAgIHJldHVybiBudWxsXG4gIH0gZWxzZSB7XG4gICAgdmFyIHYxID0gcGFyc2UodmVyc2lvbjEpXG4gICAgdmFyIHYyID0gcGFyc2UodmVyc2lvbjIpXG4gICAgdmFyIHByZWZpeCA9ICcnXG4gICAgaWYgKHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICBwcmVmaXggPSAncHJlJ1xuICAgICAgdmFyIGRlZmF1bHRSZXN1bHQgPSAncHJlcmVsZWFzZSdcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsga2V5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQgLy8gbWF5IGJlIHVuZGVmaW5lZFxuICB9XG59XG5cbmV4cG9ydHMuY29tcGFyZUlkZW50aWZpZXJzID0gY29tcGFyZUlkZW50aWZpZXJzXG5cbnZhciBudW1lcmljID0gL15bMC05XSskL1xuZnVuY3Rpb24gY29tcGFyZUlkZW50aWZpZXJzIChhLCBiKSB7XG4gIHZhciBhbnVtID0gbnVtZXJpYy50ZXN0KGEpXG4gIHZhciBibnVtID0gbnVtZXJpYy50ZXN0KGIpXG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYVxuICAgIGIgPSArYlxuICB9XG5cbiAgcmV0dXJuIGEgPT09IGIgPyAwXG4gICAgOiAoYW51bSAmJiAhYm51bSkgPyAtMVxuICAgIDogKGJudW0gJiYgIWFudW0pID8gMVxuICAgIDogYSA8IGIgPyAtMVxuICAgIDogMVxufVxuXG5leHBvcnRzLnJjb21wYXJlSWRlbnRpZmllcnMgPSByY29tcGFyZUlkZW50aWZpZXJzXG5mdW5jdGlvbiByY29tcGFyZUlkZW50aWZpZXJzIChhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcbn1cblxuZXhwb3J0cy5tYWpvciA9IG1ham9yXG5mdW5jdGlvbiBtYWpvciAoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG59XG5cbmV4cG9ydHMubWlub3IgPSBtaW5vclxuZnVuY3Rpb24gbWlub3IgKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vclxufVxuXG5leHBvcnRzLnBhdGNoID0gcGF0Y2hcbmZ1bmN0aW9uIHBhdGNoIChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2hcbn1cblxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZVxuZnVuY3Rpb24gY29tcGFyZSAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG59XG5cbmV4cG9ydHMuY29tcGFyZUxvb3NlID0gY29tcGFyZUxvb3NlXG5mdW5jdGlvbiBjb21wYXJlTG9vc2UgKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgdHJ1ZSlcbn1cblxuZXhwb3J0cy5jb21wYXJlQnVpbGQgPSBjb21wYXJlQnVpbGRcbmZ1bmN0aW9uIGNvbXBhcmVCdWlsZCAoYSwgYiwgbG9vc2UpIHtcbiAgdmFyIHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgdmFyIHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cblxuZXhwb3J0cy5yY29tcGFyZSA9IHJjb21wYXJlXG5mdW5jdGlvbiByY29tcGFyZSAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYiwgYSwgbG9vc2UpXG59XG5cbmV4cG9ydHMuc29ydCA9IHNvcnRcbmZ1bmN0aW9uIHNvcnQgKGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlQnVpbGQoYSwgYiwgbG9vc2UpXG4gIH0pXG59XG5cbmV4cG9ydHMucnNvcnQgPSByc29ydFxuZnVuY3Rpb24gcnNvcnQgKGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpXG4gIH0pXG59XG5cbmV4cG9ydHMuZ3QgPSBndFxuZnVuY3Rpb24gZ3QgKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDBcbn1cblxuZXhwb3J0cy5sdCA9IGx0XG5mdW5jdGlvbiBsdCAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxufVxuXG5leHBvcnRzLmVxID0gZXFcbmZ1bmN0aW9uIGVxIChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbn1cblxuZXhwb3J0cy5uZXEgPSBuZXFcbmZ1bmN0aW9uIG5lcSAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwXG59XG5cbmV4cG9ydHMuZ3RlID0gZ3RlXG5mdW5jdGlvbiBndGUgKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG59XG5cbmV4cG9ydHMubHRlID0gbHRlXG5mdW5jdGlvbiBsdGUgKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG59XG5cbmV4cG9ydHMuY21wID0gY21wXG5mdW5jdGlvbiBjbXAgKGEsIG9wLCBiLCBsb29zZSkge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhID09PSBiXG5cbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JylcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9wZXJhdG9yOiAnICsgb3ApXG4gIH1cbn1cblxuZXhwb3J0cy5Db21wYXJhdG9yID0gQ29tcGFyYXRvclxuZnVuY3Rpb24gQ29tcGFyYXRvciAoY29tcCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICByZXR1cm4gY29tcFxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBvcHRpb25zKVxuICB9XG5cbiAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgdGhpcy5wYXJzZShjb21wKVxuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgdGhpcy52YWx1ZSA9ICcnXG4gIH0gZWxzZSB7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gIH1cblxuICBkZWJ1ZygnY29tcCcsIHRoaXMpXG59XG5cbnZhciBBTlkgPSB7fVxuQ29tcGFyYXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29tcCkge1xuICB2YXIgciA9IHRoaXMub3B0aW9ucy5sb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgdmFyIG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgaWYgKCFtKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb21wYXJhdG9yOiAnICsgY29tcClcbiAgfVxuXG4gIHRoaXMub3BlcmF0b3IgPSBtWzFdICE9PSB1bmRlZmluZWQgPyBtWzFdIDogJydcbiAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICB9XG5cbiAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gIGlmICghbVsyXSkge1xuICAgIHRoaXMuc2VtdmVyID0gQU5ZXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgfVxufVxuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVcbn1cblxuQ29tcGFyYXRvci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLm9wdGlvbnMpXG59XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAoY29tcCwgb3B0aW9ucykge1xuICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgdmFyIHJhbmdlVG1wXG5cbiAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKVxuICAgIHJldHVybiBzYXRpc2ZpZXModGhpcy52YWx1ZSwgcmFuZ2VUbXAsIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHNhdGlzZmllcyhjb21wLnNlbXZlciwgcmFuZ2VUbXAsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpXG4gIHZhciBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JylcbiAgdmFyIHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uXG4gIHZhciBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpXG4gIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9XG4gICAgY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICgodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKSlcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpKVxuXG4gIHJldHVybiBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHwgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW5cbn1cblxuZXhwb3J0cy5SYW5nZSA9IFJhbmdlXG5mdW5jdGlvbiBSYW5nZSAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gcmFuZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UudmFsdWUsIG9wdGlvbnMpXG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgdGhpcy5yYXcgPSByYW5nZVxuICB0aGlzLnNldCA9IHJhbmdlLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pLm1hcChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSlcbiAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgLy8gdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgcmVsZXZhbnQgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgIHJldHVybiBjLmxlbmd0aFxuICB9KVxuXG4gIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSlcbiAgfVxuXG4gIHRoaXMuZm9ybWF0KClcbn1cblxuUmFuZ2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0Lm1hcChmdW5jdGlvbiAoY29tcHMpIHtcbiAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKVxuICB9KS5qb2luKCd8fCcpLnRyaW0oKVxuICByZXR1cm4gdGhpcy5yYW5nZVxufVxuXG5SYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlXG59XG5cblJhbmdlLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIHZhciBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZVxuICByYW5nZSA9IHJhbmdlLnRyaW0oKVxuICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgdmFyIGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV1cbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKVxuICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSlcbiAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW3QuQ09NUEFSQVRPUlRSSU1dKVxuXG4gIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuXG4gIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuXG4gIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgdmFyIGNvbXBSZSA9IGxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICB2YXIgc2V0ID0gcmFuZ2Uuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucylcbiAgfSwgdGhpcykuam9pbignICcpLnNwbGl0KC9cXHMrLylcbiAgaWYgKHRoaXMub3B0aW9ucy5sb29zZSkge1xuICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbiAoY29tcCkge1xuICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChjb21wUmUpXG4gICAgfSlcbiAgfVxuICBzZXQgPSBzZXQubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucylcbiAgfSwgdGhpcylcblxuICByZXR1cm4gc2V0XG59XG5cblJhbmdlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKHJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpXG4gIH1cblxuICByZXR1cm4gdGhpcy5zZXQuc29tZShmdW5jdGlvbiAodGhpc0NvbXBhcmF0b3JzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGlzU2F0aXNmaWFibGUodGhpc0NvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgcmFuZ2Uuc2V0LnNvbWUoZnVuY3Rpb24gKHJhbmdlQ29tcGFyYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpc1NhdGlzZmlhYmxlKHJhbmdlQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uICh0aGlzQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24gKHJhbmdlQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgKVxuICB9KVxufVxuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuZnVuY3Rpb24gaXNTYXRpc2ZpYWJsZSAoY29tcGFyYXRvcnMsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IHRydWVcbiAgdmFyIHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICB2YXIgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24gKG90aGVyQ29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIE1vc3RseSBqdXN0IGZvciB0ZXN0aW5nIGFuZCBsZWdhY3kgQVBJIHJlYXNvbnNcbmV4cG9ydHMudG9Db21wYXJhdG9ycyA9IHRvQ29tcGFyYXRvcnNcbmZ1bmN0aW9uIHRvQ29tcGFyYXRvcnMgKHJhbmdlLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldC5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlXG4gICAgfSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpXG4gIH0pXG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvciAoY29tcCwgb3B0aW9ucykge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuZnVuY3Rpb24gaXNYIChpZCkge1xuICByZXR1cm4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG59XG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wXG5mdW5jdGlvbiByZXBsYWNlVGlsZGVzIChjb21wLCBvcHRpb25zKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZSAoY29tcCwgb3B0aW9ucykge1xuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbiAoXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICB2YXIgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCdcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnLScgKyBwciArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjBcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCdcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wXG4vLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXRzIChjb21wLCBvcHRpb25zKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VDYXJldCAoY29tcCwgb3B0aW9ucykge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKVxuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkNBUkVUTE9PU0VdIDogcmVbdC5DQVJFVF1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbiAoXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICB2YXIgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCdcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcilcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnLScgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJy0nICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnLScgKyBwciArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2VzIChjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2UgKGNvbXAsIG9wdGlvbnMpIHtcbiAgY29tcCA9IGNvbXAudHJpbSgpXG4gIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICB2YXIgeE0gPSBpc1goTSlcbiAgICB2YXIgeG0gPSB4TSB8fCBpc1gobSlcbiAgICB2YXIgeHAgPSB4bSB8fCBpc1gocClcbiAgICB2YXIgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgLy8gPjEuMi4zID0+ID49IDEuMi40XG4gICAgICAgIGd0bHQgPSAnPj0nXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgICBtID0gMFxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IGd0bHQgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwclxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAnICsgcHIgKyAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCcgKyBwclxuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCcgKyBwciArXG4gICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnICsgcHJcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmZ1bmN0aW9uIHJlcGxhY2VTdGFycyAoY29tcCwgb3B0aW9ucykge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgb3B0aW9ucylcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW3QuU1RBUl0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wXG5mdW5jdGlvbiBoeXBoZW5SZXBsYWNlICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpIHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuMC4wJ1xuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gJz49JyArIGZNICsgJy4nICsgZm0gKyAnLjAnXG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9ICc+PScgKyBmcm9tXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSAnPCcgKyAoK3RNICsgMSkgKyAnLjAuMCdcbiAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgdG8gPSAnPCcgKyB0TSArICcuJyArICgrdG0gKyAxKSArICcuMCdcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9ICc8PScgKyB0TSArICcuJyArIHRtICsgJy4nICsgdHAgKyAnLScgKyB0cHJcbiAgfSBlbHNlIHtcbiAgICB0byA9ICc8PScgKyB0b1xuICB9XG5cbiAgcmV0dXJuIChmcm9tICsgJyAnICsgdG8pLnRyaW0oKVxufVxuXG4vLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG5SYW5nZS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gIGlmICghdmVyc2lvbikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbiwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHRlc3RTZXQgKHNldCwgdmVyc2lvbiwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghc2V0W2ldLnRlc3QodmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoICYmICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgIC8vIEZvciBleGFtcGxlLCBeMS4yLjMtcHIuMSBkZXN1Z2FycyB0byA+PTEuMi4zLXByLjEgPDIuMC4wXG4gICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQncyB3aXRoaW4gdGhlIHJhbmdlIHNldCBieSB0aGUgY29tcGFyYXRvcnMuXG4gICAgZm9yIChpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcilcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydHMuc2F0aXNmaWVzID0gc2F0aXNmaWVzXG5mdW5jdGlvbiBzYXRpc2ZpZXMgKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbilcbn1cblxuZXhwb3J0cy5tYXhTYXRpc2Z5aW5nID0gbWF4U2F0aXNmeWluZ1xuZnVuY3Rpb24gbWF4U2F0aXNmeWluZyAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSB7XG4gIHZhciBtYXggPSBudWxsXG4gIHZhciBtYXhTViA9IG51bGxcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5cbmV4cG9ydHMubWluU2F0aXNmeWluZyA9IG1pblNhdGlzZnlpbmdcbmZ1bmN0aW9uIG1pblNhdGlzZnlpbmcgKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykge1xuICB2YXIgbWluID0gbnVsbFxuICB2YXIgbWluU1YgPSBudWxsXG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5cbmV4cG9ydHMubWluVmVyc2lvbiA9IG1pblZlcnNpb25cbmZ1bmN0aW9uIG1pblZlcnNpb24gKHJhbmdlLCBsb29zZSkge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgdmFyIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoY29tcGFyYXRvcikge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIHZhciBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghbWludmVyIHx8IGd0KG1pbnZlciwgY29tcHZlcikpIHtcbiAgICAgICAgICAgIG1pbnZlciA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG9wZXJhdGlvbjogJyArIGNvbXBhcmF0b3Iub3BlcmF0b3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0cy52YWxpZFJhbmdlID0gdmFsaWRSYW5nZVxuZnVuY3Rpb24gdmFsaWRSYW5nZSAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBsZXNzIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2VcbmV4cG9ydHMubHRyID0gbHRyXG5mdW5jdGlvbiBsdHIgKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG59XG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmV4cG9ydHMuZ3RyID0gZ3RyXG5mdW5jdGlvbiBndHIgKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpXG59XG5cbmV4cG9ydHMub3V0c2lkZSA9IG91dHNpZGVcbmZ1bmN0aW9uIG91dHNpZGUgKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuXG4gIHZhciBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXBcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3RcbiAgICAgIGx0ZWZuID0gbHRlXG4gICAgICBsdGZuID0gbHRcbiAgICAgIGNvbXAgPSAnPidcbiAgICAgIGVjb21wID0gJz49J1xuICAgICAgYnJlYWtcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdFxuICAgICAgbHRlZm4gPSBndGVcbiAgICAgIGx0Zm4gPSBndFxuICAgICAgY29tcCA9ICc8J1xuICAgICAgZWNvbXAgPSAnPD0nXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpXG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2lmZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICB2YXIgaGlnaCA9IG51bGxcbiAgICB2YXIgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoY29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnRzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG5mdW5jdGlvbiBwcmVyZWxlYXNlICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5cbmV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHNcbmZ1bmN0aW9uIGludGVyc2VjdHMgKHIxLCByMiwgb3B0aW9ucykge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxuXG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZVxuZnVuY3Rpb24gY29lcmNlICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdmFyIG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgdmFyIG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggIT09IHZlcnNpb24ubGVuZ3RoKVxuICAgICkge1xuICAgICAgaWYgKCFtYXRjaCB8fFxuICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gbmV4dC5pbmRleCArIG5leHRbMV0ubGVuZ3RoICsgbmV4dFsyXS5sZW5ndGhcbiAgICB9XG4gICAgLy8gbGVhdmUgaXQgaW4gYSBjbGVhbiBzdGF0ZVxuICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSAtMVxuICB9XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiBwYXJzZShtYXRjaFsyXSArXG4gICAgJy4nICsgKG1hdGNoWzNdIHx8ICcwJykgK1xuICAgICcuJyArIChtYXRjaFs0XSB8fCAnMCcpLCBvcHRpb25zKVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFsR0E7QUFDQTtBQW1HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcENBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBR0E7QUFJQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBckJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFoQkE7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/node_modules/semver/semver.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js":
/*!***************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js ***!
  \***************************************************************************/
/*! exports provided: describeBuiltInComponentFrame, describeNativeComponentFrame, describeClassComponentFrame, describeFunctionComponentFrame, describeUnknownElementTypeFrameInDEV */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"describeBuiltInComponentFrame\", function() { return describeBuiltInComponentFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"describeNativeComponentFrame\", function() { return describeNativeComponentFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"describeClassComponentFrame\", function() { return describeClassComponentFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"describeFunctionComponentFrame\", function() { return describeFunctionComponentFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"describeUnknownElementTypeFrameInDEV\", function() { return describeUnknownElementTypeFrameInDEV; });\n/* harmony import */ var _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReactSymbols */ \"../react-devtools-shared/src/backend/ReactSymbols.js\");\n/* harmony import */ var _DevToolsConsolePatching__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DevToolsConsolePatching */ \"../react-devtools-shared/src/backend/DevToolsConsolePatching.js\");\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of ReactComponentStackFrame.\n// This fork enables DevTools to use the same \"native\" component stack format,\n// while still maintaining support for multiple renderer versions\n// (which use different values for ReactTypeOfWork).\n // The shared console patching code is DEV-only.\n// We can't use it since DevTools only ships production builds.\n\n\nlet prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  if (prefix === undefined) {\n    // Extract the VM specific prefix used by each line.\n    try {\n      throw Error();\n    } catch (x) {\n      const match = x.stack.trim().match(/\\n( *(at )?)/);\n      prefix = match && match[1] || '';\n    }\n  } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n  return '\\n' + prefix + name;\n}\nlet reentry = false;\nlet componentFrameCache;\n\nif (true) {\n  const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct, currentDispatcherRef) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  if (true) {\n    const frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  let control;\n  const previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  reentry = true; // Override the dispatcher so effects scheduled by this shallow render are thrown away.\n  //\n  // Note that unlike the code this was forked from (in ReactComponentStackFrame)\n  // DevTools should override the dispatcher even when DevTools is compiled in production mode,\n  // because the app itself may be in development mode and log errors/warnings.\n\n  const previousDispatcher = currentDispatcherRef.current;\n  currentDispatcherRef.current = null;\n  Object(_DevToolsConsolePatching__WEBPACK_IMPORTED_MODULE_1__[\"disableLogs\"])();\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      const Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      const sampleLines = sample.stack.split('\\n');\n      const controlLines = control.stack.split('\\n');\n      let s = sampleLines.length - 1;\n      let c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                const frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, frame);\n                  }\n                } // Return the line we found.\n\n\n                return frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n    Error.prepareStackTrace = previousPrepareStackTrace;\n    currentDispatcherRef.current = previousDispatcher;\n    Object(_DevToolsConsolePatching__WEBPACK_IMPORTED_MODULE_1__[\"reenableLogs\"])();\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  const name = fn ? fn.displayName || fn.name : '';\n  const syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  if (true) {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeClassComponentFrame(ctor, source, ownerFn, currentDispatcherRef) {\n  return describeNativeComponentFrame(ctor, true, currentDispatcherRef);\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn, currentDispatcherRef) {\n  return describeNativeComponentFrame(fn, false, currentDispatcherRef);\n}\n\nfunction shouldConstruct(Component) {\n  const prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn, currentDispatcherRef) {\n  if (false) {}\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    return describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type, source, ownerFn);\n  }\n\n  switch (type) {\n    case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"SUSPENSE_NUMBER\"]:\n    case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"SUSPENSE_SYMBOL_STRING\"]:\n      return describeBuiltInComponentFrame('Suspense', source, ownerFn);\n\n    case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"SUSPENSE_LIST_NUMBER\"]:\n    case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"SUSPENSE_LIST_SYMBOL_STRING\"]:\n      return describeBuiltInComponentFrame('SuspenseList', source, ownerFn);\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"FORWARD_REF_NUMBER\"]:\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"FORWARD_REF_SYMBOL_STRING\"]:\n        return describeFunctionComponentFrame(type.render, source, ownerFn, currentDispatcherRef);\n\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"MEMO_NUMBER\"]:\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"MEMO_SYMBOL_STRING\"]:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn, currentDispatcherRef);\n\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"LAZY_NUMBER\"]:\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_0__[\"LAZY_SYMBOL_STRING\"]:\n        {\n          const lazyComponent = type;\n          const payload = lazyComponent._payload;\n          const init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn, currentDispatcherRef);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL0RldlRvb2xzQ29tcG9uZW50U3RhY2tGcmFtZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvRGV2VG9vbHNDb21wb25lbnRTdGFja0ZyYW1lLmpzPzkwYWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIFRoaXMgaXMgYSBEZXZUb29scyBmb3JrIG9mIFJlYWN0Q29tcG9uZW50U3RhY2tGcmFtZS5cbi8vIFRoaXMgZm9yayBlbmFibGVzIERldlRvb2xzIHRvIHVzZSB0aGUgc2FtZSBcIm5hdGl2ZVwiIGNvbXBvbmVudCBzdGFjayBmb3JtYXQsXG4vLyB3aGlsZSBzdGlsbCBtYWludGFpbmluZyBzdXBwb3J0IGZvciBtdWx0aXBsZSByZW5kZXJlciB2ZXJzaW9uc1xuLy8gKHdoaWNoIHVzZSBkaWZmZXJlbnQgdmFsdWVzIGZvciBSZWFjdFR5cGVPZldvcmspLlxuXG5pbXBvcnQgdHlwZSB7U291cmNlfSBmcm9tICdzaGFyZWQvUmVhY3RFbGVtZW50VHlwZSc7XG5pbXBvcnQgdHlwZSB7TGF6eUNvbXBvbmVudH0gZnJvbSAncmVhY3Qvc3JjL1JlYWN0TGF6eSc7XG5pbXBvcnQgdHlwZSB7Q3VycmVudERpc3BhdGNoZXJSZWZ9IGZyb20gJy4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBGT1JXQVJEX1JFRl9OVU1CRVIsXG4gIEZPUldBUkRfUkVGX1NZTUJPTF9TVFJJTkcsXG4gIExBWllfTlVNQkVSLFxuICBMQVpZX1NZTUJPTF9TVFJJTkcsXG4gIE1FTU9fTlVNQkVSLFxuICBNRU1PX1NZTUJPTF9TVFJJTkcsXG4gIFNVU1BFTlNFX05VTUJFUixcbiAgU1VTUEVOU0VfU1lNQk9MX1NUUklORyxcbiAgU1VTUEVOU0VfTElTVF9OVU1CRVIsXG4gIFNVU1BFTlNFX0xJU1RfU1lNQk9MX1NUUklORyxcbn0gZnJvbSAnLi9SZWFjdFN5bWJvbHMnO1xuXG4vLyBUaGUgc2hhcmVkIGNvbnNvbGUgcGF0Y2hpbmcgY29kZSBpcyBERVYtb25seS5cbi8vIFdlIGNhbid0IHVzZSBpdCBzaW5jZSBEZXZUb29scyBvbmx5IHNoaXBzIHByb2R1Y3Rpb24gYnVpbGRzLlxuaW1wb3J0IHtkaXNhYmxlTG9ncywgcmVlbmFibGVMb2dzfSBmcm9tICcuL0RldlRvb2xzQ29uc29sZVBhdGNoaW5nJztcblxubGV0IHByZWZpeDtcbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcbiAgbmFtZTogc3RyaW5nLFxuICBzb3VyY2U6IHZvaWQgfCBudWxsIHwgU291cmNlLFxuICBvd25lckZuOiB2b2lkIHwgbnVsbCB8IEZ1bmN0aW9uLFxuKTogc3RyaW5nIHtcbiAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgJyc7XG4gICAgfVxuICB9XG4gIC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xufVxuXG5sZXQgcmVlbnRyeSA9IGZhbHNlO1xubGV0IGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5pZiAoX19ERVZfXykge1xuICBjb25zdCBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKFxuICBmbjogRnVuY3Rpb24sXG4gIGNvbnN0cnVjdDogYm9vbGVhbixcbiAgY3VycmVudERpc3BhdGNoZXJSZWY6IEN1cnJlbnREaXNwYXRjaGVyUmVmLFxuKTogc3RyaW5nIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICBsZXQgY29udHJvbDtcblxuICBjb25zdCBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gIC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcblxuICByZWVudHJ5ID0gdHJ1ZTtcblxuICAvLyBPdmVycmlkZSB0aGUgZGlzcGF0Y2hlciBzbyBlZmZlY3RzIHNjaGVkdWxlZCBieSB0aGlzIHNoYWxsb3cgcmVuZGVyIGFyZSB0aHJvd24gYXdheS5cbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHVubGlrZSB0aGUgY29kZSB0aGlzIHdhcyBmb3JrZWQgZnJvbSAoaW4gUmVhY3RDb21wb25lbnRTdGFja0ZyYW1lKVxuICAvLyBEZXZUb29scyBzaG91bGQgb3ZlcnJpZGUgdGhlIGRpc3BhdGNoZXIgZXZlbiB3aGVuIERldlRvb2xzIGlzIGNvbXBpbGVkIGluIHByb2R1Y3Rpb24gbW9kZSxcbiAgLy8gYmVjYXVzZSB0aGUgYXBwIGl0c2VsZiBtYXkgYmUgaW4gZGV2ZWxvcG1lbnQgbW9kZSBhbmQgbG9nIGVycm9ycy93YXJuaW5ncy5cbiAgY29uc3QgcHJldmlvdXNEaXNwYXRjaGVyID0gY3VycmVudERpc3BhdGNoZXJSZWYuY3VycmVudDtcbiAgY3VycmVudERpc3BhdGNoZXJSZWYuY3VycmVudCA9IG51bGw7XG4gIGRpc2FibGVMb2dzKCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIGNvbnN0IEZha2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICBjb25zdCBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICBjb25zdCBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIGxldCBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTtcbiAgICAgICAgICAgICAgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICBjb25zdCBmcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBmcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG5cbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZi5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgIHJlZW5hYmxlTG9ncygpO1xuICB9XG4gIC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cbiAgY29uc3QgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICBjb25zdCBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuICBpZiAoX19ERVZfXykge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShcbiAgY3RvcjogRnVuY3Rpb24sXG4gIHNvdXJjZTogdm9pZCB8IG51bGwgfCBTb3VyY2UsXG4gIG93bmVyRm46IHZvaWQgfCBudWxsIHwgRnVuY3Rpb24sXG4gIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBDdXJyZW50RGlzcGF0Y2hlclJlZixcbik6IHN0cmluZyB7XG4gIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGN0b3IsIHRydWUsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShcbiAgZm46IEZ1bmN0aW9uLFxuICBzb3VyY2U6IHZvaWQgfCBudWxsIHwgU291cmNlLFxuICBvd25lckZuOiB2b2lkIHwgbnVsbCB8IEZ1bmN0aW9uLFxuICBjdXJyZW50RGlzcGF0Y2hlclJlZjogQ3VycmVudERpc3BhdGNoZXJSZWYsXG4pOiBzdHJpbmcge1xuICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudDogRnVuY3Rpb24pIHtcbiAgY29uc3QgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoXG4gIHR5cGU6IGFueSxcbiAgc291cmNlOiB2b2lkIHwgbnVsbCB8IFNvdXJjZSxcbiAgb3duZXJGbjogdm9pZCB8IG51bGwgfCBGdW5jdGlvbixcbiAgY3VycmVudERpc3BhdGNoZXJSZWY6IEN1cnJlbnREaXNwYXRjaGVyUmVmLFxuKTogc3RyaW5nIHtcbiAgaWYgKCFfX0RFVl9fKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICB0eXBlLFxuICAgICAgc2hvdWxkQ29uc3RydWN0KHR5cGUpLFxuICAgICAgY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTVVNQRU5TRV9OVU1CRVI6XG4gICAgY2FzZSBTVVNQRU5TRV9TWU1CT0xfU1RSSU5HOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScsIHNvdXJjZSwgb3duZXJGbik7XG4gICAgY2FzZSBTVVNQRU5TRV9MSVNUX05VTUJFUjpcbiAgICBjYXNlIFNVU1BFTlNFX0xJU1RfU1lNQk9MX1NUUklORzpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jywgc291cmNlLCBvd25lckZuKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIEZPUldBUkRfUkVGX05VTUJFUjpcbiAgICAgIGNhc2UgRk9SV0FSRF9SRUZfU1lNQk9MX1NUUklORzpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShcbiAgICAgICAgICB0eXBlLnJlbmRlcixcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgb3duZXJGbixcbiAgICAgICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgTUVNT19OVU1CRVI6XG4gICAgICBjYXNlIE1FTU9fU1lNQk9MX1NUUklORzpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihcbiAgICAgICAgICB0eXBlLnR5cGUsXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIG93bmVyRm4sXG4gICAgICAgICAgY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgICAgICk7XG4gICAgICBjYXNlIExBWllfTlVNQkVSOlxuICAgICAgY2FzZSBMQVpZX1NZTUJPTF9TVFJJTkc6IHtcbiAgICAgICAgY29uc3QgbGF6eUNvbXBvbmVudDogTGF6eUNvbXBvbmVudDxhbnksIGFueT4gPSAodHlwZTogYW55KTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgIGNvbnN0IGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihcbiAgICAgICAgICAgIGluaXQocGF5bG9hZCksXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBvd25lckZuLFxuICAgICAgICAgICAgY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQWNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BLGVBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQWhDQTtBQWtDQTtBQUNBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/DevToolsConsolePatching.js":
/*!***********************************************************************!*\
  !*** ../react-devtools-shared/src/backend/DevToolsConsolePatching.js ***!
  \***********************************************************************/
/*! exports provided: disableLogs, reenableLogs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableLogs\", function() { return disableLogs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reenableLogs\", function() { return reenableLogs; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of shared/ConsolePatchingDev.\n// The shared console patching code is DEV-only.\n// We can't use it since DevTools only ships production builds.\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nlet disabledDepth = 0;\nlet prevLog;\nlet prevInfo;\nlet prevWarn;\nlet prevError;\nlet prevGroup;\nlet prevGroupCollapsed;\nlet prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  if (disabledDepth === 0) {\n    /* eslint-disable react-internal/no-production-logging */\n    prevLog = console.log;\n    prevInfo = console.info;\n    prevWarn = console.warn;\n    prevError = console.error;\n    prevGroup = console.group;\n    prevGroupCollapsed = console.groupCollapsed;\n    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n    const props = {\n      configurable: true,\n      enumerable: true,\n      value: disabledLog,\n      writable: true\n    }; // $FlowFixMe Flow thinks console is immutable.\n\n    Object.defineProperties(console, {\n      info: props,\n      log: props,\n      warn: props,\n      error: props,\n      group: props,\n      groupCollapsed: props,\n      groupEnd: props\n    });\n    /* eslint-enable react-internal/no-production-logging */\n  }\n\n  disabledDepth++;\n}\nfunction reenableLogs() {\n  disabledDepth--;\n\n  if (disabledDepth === 0) {\n    /* eslint-disable react-internal/no-production-logging */\n    const props = {\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }; // $FlowFixMe Flow thinks console is immutable.\n\n    Object.defineProperties(console, {\n      log: { ...props,\n        value: prevLog\n      },\n      info: { ...props,\n        value: prevInfo\n      },\n      warn: { ...props,\n        value: prevWarn\n      },\n      error: { ...props,\n        value: prevError\n      },\n      group: { ...props,\n        value: prevGroup\n      },\n      groupCollapsed: { ...props,\n        value: prevGroupCollapsed\n      },\n      groupEnd: { ...props,\n        value: prevGroupEnd\n      }\n    });\n    /* eslint-enable react-internal/no-production-logging */\n  }\n\n  if (disabledDepth < 0) {\n    console.error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL0RldlRvb2xzQ29uc29sZVBhdGNoaW5nLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9EZXZUb29sc0NvbnNvbGVQYXRjaGluZy5qcz9kODhlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vLyBUaGlzIGlzIGEgRGV2VG9vbHMgZm9yayBvZiBzaGFyZWQvQ29uc29sZVBhdGNoaW5nRGV2LlxuLy8gVGhlIHNoYXJlZCBjb25zb2xlIHBhdGNoaW5nIGNvZGUgaXMgREVWLW9ubHkuXG4vLyBXZSBjYW4ndCB1c2UgaXQgc2luY2UgRGV2VG9vbHMgb25seSBzaGlwcyBwcm9kdWN0aW9uIGJ1aWxkcy5cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxuXG5sZXQgZGlzYWJsZWREZXB0aCA9IDA7XG5sZXQgcHJldkxvZztcbmxldCBwcmV2SW5mbztcbmxldCBwcmV2V2FybjtcbmxldCBwcmV2RXJyb3I7XG5sZXQgcHJldkdyb3VwO1xubGV0IHByZXZHcm91cENvbGxhcHNlZDtcbmxldCBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlTG9ncygpOiB2b2lkIHtcbiAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfTtcbiAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgIGluZm86IHByb3BzLFxuICAgICAgbG9nOiBwcm9wcyxcbiAgICAgIHdhcm46IHByb3BzLFxuICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgZ3JvdXBFbmQ6IHByb3BzLFxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gIH1cbiAgZGlzYWJsZWREZXB0aCsrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCk6IHZvaWQge1xuICBkaXNhYmxlZERlcHRoLS07XG4gIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfTtcbiAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgIGxvZzogey4uLnByb3BzLCB2YWx1ZTogcHJldkxvZ30sXG4gICAgICBpbmZvOiB7Li4ucHJvcHMsIHZhbHVlOiBwcmV2SW5mb30sXG4gICAgICB3YXJuOiB7Li4ucHJvcHMsIHZhbHVlOiBwcmV2V2Fybn0sXG4gICAgICBlcnJvcjogey4uLnByb3BzLCB2YWx1ZTogcHJldkVycm9yfSxcbiAgICAgIGdyb3VwOiB7Li4ucHJvcHMsIHZhbHVlOiBwcmV2R3JvdXB9LFxuICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHsuLi5wcm9wcywgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZH0sXG4gICAgICBncm91cEVuZDogey4uLnByb3BzLCB2YWx1ZTogcHJldkdyb3VwRW5kfSxcbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICB9XG4gIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAnZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgK1xuICAgICAgICAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgICApO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/DevToolsConsolePatching.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js":
/*!***************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js ***!
  \***************************************************************************/
/*! exports provided: getStackByFiberInDevAndProd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStackByFiberInDevAndProd\", function() { return getStackByFiberInDevAndProd; });\n/* harmony import */ var _DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DevToolsComponentStackFrame */ \"../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js\");\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of ReactFiberComponentStack.\n// This fork enables DevTools to use the same \"native\" component stack format,\n// while still maintaining support for multiple renderer versions\n// (which use different values for ReactTypeOfWork).\n\n\nfunction describeFiber(workTagMap, workInProgress, currentDispatcherRef) {\n  const {\n    HostComponent,\n    LazyComponent,\n    SuspenseComponent,\n    SuspenseListComponent,\n    FunctionComponent,\n    IndeterminateComponent,\n    SimpleMemoComponent,\n    ForwardRef,\n    ClassComponent\n  } = workTagMap;\n  const owner =  true ? workInProgress._debugOwner ? workInProgress._debugOwner.type : null : undefined;\n  const source =  true ? workInProgress._debugSource : undefined;\n\n  switch (workInProgress.tag) {\n    case HostComponent:\n      return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeBuiltInComponentFrame\"])(workInProgress.type, source, owner);\n\n    case LazyComponent:\n      return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeBuiltInComponentFrame\"])('Lazy', source, owner);\n\n    case SuspenseComponent:\n      return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeBuiltInComponentFrame\"])('Suspense', source, owner);\n\n    case SuspenseListComponent:\n      return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeBuiltInComponentFrame\"])('SuspenseList', source, owner);\n\n    case FunctionComponent:\n    case IndeterminateComponent:\n    case SimpleMemoComponent:\n      return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeFunctionComponentFrame\"])(workInProgress.type, source, owner, currentDispatcherRef);\n\n    case ForwardRef:\n      return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeFunctionComponentFrame\"])(workInProgress.type.render, source, owner, currentDispatcherRef);\n\n    case ClassComponent:\n      return Object(_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__[\"describeClassComponentFrame\"])(workInProgress.type, source, owner, currentDispatcherRef);\n\n    default:\n      return '';\n  }\n}\n\nfunction getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {\n  try {\n    let info = '';\n    let node = workInProgress;\n\n    do {\n      info += describeFiber(workTagMap, node, currentDispatcherRef);\n      node = node.return;\n    } while (node);\n\n    return info;\n  } catch (x) {\n    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL0RldlRvb2xzRmliZXJDb21wb25lbnRTdGFjay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvRGV2VG9vbHNGaWJlckNvbXBvbmVudFN0YWNrLmpzPzE4ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIFRoaXMgaXMgYSBEZXZUb29scyBmb3JrIG9mIFJlYWN0RmliZXJDb21wb25lbnRTdGFjay5cbi8vIFRoaXMgZm9yayBlbmFibGVzIERldlRvb2xzIHRvIHVzZSB0aGUgc2FtZSBcIm5hdGl2ZVwiIGNvbXBvbmVudCBzdGFjayBmb3JtYXQsXG4vLyB3aGlsZSBzdGlsbCBtYWludGFpbmluZyBzdXBwb3J0IGZvciBtdWx0aXBsZSByZW5kZXJlciB2ZXJzaW9uc1xuLy8gKHdoaWNoIHVzZSBkaWZmZXJlbnQgdmFsdWVzIGZvciBSZWFjdFR5cGVPZldvcmspLlxuXG5pbXBvcnQgdHlwZSB7RmliZXJ9IGZyb20gJ3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0SW50ZXJuYWxUeXBlcyc7XG5pbXBvcnQgdHlwZSB7Q3VycmVudERpc3BhdGNoZXJSZWYsIFdvcmtUYWdNYXB9IGZyb20gJy4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSxcbiAgZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lLFxuICBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUsXG59IGZyb20gJy4vRGV2VG9vbHNDb21wb25lbnRTdGFja0ZyYW1lJztcblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihcbiAgd29ya1RhZ01hcDogV29ya1RhZ01hcCxcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICBjdXJyZW50RGlzcGF0Y2hlclJlZjogQ3VycmVudERpc3BhdGNoZXJSZWYsXG4pOiBzdHJpbmcge1xuICBjb25zdCB7XG4gICAgSG9zdENvbXBvbmVudCxcbiAgICBMYXp5Q29tcG9uZW50LFxuICAgIFN1c3BlbnNlQ29tcG9uZW50LFxuICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudCxcbiAgICBGdW5jdGlvbkNvbXBvbmVudCxcbiAgICBJbmRldGVybWluYXRlQ29tcG9uZW50LFxuICAgIFNpbXBsZU1lbW9Db21wb25lbnQsXG4gICAgRm9yd2FyZFJlZixcbiAgICBDbGFzc0NvbXBvbmVudCxcbiAgfSA9IHdvcmtUYWdNYXA7XG5cbiAgY29uc3Qgb3duZXI6IG51bGwgfCBGdW5jdGlvbiA9IF9fREVWX19cbiAgICA/IHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyXG4gICAgICA/IHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyLnR5cGVcbiAgICAgIDogbnVsbFxuICAgIDogbnVsbDtcbiAgY29uc3Qgc291cmNlID0gX19ERVZfXyA/IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZSA6IG51bGw7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHdvcmtJblByb2dyZXNzLnR5cGUsIHNvdXJjZSwgb3duZXIpO1xuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScsIHNvdXJjZSwgb3duZXIpO1xuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJywgc291cmNlLCBvd25lcik7XG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcsIHNvdXJjZSwgb3duZXIpO1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgb3duZXIsXG4gICAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmLFxuICAgICAgKTtcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLnJlbmRlcixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBvd25lcixcbiAgICAgICAgY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgICApO1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIG93bmVyLFxuICAgICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKFxuICB3b3JrVGFnTWFwOiBXb3JrVGFnTWFwLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBDdXJyZW50RGlzcGF0Y2hlclJlZixcbik6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgbGV0IGluZm8gPSAnJztcbiAgICBsZXQgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICAgIGRvIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcih3b3JrVGFnTWFwLCBub2RlLCBjdXJyZW50RGlzcGF0Y2hlclJlZik7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcgKyB4Lm1lc3NhZ2UgKyAnXFxuJyArIHguc3RhY2s7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBWUE7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQWpDQTtBQW1DQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/ReactSymbols.js":
/*!************************************************************!*\
  !*** ../react-devtools-shared/src/backend/ReactSymbols.js ***!
  \************************************************************/
/*! exports provided: CONCURRENT_MODE_NUMBER, CONCURRENT_MODE_SYMBOL_STRING, CONTEXT_NUMBER, CONTEXT_SYMBOL_STRING, DEPRECATED_ASYNC_MODE_SYMBOL_STRING, ELEMENT_NUMBER, ELEMENT_SYMBOL_STRING, DEBUG_TRACING_MODE_NUMBER, DEBUG_TRACING_MODE_SYMBOL_STRING, FORWARD_REF_NUMBER, FORWARD_REF_SYMBOL_STRING, FRAGMENT_NUMBER, FRAGMENT_SYMBOL_STRING, LAZY_NUMBER, LAZY_SYMBOL_STRING, MEMO_NUMBER, MEMO_SYMBOL_STRING, PORTAL_NUMBER, PORTAL_SYMBOL_STRING, PROFILER_NUMBER, PROFILER_SYMBOL_STRING, PROVIDER_NUMBER, PROVIDER_SYMBOL_STRING, SCOPE_NUMBER, SCOPE_SYMBOL_STRING, STRICT_MODE_NUMBER, STRICT_MODE_SYMBOL_STRING, SUSPENSE_NUMBER, SUSPENSE_SYMBOL_STRING, SUSPENSE_LIST_NUMBER, SUSPENSE_LIST_SYMBOL_STRING */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONCURRENT_MODE_NUMBER\", function() { return CONCURRENT_MODE_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONCURRENT_MODE_SYMBOL_STRING\", function() { return CONCURRENT_MODE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONTEXT_NUMBER\", function() { return CONTEXT_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONTEXT_SYMBOL_STRING\", function() { return CONTEXT_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEPRECATED_ASYNC_MODE_SYMBOL_STRING\", function() { return DEPRECATED_ASYNC_MODE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ELEMENT_NUMBER\", function() { return ELEMENT_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ELEMENT_SYMBOL_STRING\", function() { return ELEMENT_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_TRACING_MODE_NUMBER\", function() { return DEBUG_TRACING_MODE_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_TRACING_MODE_SYMBOL_STRING\", function() { return DEBUG_TRACING_MODE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FORWARD_REF_NUMBER\", function() { return FORWARD_REF_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FORWARD_REF_SYMBOL_STRING\", function() { return FORWARD_REF_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FRAGMENT_NUMBER\", function() { return FRAGMENT_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FRAGMENT_SYMBOL_STRING\", function() { return FRAGMENT_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LAZY_NUMBER\", function() { return LAZY_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LAZY_SYMBOL_STRING\", function() { return LAZY_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MEMO_NUMBER\", function() { return MEMO_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MEMO_SYMBOL_STRING\", function() { return MEMO_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PORTAL_NUMBER\", function() { return PORTAL_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PORTAL_SYMBOL_STRING\", function() { return PORTAL_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PROFILER_NUMBER\", function() { return PROFILER_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PROFILER_SYMBOL_STRING\", function() { return PROFILER_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PROVIDER_NUMBER\", function() { return PROVIDER_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PROVIDER_SYMBOL_STRING\", function() { return PROVIDER_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCOPE_NUMBER\", function() { return SCOPE_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCOPE_SYMBOL_STRING\", function() { return SCOPE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STRICT_MODE_NUMBER\", function() { return STRICT_MODE_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STRICT_MODE_SYMBOL_STRING\", function() { return STRICT_MODE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SUSPENSE_NUMBER\", function() { return SUSPENSE_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SUSPENSE_SYMBOL_STRING\", function() { return SUSPENSE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SUSPENSE_LIST_NUMBER\", function() { return SUSPENSE_LIST_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SUSPENSE_LIST_SYMBOL_STRING\", function() { return SUSPENSE_LIST_SYMBOL_STRING; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This list should be kept updated to reflect additions to 'shared/ReactSymbols'.\n// DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:\n// 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)\n// 2. DevTools must support both Symbol and numeric forms of each symbol;\n//    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.\nconst CONCURRENT_MODE_NUMBER = 0xeacf;\nconst CONCURRENT_MODE_SYMBOL_STRING = 'Symbol(react.concurrent_mode)';\nconst CONTEXT_NUMBER = 0xeace;\nconst CONTEXT_SYMBOL_STRING = 'Symbol(react.context)';\nconst DEPRECATED_ASYNC_MODE_SYMBOL_STRING = 'Symbol(react.async_mode)';\nconst ELEMENT_NUMBER = 0xeac7;\nconst ELEMENT_SYMBOL_STRING = 'Symbol(react.element)';\nconst DEBUG_TRACING_MODE_NUMBER = 0xeae1;\nconst DEBUG_TRACING_MODE_SYMBOL_STRING = 'Symbol(react.debug_trace_mode)';\nconst FORWARD_REF_NUMBER = 0xead0;\nconst FORWARD_REF_SYMBOL_STRING = 'Symbol(react.forward_ref)';\nconst FRAGMENT_NUMBER = 0xeacb;\nconst FRAGMENT_SYMBOL_STRING = 'Symbol(react.fragment)';\nconst LAZY_NUMBER = 0xead4;\nconst LAZY_SYMBOL_STRING = 'Symbol(react.lazy)';\nconst MEMO_NUMBER = 0xead3;\nconst MEMO_SYMBOL_STRING = 'Symbol(react.memo)';\nconst PORTAL_NUMBER = 0xeaca;\nconst PORTAL_SYMBOL_STRING = 'Symbol(react.portal)';\nconst PROFILER_NUMBER = 0xead2;\nconst PROFILER_SYMBOL_STRING = 'Symbol(react.profiler)';\nconst PROVIDER_NUMBER = 0xeacd;\nconst PROVIDER_SYMBOL_STRING = 'Symbol(react.provider)';\nconst SCOPE_NUMBER = 0xead7;\nconst SCOPE_SYMBOL_STRING = 'Symbol(react.scope)';\nconst STRICT_MODE_NUMBER = 0xeacc;\nconst STRICT_MODE_SYMBOL_STRING = 'Symbol(react.strict_mode)';\nconst SUSPENSE_NUMBER = 0xead1;\nconst SUSPENSE_SYMBOL_STRING = 'Symbol(react.suspense)';\nconst SUSPENSE_LIST_NUMBER = 0xead8;\nconst SUSPENSE_LIST_SYMBOL_STRING = 'Symbol(react.suspense_list)';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzLmpzP2Y4MjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIFRoaXMgbGlzdCBzaG91bGQgYmUga2VwdCB1cGRhdGVkIHRvIHJlZmxlY3QgYWRkaXRpb25zIHRvICdzaGFyZWQvUmVhY3RTeW1ib2xzJy5cbi8vIERldlRvb2xzIGNhbid0IGltcG9ydCBzeW1ib2xzIGZyb20gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnIGRpcmVjdGx5IGZvciB0d28gcmVhc29uczpcbi8vIDEuIERldlRvb2xzIHJlcXVpcmVzIHN5bWJvbHMgd2hpY2ggbWF5IGhhdmUgYmVlbiBkZWxldGVkIGluIG1vcmUgcmVjZW50IHZlcnNpb25zIChlLmcuIGNvbmN1cnJlbnQgbW9kZSlcbi8vIDIuIERldlRvb2xzIG11c3Qgc3VwcG9ydCBib3RoIFN5bWJvbCBhbmQgbnVtZXJpYyBmb3JtcyBvZiBlYWNoIHN5bWJvbDtcbi8vICAgIFNpbmNlIGUuZy4gc3RhbmRhbG9uZSBEZXZUb29scyBydW5zIGluIGEgc2VwYXJhdGUgcHJvY2VzcywgaXQgY2FuJ3QgcmVseSBvbiBpdHMgb3duIEVTIGNhcGFiaWxpdGllcy5cblxuZXhwb3J0IGNvbnN0IENPTkNVUlJFTlRfTU9ERV9OVU1CRVIgPSAweGVhY2Y7XG5leHBvcnQgY29uc3QgQ09OQ1VSUkVOVF9NT0RFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmNvbmN1cnJlbnRfbW9kZSknO1xuXG5leHBvcnQgY29uc3QgQ09OVEVYVF9OVU1CRVIgPSAweGVhY2U7XG5leHBvcnQgY29uc3QgQ09OVEVYVF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5jb250ZXh0KSc7XG5cbmV4cG9ydCBjb25zdCBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuYXN5bmNfbW9kZSknO1xuXG5leHBvcnQgY29uc3QgRUxFTUVOVF9OVU1CRVIgPSAweGVhYzc7XG5leHBvcnQgY29uc3QgRUxFTUVOVF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5lbGVtZW50KSc7XG5cbmV4cG9ydCBjb25zdCBERUJVR19UUkFDSU5HX01PREVfTlVNQkVSID0gMHhlYWUxO1xuZXhwb3J0IGNvbnN0IERFQlVHX1RSQUNJTkdfTU9ERV9TWU1CT0xfU1RSSU5HID1cbiAgJ1N5bWJvbChyZWFjdC5kZWJ1Z190cmFjZV9tb2RlKSc7XG5cbmV4cG9ydCBjb25zdCBGT1JXQVJEX1JFRl9OVU1CRVIgPSAweGVhZDA7XG5leHBvcnQgY29uc3QgRk9SV0FSRF9SRUZfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuZm9yd2FyZF9yZWYpJztcblxuZXhwb3J0IGNvbnN0IEZSQUdNRU5UX05VTUJFUiA9IDB4ZWFjYjtcbmV4cG9ydCBjb25zdCBGUkFHTUVOVF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5mcmFnbWVudCknO1xuXG5leHBvcnQgY29uc3QgTEFaWV9OVU1CRVIgPSAweGVhZDQ7XG5leHBvcnQgY29uc3QgTEFaWV9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5sYXp5KSc7XG5cbmV4cG9ydCBjb25zdCBNRU1PX05VTUJFUiA9IDB4ZWFkMztcbmV4cG9ydCBjb25zdCBNRU1PX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0Lm1lbW8pJztcblxuZXhwb3J0IGNvbnN0IFBPUlRBTF9OVU1CRVIgPSAweGVhY2E7XG5leHBvcnQgY29uc3QgUE9SVEFMX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnBvcnRhbCknO1xuXG5leHBvcnQgY29uc3QgUFJPRklMRVJfTlVNQkVSID0gMHhlYWQyO1xuZXhwb3J0IGNvbnN0IFBST0ZJTEVSX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnByb2ZpbGVyKSc7XG5cbmV4cG9ydCBjb25zdCBQUk9WSURFUl9OVU1CRVIgPSAweGVhY2Q7XG5leHBvcnQgY29uc3QgUFJPVklERVJfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QucHJvdmlkZXIpJztcblxuZXhwb3J0IGNvbnN0IFNDT1BFX05VTUJFUiA9IDB4ZWFkNztcbmV4cG9ydCBjb25zdCBTQ09QRV9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5zY29wZSknO1xuXG5leHBvcnQgY29uc3QgU1RSSUNUX01PREVfTlVNQkVSID0gMHhlYWNjO1xuZXhwb3J0IGNvbnN0IFNUUklDVF9NT0RFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnN0cmljdF9tb2RlKSc7XG5cbmV4cG9ydCBjb25zdCBTVVNQRU5TRV9OVU1CRVIgPSAweGVhZDE7XG5leHBvcnQgY29uc3QgU1VTUEVOU0VfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc3VzcGVuc2UpJztcblxuZXhwb3J0IGNvbnN0IFNVU1BFTlNFX0xJU1RfTlVNQkVSID0gMHhlYWQ4O1xuZXhwb3J0IGNvbnN0IFNVU1BFTlNFX0xJU1RfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc3VzcGVuc2VfbGlzdCknO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/ReactSymbols.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/StyleX/utils.js":
/*!************************************************************!*\
  !*** ../react-devtools-shared/src/backend/StyleX/utils.js ***!
  \************************************************************/
/*! exports provided: getStyleXData, crawlData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStyleXData\", function() { return getStyleXData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"crawlData\", function() { return crawlData; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst cachedStyleNameToValueMap = new Map();\nfunction getStyleXData(data) {\n  const sources = new Set();\n  const resolvedStyles = {};\n  crawlData(data, sources, resolvedStyles);\n  return {\n    sources: Array.from(sources).sort(),\n    resolvedStyles\n  };\n}\nfunction crawlData(data, sources, resolvedStyles) {\n  if (Array.isArray(data)) {\n    data.forEach(entry => {\n      if (Array.isArray(entry)) {\n        crawlData(entry, sources, resolvedStyles);\n      } else {\n        crawlObjectProperties(entry, sources, resolvedStyles);\n      }\n    });\n  } else {\n    crawlObjectProperties(data, sources, resolvedStyles);\n  }\n\n  resolvedStyles = Object.fromEntries(Object.entries(resolvedStyles).sort());\n}\n\nfunction crawlObjectProperties(entry, sources, resolvedStyles) {\n  const keys = Object.keys(entry);\n  keys.forEach(key => {\n    const value = entry[key];\n\n    if (typeof value === 'string') {\n      if (key === value) {\n        // Special case; this key is the name of the style's source/file/module.\n        sources.add(key);\n      } else {\n        resolvedStyles[key] = getPropertyValueForStyleName(value);\n      }\n    } else {\n      const nestedStyle = {};\n      resolvedStyles[key] = nestedStyle;\n      crawlData([value], sources, nestedStyle);\n    }\n  });\n}\n\nfunction getPropertyValueForStyleName(styleName) {\n  if (cachedStyleNameToValueMap.has(styleName)) {\n    return cachedStyleNameToValueMap.get(styleName);\n  }\n\n  for (let styleSheetIndex = 0; styleSheetIndex < document.styleSheets.length; styleSheetIndex++) {\n    const styleSheet = document.styleSheets[styleSheetIndex]; // $FlowFixMe Flow doesn't konw about these properties\n\n    const rules = styleSheet.rules || styleSheet.cssRules;\n\n    for (let ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {\n      const rule = rules[ruleIndex]; // $FlowFixMe Flow doesn't konw about these properties\n\n      const {\n        cssText,\n        selectorText,\n        style\n      } = rule;\n\n      if (selectorText != null) {\n        if (selectorText.startsWith(`.${styleName}`)) {\n          const match = cssText.match(/{ *([a-z\\-]+):/);\n\n          if (match !== null) {\n            const property = match[1];\n            const value = style.getPropertyValue(property);\n            cachedStyleNameToValueMap.set(styleName, value);\n            return value;\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n\n  return null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1N0eWxlWC91dGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvU3R5bGVYL3V0aWxzLmpzPzQ4NjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtTdHlsZVhQbHVnaW59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdHlwZXMnO1xuXG5jb25zdCBjYWNoZWRTdHlsZU5hbWVUb1ZhbHVlTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGVYRGF0YShkYXRhOiBhbnkpOiBTdHlsZVhQbHVnaW4ge1xuICBjb25zdCBzb3VyY2VzID0gbmV3IFNldCgpO1xuICBjb25zdCByZXNvbHZlZFN0eWxlcyA9IHt9O1xuXG4gIGNyYXdsRGF0YShkYXRhLCBzb3VyY2VzLCByZXNvbHZlZFN0eWxlcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzb3VyY2VzOiBBcnJheS5mcm9tKHNvdXJjZXMpLnNvcnQoKSxcbiAgICByZXNvbHZlZFN0eWxlcyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyYXdsRGF0YShcbiAgZGF0YTogYW55LFxuICBzb3VyY2VzOiBTZXQ8c3RyaW5nPixcbiAgcmVzb2x2ZWRTdHlsZXM6IE9iamVjdCxcbik6IHZvaWQge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIGRhdGEuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgY3Jhd2xEYXRhKGVudHJ5LCBzb3VyY2VzLCByZXNvbHZlZFN0eWxlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmF3bE9iamVjdFByb3BlcnRpZXMoZW50cnksIHNvdXJjZXMsIHJlc29sdmVkU3R5bGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjcmF3bE9iamVjdFByb3BlcnRpZXMoZGF0YSwgc291cmNlcywgcmVzb2x2ZWRTdHlsZXMpO1xuICB9XG5cbiAgcmVzb2x2ZWRTdHlsZXMgPSBPYmplY3QuZnJvbUVudHJpZXM8c3RyaW5nLCBhbnk+KFxuICAgIE9iamVjdC5lbnRyaWVzKHJlc29sdmVkU3R5bGVzKS5zb3J0KCksXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNyYXdsT2JqZWN0UHJvcGVydGllcyhcbiAgZW50cnk6IE9iamVjdCxcbiAgc291cmNlczogU2V0PHN0cmluZz4sXG4gIHJlc29sdmVkU3R5bGVzOiBPYmplY3QsXG4pOiB2b2lkIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVudHJ5KTtcbiAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBlbnRyeVtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoa2V5ID09PSB2YWx1ZSkge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2U7IHRoaXMga2V5IGlzIHRoZSBuYW1lIG9mIHRoZSBzdHlsZSdzIHNvdXJjZS9maWxlL21vZHVsZS5cbiAgICAgICAgc291cmNlcy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmVkU3R5bGVzW2tleV0gPSBnZXRQcm9wZXJ0eVZhbHVlRm9yU3R5bGVOYW1lKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmVzdGVkU3R5bGUgPSB7fTtcbiAgICAgIHJlc29sdmVkU3R5bGVzW2tleV0gPSBuZXN0ZWRTdHlsZTtcbiAgICAgIGNyYXdsRGF0YShbdmFsdWVdLCBzb3VyY2VzLCBuZXN0ZWRTdHlsZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZUZvclN0eWxlTmFtZShzdHlsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICBpZiAoY2FjaGVkU3R5bGVOYW1lVG9WYWx1ZU1hcC5oYXMoc3R5bGVOYW1lKSkge1xuICAgIHJldHVybiAoKGNhY2hlZFN0eWxlTmFtZVRvVmFsdWVNYXAuZ2V0KHN0eWxlTmFtZSk6IGFueSk6IHN0cmluZyk7XG4gIH1cblxuICBmb3IgKFxuICAgIGxldCBzdHlsZVNoZWV0SW5kZXggPSAwO1xuICAgIHN0eWxlU2hlZXRJbmRleCA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDtcbiAgICBzdHlsZVNoZWV0SW5kZXgrK1xuICApIHtcbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gKChkb2N1bWVudC5zdHlsZVNoZWV0c1tcbiAgICAgIHN0eWxlU2hlZXRJbmRleFxuICAgIF06IGFueSk6IENTU1N0eWxlU2hlZXQpO1xuICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtvbncgYWJvdXQgdGhlc2UgcHJvcGVydGllc1xuICAgIGNvbnN0IHJ1bGVzID0gc3R5bGVTaGVldC5ydWxlcyB8fCBzdHlsZVNoZWV0LmNzc1J1bGVzO1xuICAgIGZvciAobGV0IHJ1bGVJbmRleCA9IDA7IHJ1bGVJbmRleCA8IHJ1bGVzLmxlbmd0aDsgcnVsZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1tydWxlSW5kZXhdO1xuICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga29udyBhYm91dCB0aGVzZSBwcm9wZXJ0aWVzXG4gICAgICBjb25zdCB7Y3NzVGV4dCwgc2VsZWN0b3JUZXh0LCBzdHlsZX0gPSBydWxlO1xuXG4gICAgICBpZiAoc2VsZWN0b3JUZXh0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yVGV4dC5zdGFydHNXaXRoKGAuJHtzdHlsZU5hbWV9YCkpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IGNzc1RleHQubWF0Y2goL3sgKihbYS16XFwtXSspOi8pO1xuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgIGNhY2hlZFN0eWxlTmFtZVRvVmFsdWVNYXAuc2V0KHN0eWxlTmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7QUFXQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/StyleX/utils.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/console.js":
/*!*******************************************************!*\
  !*** ../react-devtools-shared/src/backend/console.js ***!
  \*******************************************************/
/*! exports provided: isStringComponentStack, dangerous_setTargetConsoleForTesting, registerRenderer, patch, unpatch, patchForStrictMode, unpatchForStrictMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStringComponentStack\", function() { return isStringComponentStack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dangerous_setTargetConsoleForTesting\", function() { return dangerous_setTargetConsoleForTesting; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registerRenderer\", function() { return registerRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"patch\", function() { return patch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unpatch\", function() { return unpatch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"patchForStrictMode\", function() { return patchForStrictMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unpatchForStrictMode\", function() { return unpatchForStrictMode; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"../react-devtools-shared/src/backend/utils.js\");\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderer */ \"../react-devtools-shared/src/backend/renderer.js\");\n/* harmony import */ var _DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DevToolsFiberComponentStack */ \"../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js\");\n/* harmony import */ var react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-devtools-feature-flags */ \"../react-devtools-shared/src/config/DevToolsFeatureFlags.extension-oss.js\");\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\nconst OVERRIDE_CONSOLE_METHODS = ['error', 'trace', 'warn'];\nconst DIMMED_NODE_CONSOLE_COLOR = '\\x1b[2m%s\\x1b[0m'; // React's custom built component stack strings match \"\\s{4}in\"\n// Chrome's prefix matches \"\\s{4}at\"\n\nconst PREFIX_REGEX = /\\s{4}(in|at)\\s{1}/; // Firefox and Safari have no prefix (\"\")\n// but we can fallback to looking for location info (e.g. \"foo.js:12:345\")\n\nconst ROW_COLUMN_NUMBER_REGEX = /:\\d+:\\d+(\\n|$)/;\nfunction isStringComponentStack(text) {\n  return PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);\n}\nconst STYLE_DIRECTIVE_REGEX = /^%c/; // This function tells whether or not the arguments for a console\n// method has been overridden by the patchForStrictMode function.\n// If it has we'll need to do some special formatting of the arguments\n// so the console color stays consistent\n\nfunction isStrictModeOverride(args, method) {\n  return args.length === 2 && STYLE_DIRECTIVE_REGEX.test(args[0]) && args[1] === `color: ${getConsoleColor(method) || ''}`;\n}\n\nfunction getConsoleColor(method) {\n  switch (method) {\n    case 'warn':\n      return consoleSettingsRef.browserTheme === 'light' ? \"rgba(250, 180, 50, 0.75)\" : \"rgba(250, 180, 50, 0.5)\";\n\n    case 'error':\n      return consoleSettingsRef.browserTheme === 'light' ? \"rgba(250, 123, 130, 0.75)\" : \"rgba(250, 123, 130, 0.5)\";\n\n    case 'log':\n    default:\n      return consoleSettingsRef.browserTheme === 'light' ? \"rgba(125, 125, 125, 0.75)\" : \"rgba(125, 125, 125, 0.5)\";\n  }\n}\n\nconst injectedRenderers = new Map();\nlet targetConsole = console;\nlet targetConsoleMethods = {};\n\nfor (const method in console) {\n  targetConsoleMethods[method] = console[method];\n}\n\nlet unpatchFn = null;\nlet isNode = false;\n\ntry {\n  isNode = undefined === global;\n} catch (error) {} // Enables e.g. Jest tests to inject a mock console object.\n\n\nfunction dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {\n  targetConsole = targetConsoleForTesting;\n  targetConsoleMethods = {};\n\n  for (const method in targetConsole) {\n    targetConsoleMethods[method] = console[method];\n  }\n} // v16 renderers should use this method to inject internals necessary to generate a component stack.\n// These internals will be used if the console is patched.\n// Injecting them separately allows the console to easily be patched or un-patched later (at runtime).\n\nfunction registerRenderer(renderer, onErrorOrWarning) {\n  const {\n    currentDispatcherRef,\n    getCurrentFiber,\n    findFiberByHostInstance,\n    version\n  } = renderer; // Ignore React v15 and older because they don't expose a component stack anyway.\n\n  if (typeof findFiberByHostInstance !== 'function') {\n    return;\n  } // currentDispatcherRef gets injected for v16.8+ to support hooks inspection.\n  // getCurrentFiber gets injected for v16.9+.\n\n\n  if (currentDispatcherRef != null && typeof getCurrentFiber === 'function') {\n    const {\n      ReactTypeOfWork\n    } = Object(_renderer__WEBPACK_IMPORTED_MODULE_1__[\"getInternalReactConstants\"])(version);\n    injectedRenderers.set(renderer, {\n      currentDispatcherRef,\n      getCurrentFiber,\n      workTagMap: ReactTypeOfWork,\n      onErrorOrWarning\n    });\n  }\n}\nconst consoleSettingsRef = {\n  appendComponentStack: false,\n  breakOnConsoleErrors: false,\n  showInlineWarningsAndErrors: false,\n  hideConsoleLogsInStrictMode: false,\n  browserTheme: 'dark'\n}; // Patches console methods to append component stack for the current fiber.\n// Call unpatch() to remove the injected behavior.\n\nfunction patch({\n  appendComponentStack,\n  breakOnConsoleErrors,\n  showInlineWarningsAndErrors,\n  hideConsoleLogsInStrictMode,\n  browserTheme\n}) {\n  // Settings may change after we've patched the console.\n  // Using a shared ref allows the patch function to read the latest values.\n  consoleSettingsRef.appendComponentStack = appendComponentStack;\n  consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;\n  consoleSettingsRef.showInlineWarningsAndErrors = showInlineWarningsAndErrors;\n  consoleSettingsRef.hideConsoleLogsInStrictMode = hideConsoleLogsInStrictMode;\n  consoleSettingsRef.browserTheme = browserTheme;\n\n  if (appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {\n    if (unpatchFn !== null) {\n      // Don't patch twice.\n      return;\n    }\n\n    const originalConsoleMethods = {};\n\n    unpatchFn = () => {\n      for (const method in originalConsoleMethods) {\n        try {\n          // $FlowFixMe property error|warn is not writable.\n          targetConsole[method] = originalConsoleMethods[method];\n        } catch (error) {}\n      }\n    };\n\n    OVERRIDE_CONSOLE_METHODS.forEach(method => {\n      try {\n        const originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ : targetConsole[method];\n\n        const overrideMethod = (...args) => {\n          let shouldAppendWarningStack = false;\n\n          if (method !== 'log') {\n            if (consoleSettingsRef.appendComponentStack) {\n              const lastArg = args.length > 0 ? args[args.length - 1] : null;\n              const alreadyHasComponentStack = typeof lastArg === 'string' && isStringComponentStack(lastArg); // If we are ever called with a string that already has a component stack,\n              // e.g. a React error/warning, don't append a second stack.\n\n              shouldAppendWarningStack = !alreadyHasComponentStack;\n            }\n          }\n\n          const shouldShowInlineWarningsAndErrors = consoleSettingsRef.showInlineWarningsAndErrors && (method === 'error' || method === 'warn'); // Search for the first renderer that has a current Fiber.\n          // We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)\n          // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n          for (const {\n            currentDispatcherRef,\n            getCurrentFiber,\n            onErrorOrWarning,\n            workTagMap\n          } of injectedRenderers.values()) {\n            const current = getCurrentFiber();\n\n            if (current != null) {\n              try {\n                if (shouldShowInlineWarningsAndErrors) {\n                  // patch() is called by two places: (1) the hook and (2) the renderer backend.\n                  // The backend is what implements a message queue, so it's the only one that injects onErrorOrWarning.\n                  if (typeof onErrorOrWarning === 'function') {\n                    onErrorOrWarning(current, method, // Copy args before we mutate them (e.g. adding the component stack)\n                    args.slice());\n                  }\n                }\n\n                if (shouldAppendWarningStack) {\n                  const componentStack = Object(_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__[\"getStackByFiberInDevAndProd\"])(workTagMap, current, currentDispatcherRef);\n\n                  if (componentStack !== '') {\n                    if (isStrictModeOverride(args, method)) {\n                      args[0] = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"format\"])(args[0], componentStack);\n                    } else {\n                      args.push(componentStack);\n                    }\n                  }\n                }\n              } catch (error) {\n                // Don't let a DevTools or React internal error interfere with logging.\n                setTimeout(() => {\n                  throw error;\n                }, 0);\n              } finally {\n                break;\n              }\n            }\n          }\n\n          if (consoleSettingsRef.breakOnConsoleErrors) {\n            // --- Welcome to debugging with React DevTools ---\n            // This debugger statement means that you've enabled the \"break on warnings\" feature.\n            // Use the browser's Call Stack panel to step out of this override function-\n            // to where the original warning or error was logged.\n            // eslint-disable-next-line no-debugger\n            debugger;\n          }\n\n          originalMethod(...args);\n        };\n\n        overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod;\n        originalMethod.__REACT_DEVTOOLS_OVERRIDE_METHOD__ = overrideMethod; // $FlowFixMe property error|warn is not writable.\n\n        targetConsole[method] = overrideMethod;\n      } catch (error) {}\n    });\n  } else {\n    unpatch();\n  }\n} // Removed component stack patch from console methods.\n\nfunction unpatch() {\n  if (unpatchFn !== null) {\n    unpatchFn();\n    unpatchFn = null;\n  }\n}\nlet unpatchForStrictModeFn = null; // NOTE: KEEP IN SYNC with src/hook.js:patchConsoleForInitialRenderInStrictMode\n\nfunction patchForStrictMode() {\n  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__[\"consoleManagedByDevToolsDuringStrictMode\"]) {\n    const overrideConsoleMethods = ['error', 'trace', 'warn', 'log'];\n\n    if (unpatchForStrictModeFn !== null) {\n      // Don't patch twice.\n      return;\n    }\n\n    const originalConsoleMethods = {};\n\n    unpatchForStrictModeFn = () => {\n      for (const method in originalConsoleMethods) {\n        try {\n          // $FlowFixMe property error|warn is not writable.\n          targetConsole[method] = originalConsoleMethods[method];\n        } catch (error) {}\n      }\n    };\n\n    overrideConsoleMethods.forEach(method => {\n      try {\n        const originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method];\n\n        const overrideMethod = (...args) => {\n          if (!consoleSettingsRef.hideConsoleLogsInStrictMode) {\n            // Dim the text color of the double logs if we're not\n            // hiding them.\n            if (isNode) {\n              originalMethod(DIMMED_NODE_CONSOLE_COLOR, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"format\"])(...args));\n            } else {\n              const color = getConsoleColor(method);\n\n              if (color) {\n                originalMethod(`%c${Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"format\"])(...args)}`, `color: ${color}`);\n              } else {\n                throw Error('Console color is not defined');\n              }\n            }\n          }\n        };\n\n        overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;\n        originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod; // $FlowFixMe property error|warn is not writable.\n\n        targetConsole[method] = overrideMethod;\n      } catch (error) {}\n    });\n  }\n} // NOTE: KEEP IN SYNC with src/hook.js:unpatchConsoleForInitialRenderInStrictMode\n\nfunction unpatchForStrictMode() {\n  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__[\"consoleManagedByDevToolsDuringStrictMode\"]) {\n    if (unpatchForStrictModeFn !== null) {\n      unpatchForStrictModeFn();\n      unpatchForStrictModeFn = null;\n    }\n  }\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2NvbnNvbGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2NvbnNvbGUuanM/YWU5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEludGVybmFsVHlwZXMnO1xuaW1wb3J0IHR5cGUge0N1cnJlbnREaXNwYXRjaGVyUmVmLCBSZWFjdFJlbmRlcmVyLCBXb3JrVGFnTWFwfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB0eXBlIHtCcm93c2VyVGhlbWV9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvdmlld3MvRGV2VG9vbHMnO1xuaW1wb3J0IHtmb3JtYXR9IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQge2dldEludGVybmFsUmVhY3RDb25zdGFudHN9IGZyb20gJy4vcmVuZGVyZXInO1xuaW1wb3J0IHtnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2R9IGZyb20gJy4vRGV2VG9vbHNGaWJlckNvbXBvbmVudFN0YWNrJztcbmltcG9ydCB7Y29uc29sZU1hbmFnZWRCeURldlRvb2xzRHVyaW5nU3RyaWN0TW9kZX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtZmVhdHVyZS1mbGFncyc7XG5cbmNvbnN0IE9WRVJSSURFX0NPTlNPTEVfTUVUSE9EUyA9IFsnZXJyb3InLCAndHJhY2UnLCAnd2FybiddO1xuY29uc3QgRElNTUVEX05PREVfQ09OU09MRV9DT0xPUiA9ICdcXHgxYlsybSVzXFx4MWJbMG0nO1xuXG4vLyBSZWFjdCdzIGN1c3RvbSBidWlsdCBjb21wb25lbnQgc3RhY2sgc3RyaW5ncyBtYXRjaCBcIlxcc3s0fWluXCJcbi8vIENocm9tZSdzIHByZWZpeCBtYXRjaGVzIFwiXFxzezR9YXRcIlxuY29uc3QgUFJFRklYX1JFR0VYID0gL1xcc3s0fShpbnxhdClcXHN7MX0vO1xuLy8gRmlyZWZveCBhbmQgU2FmYXJpIGhhdmUgbm8gcHJlZml4IChcIlwiKVxuLy8gYnV0IHdlIGNhbiBmYWxsYmFjayB0byBsb29raW5nIGZvciBsb2NhdGlvbiBpbmZvIChlLmcuIFwiZm9vLmpzOjEyOjM0NVwiKVxuY29uc3QgUk9XX0NPTFVNTl9OVU1CRVJfUkVHRVggPSAvOlxcZCs6XFxkKyhcXG58JCkvO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdDb21wb25lbnRTdGFjayh0ZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFBSRUZJWF9SRUdFWC50ZXN0KHRleHQpIHx8IFJPV19DT0xVTU5fTlVNQkVSX1JFR0VYLnRlc3QodGV4dCk7XG59XG5cbmNvbnN0IFNUWUxFX0RJUkVDVElWRV9SRUdFWCA9IC9eJWMvO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHRlbGxzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgZm9yIGEgY29uc29sZVxuLy8gbWV0aG9kIGhhcyBiZWVuIG92ZXJyaWRkZW4gYnkgdGhlIHBhdGNoRm9yU3RyaWN0TW9kZSBmdW5jdGlvbi5cbi8vIElmIGl0IGhhcyB3ZSdsbCBuZWVkIHRvIGRvIHNvbWUgc3BlY2lhbCBmb3JtYXR0aW5nIG9mIHRoZSBhcmd1bWVudHNcbi8vIHNvIHRoZSBjb25zb2xlIGNvbG9yIHN0YXlzIGNvbnNpc3RlbnRcbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZU92ZXJyaWRlKGFyZ3M6IEFycmF5PHN0cmluZz4sIG1ldGhvZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgYXJncy5sZW5ndGggPT09IDIgJiZcbiAgICBTVFlMRV9ESVJFQ1RJVkVfUkVHRVgudGVzdChhcmdzWzBdKSAmJlxuICAgIGFyZ3NbMV0gPT09IGBjb2xvcjogJHtnZXRDb25zb2xlQ29sb3IobWV0aG9kKSB8fCAnJ31gXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnNvbGVDb2xvcihtZXRob2Q6IHN0cmluZyk6ID9zdHJpbmcge1xuICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgIGNhc2UgJ3dhcm4nOlxuICAgICAgcmV0dXJuIGNvbnNvbGVTZXR0aW5nc1JlZi5icm93c2VyVGhlbWUgPT09ICdsaWdodCdcbiAgICAgICAgPyBwcm9jZXNzLmVudi5MSUdIVF9NT0RFX0RJTU1FRF9XQVJOSU5HX0NPTE9SXG4gICAgICAgIDogcHJvY2Vzcy5lbnYuREFSS19NT0RFX0RJTU1FRF9XQVJOSU5HX0NPTE9SO1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIHJldHVybiBjb25zb2xlU2V0dGluZ3NSZWYuYnJvd3NlclRoZW1lID09PSAnbGlnaHQnXG4gICAgICAgID8gcHJvY2Vzcy5lbnYuTElHSFRfTU9ERV9ESU1NRURfRVJST1JfQ09MT1JcbiAgICAgICAgOiBwcm9jZXNzLmVudi5EQVJLX01PREVfRElNTUVEX0VSUk9SX0NPTE9SO1xuICAgIGNhc2UgJ2xvZyc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb25zb2xlU2V0dGluZ3NSZWYuYnJvd3NlclRoZW1lID09PSAnbGlnaHQnXG4gICAgICAgID8gcHJvY2Vzcy5lbnYuTElHSFRfTU9ERV9ESU1NRURfTE9HX0NPTE9SXG4gICAgICAgIDogcHJvY2Vzcy5lbnYuREFSS19NT0RFX0RJTU1FRF9MT0dfQ09MT1I7XG4gIH1cbn1cbnR5cGUgT25FcnJvck9yV2FybmluZyA9IChcbiAgZmliZXI6IEZpYmVyLFxuICB0eXBlOiAnZXJyb3InIHwgJ3dhcm4nLFxuICBhcmdzOiBBcnJheTxhbnk+LFxuKSA9PiB2b2lkO1xuXG5jb25zdCBpbmplY3RlZFJlbmRlcmVyczogTWFwPFxuICBSZWFjdFJlbmRlcmVyLFxuICB7fFxuICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBDdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICBnZXRDdXJyZW50RmliZXI6ICgpID0+IEZpYmVyIHwgbnVsbCxcbiAgICBvbkVycm9yT3JXYXJuaW5nOiA/T25FcnJvck9yV2FybmluZyxcbiAgICB3b3JrVGFnTWFwOiBXb3JrVGFnTWFwLFxuICB8fSxcbj4gPSBuZXcgTWFwKCk7XG5cbmxldCB0YXJnZXRDb25zb2xlOiBPYmplY3QgPSBjb25zb2xlO1xubGV0IHRhcmdldENvbnNvbGVNZXRob2RzID0ge307XG5mb3IgKGNvbnN0IG1ldGhvZCBpbiBjb25zb2xlKSB7XG4gIHRhcmdldENvbnNvbGVNZXRob2RzW21ldGhvZF0gPSBjb25zb2xlW21ldGhvZF07XG59XG5cbmxldCB1bnBhdGNoRm46IG51bGwgfCAoKCkgPT4gdm9pZCkgPSBudWxsO1xuXG5sZXQgaXNOb2RlID0gZmFsc2U7XG50cnkge1xuICBpc05vZGUgPSB0aGlzID09PSBnbG9iYWw7XG59IGNhdGNoIChlcnJvcikge31cblxuLy8gRW5hYmxlcyBlLmcuIEplc3QgdGVzdHMgdG8gaW5qZWN0IGEgbW9jayBjb25zb2xlIG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBkYW5nZXJvdXNfc2V0VGFyZ2V0Q29uc29sZUZvclRlc3RpbmcoXG4gIHRhcmdldENvbnNvbGVGb3JUZXN0aW5nOiBPYmplY3QsXG4pOiB2b2lkIHtcbiAgdGFyZ2V0Q29uc29sZSA9IHRhcmdldENvbnNvbGVGb3JUZXN0aW5nO1xuXG4gIHRhcmdldENvbnNvbGVNZXRob2RzID0ge307XG4gIGZvciAoY29uc3QgbWV0aG9kIGluIHRhcmdldENvbnNvbGUpIHtcbiAgICB0YXJnZXRDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gY29uc29sZVttZXRob2RdO1xuICB9XG59XG5cbi8vIHYxNiByZW5kZXJlcnMgc2hvdWxkIHVzZSB0aGlzIG1ldGhvZCB0byBpbmplY3QgaW50ZXJuYWxzIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSBhIGNvbXBvbmVudCBzdGFjay5cbi8vIFRoZXNlIGludGVybmFscyB3aWxsIGJlIHVzZWQgaWYgdGhlIGNvbnNvbGUgaXMgcGF0Y2hlZC5cbi8vIEluamVjdGluZyB0aGVtIHNlcGFyYXRlbHkgYWxsb3dzIHRoZSBjb25zb2xlIHRvIGVhc2lseSBiZSBwYXRjaGVkIG9yIHVuLXBhdGNoZWQgbGF0ZXIgKGF0IHJ1bnRpbWUpLlxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUmVuZGVyZXIoXG4gIHJlbmRlcmVyOiBSZWFjdFJlbmRlcmVyLFxuICBvbkVycm9yT3JXYXJuaW5nPzogT25FcnJvck9yV2FybmluZyxcbik6IHZvaWQge1xuICBjb25zdCB7XG4gICAgY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgZ2V0Q3VycmVudEZpYmVyLFxuICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlLFxuICAgIHZlcnNpb24sXG4gIH0gPSByZW5kZXJlcjtcblxuICAvLyBJZ25vcmUgUmVhY3QgdjE1IGFuZCBvbGRlciBiZWNhdXNlIHRoZXkgZG9uJ3QgZXhwb3NlIGEgY29tcG9uZW50IHN0YWNrIGFueXdheS5cbiAgaWYgKHR5cGVvZiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGN1cnJlbnREaXNwYXRjaGVyUmVmIGdldHMgaW5qZWN0ZWQgZm9yIHYxNi44KyB0byBzdXBwb3J0IGhvb2tzIGluc3BlY3Rpb24uXG4gIC8vIGdldEN1cnJlbnRGaWJlciBnZXRzIGluamVjdGVkIGZvciB2MTYuOSsuXG4gIGlmIChjdXJyZW50RGlzcGF0Y2hlclJlZiAhPSBudWxsICYmIHR5cGVvZiBnZXRDdXJyZW50RmliZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB7UmVhY3RUeXBlT2ZXb3JrfSA9IGdldEludGVybmFsUmVhY3RDb25zdGFudHModmVyc2lvbik7XG5cbiAgICBpbmplY3RlZFJlbmRlcmVycy5zZXQocmVuZGVyZXIsIHtcbiAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmLFxuICAgICAgZ2V0Q3VycmVudEZpYmVyLFxuICAgICAgd29ya1RhZ01hcDogUmVhY3RUeXBlT2ZXb3JrLFxuICAgICAgb25FcnJvck9yV2FybmluZyxcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBjb25zb2xlU2V0dGluZ3NSZWYgPSB7XG4gIGFwcGVuZENvbXBvbmVudFN0YWNrOiBmYWxzZSxcbiAgYnJlYWtPbkNvbnNvbGVFcnJvcnM6IGZhbHNlLFxuICBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnM6IGZhbHNlLFxuICBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGU6IGZhbHNlLFxuICBicm93c2VyVGhlbWU6ICdkYXJrJyxcbn07XG5cbi8vIFBhdGNoZXMgY29uc29sZSBtZXRob2RzIHRvIGFwcGVuZCBjb21wb25lbnQgc3RhY2sgZm9yIHRoZSBjdXJyZW50IGZpYmVyLlxuLy8gQ2FsbCB1bnBhdGNoKCkgdG8gcmVtb3ZlIHRoZSBpbmplY3RlZCBiZWhhdmlvci5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaCh7XG4gIGFwcGVuZENvbXBvbmVudFN0YWNrLFxuICBicmVha09uQ29uc29sZUVycm9ycyxcbiAgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzLFxuICBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUsXG4gIGJyb3dzZXJUaGVtZSxcbn06IHtcbiAgYXBwZW5kQ29tcG9uZW50U3RhY2s6IGJvb2xlYW4sXG4gIGJyZWFrT25Db25zb2xlRXJyb3JzOiBib29sZWFuLFxuICBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnM6IGJvb2xlYW4sXG4gIGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZTogYm9vbGVhbixcbiAgYnJvd3NlclRoZW1lOiBCcm93c2VyVGhlbWUsXG59KTogdm9pZCB7XG4gIC8vIFNldHRpbmdzIG1heSBjaGFuZ2UgYWZ0ZXIgd2UndmUgcGF0Y2hlZCB0aGUgY29uc29sZS5cbiAgLy8gVXNpbmcgYSBzaGFyZWQgcmVmIGFsbG93cyB0aGUgcGF0Y2ggZnVuY3Rpb24gdG8gcmVhZCB0aGUgbGF0ZXN0IHZhbHVlcy5cbiAgY29uc29sZVNldHRpbmdzUmVmLmFwcGVuZENvbXBvbmVudFN0YWNrID0gYXBwZW5kQ29tcG9uZW50U3RhY2s7XG4gIGNvbnNvbGVTZXR0aW5nc1JlZi5icmVha09uQ29uc29sZUVycm9ycyA9IGJyZWFrT25Db25zb2xlRXJyb3JzO1xuICBjb25zb2xlU2V0dGluZ3NSZWYuc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzID0gc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzO1xuICBjb25zb2xlU2V0dGluZ3NSZWYuaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlID0gaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlO1xuICBjb25zb2xlU2V0dGluZ3NSZWYuYnJvd3NlclRoZW1lID0gYnJvd3NlclRoZW1lO1xuXG4gIGlmIChcbiAgICBhcHBlbmRDb21wb25lbnRTdGFjayB8fFxuICAgIGJyZWFrT25Db25zb2xlRXJyb3JzIHx8XG4gICAgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzXG4gICkge1xuICAgIGlmICh1bnBhdGNoRm4gIT09IG51bGwpIHtcbiAgICAgIC8vIERvbid0IHBhdGNoIHR3aWNlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsQ29uc29sZU1ldGhvZHMgPSB7fTtcblxuICAgIHVucGF0Y2hGbiA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbWV0aG9kIGluIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIHByb3BlcnR5IGVycm9yfHdhcm4gaXMgbm90IHdyaXRhYmxlLlxuICAgICAgICAgIHRhcmdldENvbnNvbGVbbWV0aG9kXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICB9XG4gICAgfTtcblxuICAgIE9WRVJSSURFX0NPTlNPTEVfTUVUSE9EUy5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IChvcmlnaW5hbENvbnNvbGVNZXRob2RzW21ldGhvZF0gPSB0YXJnZXRDb25zb2xlW1xuICAgICAgICAgIG1ldGhvZFxuICAgICAgICBdLl9fUkVBQ1RfREVWVE9PTFNfT1JJR0lOQUxfTUVUSE9EX19cbiAgICAgICAgICA/IHRhcmdldENvbnNvbGVbbWV0aG9kXS5fX1JFQUNUX0RFVlRPT0xTX09SSUdJTkFMX01FVEhPRF9fXG4gICAgICAgICAgOiB0YXJnZXRDb25zb2xlW21ldGhvZF0pO1xuXG4gICAgICAgIGNvbnN0IG92ZXJyaWRlTWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBsZXQgc2hvdWxkQXBwZW5kV2FybmluZ1N0YWNrID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ2xvZycpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlU2V0dGluZ3NSZWYuYXBwZW5kQ29tcG9uZW50U3RhY2spIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdEFyZyA9IGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbYXJncy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlIYXNDb21wb25lbnRTdGFjayA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGxhc3RBcmcgPT09ICdzdHJpbmcnICYmIGlzU3RyaW5nQ29tcG9uZW50U3RhY2sobGFzdEFyZyk7XG5cbiAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGV2ZXIgY2FsbGVkIHdpdGggYSBzdHJpbmcgdGhhdCBhbHJlYWR5IGhhcyBhIGNvbXBvbmVudCBzdGFjayxcbiAgICAgICAgICAgICAgLy8gZS5nLiBhIFJlYWN0IGVycm9yL3dhcm5pbmcsIGRvbid0IGFwcGVuZCBhIHNlY29uZCBzdGFjay5cbiAgICAgICAgICAgICAgc2hvdWxkQXBwZW5kV2FybmluZ1N0YWNrID0gIWFscmVhZHlIYXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzaG91bGRTaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMgPVxuICAgICAgICAgICAgY29uc29sZVNldHRpbmdzUmVmLnNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyAmJlxuICAgICAgICAgICAgKG1ldGhvZCA9PT0gJ2Vycm9yJyB8fCBtZXRob2QgPT09ICd3YXJuJyk7XG5cbiAgICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSBmaXJzdCByZW5kZXJlciB0aGF0IGhhcyBhIGN1cnJlbnQgRmliZXIuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgaGFuZGxlIHRoZSBlZGdlIGNhc2Ugb2Ygc3RhY2tzIGZvciBtb3JlIHRoYW4gb25lIChlLmcuIGludGVybGVhdmVkIHJlbmRlcmVycz8pXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmLFxuICAgICAgICAgICAgZ2V0Q3VycmVudEZpYmVyLFxuICAgICAgICAgICAgb25FcnJvck9yV2FybmluZyxcbiAgICAgICAgICAgIHdvcmtUYWdNYXAsXG4gICAgICAgICAgfSBvZiBpbmplY3RlZFJlbmRlcmVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudDogP0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgLy8gcGF0Y2goKSBpcyBjYWxsZWQgYnkgdHdvIHBsYWNlczogKDEpIHRoZSBob29rIGFuZCAoMikgdGhlIHJlbmRlcmVyIGJhY2tlbmQuXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYmFja2VuZCBpcyB3aGF0IGltcGxlbWVudHMgYSBtZXNzYWdlIHF1ZXVlLCBzbyBpdCdzIHRoZSBvbmx5IG9uZSB0aGF0IGluamVjdHMgb25FcnJvck9yV2FybmluZy5cbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvck9yV2FybmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yT3JXYXJuaW5nKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgKChtZXRob2Q6IGFueSk6ICdlcnJvcicgfCAnd2FybicpLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgYXJncyBiZWZvcmUgd2UgbXV0YXRlIHRoZW0gKGUuZy4gYWRkaW5nIHRoZSBjb21wb25lbnQgc3RhY2spXG4gICAgICAgICAgICAgICAgICAgICAgYXJncy5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRBcHBlbmRXYXJuaW5nU3RhY2spIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFN0YWNrID0gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKFxuICAgICAgICAgICAgICAgICAgICB3b3JrVGFnTWFwLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50U3RhY2sgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmljdE1vZGVPdmVycmlkZShhcmdzLCBtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IGZvcm1hdChhcmdzWzBdLCBjb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBsZXQgYSBEZXZUb29scyBvciBSZWFjdCBpbnRlcm5hbCBlcnJvciBpbnRlcmZlcmUgd2l0aCBsb2dnaW5nLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29uc29sZVNldHRpbmdzUmVmLmJyZWFrT25Db25zb2xlRXJyb3JzKSB7XG4gICAgICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgd2l0aCBSZWFjdCBEZXZUb29scyAtLS1cbiAgICAgICAgICAgIC8vIFRoaXMgZGVidWdnZXIgc3RhdGVtZW50IG1lYW5zIHRoYXQgeW91J3ZlIGVuYWJsZWQgdGhlIFwiYnJlYWsgb24gd2FybmluZ3NcIiBmZWF0dXJlLlxuICAgICAgICAgICAgLy8gVXNlIHRoZSBicm93c2VyJ3MgQ2FsbCBTdGFjayBwYW5lbCB0byBzdGVwIG91dCBvZiB0aGlzIG92ZXJyaWRlIGZ1bmN0aW9uLVxuICAgICAgICAgICAgLy8gdG8gd2hlcmUgdGhlIG9yaWdpbmFsIHdhcm5pbmcgb3IgZXJyb3Igd2FzIGxvZ2dlZC5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3JpZ2luYWxNZXRob2QoLi4uYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3ZlcnJpZGVNZXRob2QuX19SRUFDVF9ERVZUT09MU19PUklHSU5BTF9NRVRIT0RfXyA9IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgICBvcmlnaW5hbE1ldGhvZC5fX1JFQUNUX0RFVlRPT0xTX09WRVJSSURFX01FVEhPRF9fID0gb3ZlcnJpZGVNZXRob2Q7XG5cbiAgICAgICAgLy8gJEZsb3dGaXhNZSBwcm9wZXJ0eSBlcnJvcnx3YXJuIGlzIG5vdCB3cml0YWJsZS5cbiAgICAgICAgdGFyZ2V0Q29uc29sZVttZXRob2RdID0gb3ZlcnJpZGVNZXRob2Q7XG4gICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB1bnBhdGNoKCk7XG4gIH1cbn1cblxuLy8gUmVtb3ZlZCBjb21wb25lbnQgc3RhY2sgcGF0Y2ggZnJvbSBjb25zb2xlIG1ldGhvZHMuXG5leHBvcnQgZnVuY3Rpb24gdW5wYXRjaCgpOiB2b2lkIHtcbiAgaWYgKHVucGF0Y2hGbiAhPT0gbnVsbCkge1xuICAgIHVucGF0Y2hGbigpO1xuICAgIHVucGF0Y2hGbiA9IG51bGw7XG4gIH1cbn1cblxubGV0IHVucGF0Y2hGb3JTdHJpY3RNb2RlRm46IG51bGwgfCAoKCkgPT4gdm9pZCkgPSBudWxsO1xuXG4vLyBOT1RFOiBLRUVQIElOIFNZTkMgd2l0aCBzcmMvaG9vay5qczpwYXRjaENvbnNvbGVGb3JJbml0aWFsUmVuZGVySW5TdHJpY3RNb2RlXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hGb3JTdHJpY3RNb2RlKCkge1xuICBpZiAoY29uc29sZU1hbmFnZWRCeURldlRvb2xzRHVyaW5nU3RyaWN0TW9kZSkge1xuICAgIGNvbnN0IG92ZXJyaWRlQ29uc29sZU1ldGhvZHMgPSBbJ2Vycm9yJywgJ3RyYWNlJywgJ3dhcm4nLCAnbG9nJ107XG5cbiAgICBpZiAodW5wYXRjaEZvclN0cmljdE1vZGVGbiAhPT0gbnVsbCkge1xuICAgICAgLy8gRG9uJ3QgcGF0Y2ggdHdpY2UuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxDb25zb2xlTWV0aG9kcyA9IHt9O1xuXG4gICAgdW5wYXRjaEZvclN0cmljdE1vZGVGbiA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbWV0aG9kIGluIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIHByb3BlcnR5IGVycm9yfHdhcm4gaXMgbm90IHdyaXRhYmxlLlxuICAgICAgICAgIHRhcmdldENvbnNvbGVbbWV0aG9kXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICB9XG4gICAgfTtcblxuICAgIG92ZXJyaWRlQ29uc29sZU1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSAob3JpZ2luYWxDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gdGFyZ2V0Q29uc29sZVtcbiAgICAgICAgICBtZXRob2RcbiAgICAgICAgXS5fX1JFQUNUX0RFVlRPT0xTX1NUUklDVF9NT0RFX09SSUdJTkFMX01FVEhPRF9fXG4gICAgICAgICAgPyB0YXJnZXRDb25zb2xlW21ldGhvZF0uX19SRUFDVF9ERVZUT09MU19TVFJJQ1RfTU9ERV9PUklHSU5BTF9NRVRIT0RfX1xuICAgICAgICAgIDogdGFyZ2V0Q29uc29sZVttZXRob2RdKTtcblxuICAgICAgICBjb25zdCBvdmVycmlkZU1ldGhvZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKCFjb25zb2xlU2V0dGluZ3NSZWYuaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAvLyBEaW0gdGhlIHRleHQgY29sb3Igb2YgdGhlIGRvdWJsZSBsb2dzIGlmIHdlJ3JlIG5vdFxuICAgICAgICAgICAgLy8gaGlkaW5nIHRoZW0uXG4gICAgICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kKERJTU1FRF9OT0RFX0NPTlNPTEVfQ09MT1IsIGZvcm1hdCguLi5hcmdzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGdldENvbnNvbGVDb2xvcihtZXRob2QpO1xuICAgICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1ldGhvZChgJWMke2Zvcm1hdCguLi5hcmdzKX1gLCBgY29sb3I6ICR7Y29sb3J9YCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NvbnNvbGUgY29sb3IgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvdmVycmlkZU1ldGhvZC5fX1JFQUNUX0RFVlRPT0xTX1NUUklDVF9NT0RFX09SSUdJTkFMX01FVEhPRF9fID0gb3JpZ2luYWxNZXRob2Q7XG4gICAgICAgIG9yaWdpbmFsTWV0aG9kLl9fUkVBQ1RfREVWVE9PTFNfU1RSSUNUX01PREVfT1ZFUlJJREVfTUVUSE9EX18gPSBvdmVycmlkZU1ldGhvZDtcblxuICAgICAgICAvLyAkRmxvd0ZpeE1lIHByb3BlcnR5IGVycm9yfHdhcm4gaXMgbm90IHdyaXRhYmxlLlxuICAgICAgICB0YXJnZXRDb25zb2xlW21ldGhvZF0gPSBvdmVycmlkZU1ldGhvZDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIH0pO1xuICB9XG59XG5cbi8vIE5PVEU6IEtFRVAgSU4gU1lOQyB3aXRoIHNyYy9ob29rLmpzOnVucGF0Y2hDb25zb2xlRm9ySW5pdGlhbFJlbmRlckluU3RyaWN0TW9kZVxuZXhwb3J0IGZ1bmN0aW9uIHVucGF0Y2hGb3JTdHJpY3RNb2RlKCk6IHZvaWQge1xuICBpZiAoY29uc29sZU1hbmFnZWRCeURldlRvb2xzRHVyaW5nU3RyaWN0TW9kZSkge1xuICAgIGlmICh1bnBhdGNoRm9yU3RyaWN0TW9kZUZuICE9PSBudWxsKSB7XG4gICAgICB1bnBhdGNoRm9yU3RyaWN0TW9kZUZuKCk7XG4gICAgICB1bnBhdGNoRm9yU3RyaWN0TW9kZUZuID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVhBO0FBZUE7QUFDQTtBQU1BO0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/console.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/renderer.js":
/*!********************************************************!*\
  !*** ../react-devtools-shared/src/backend/renderer.js ***!
  \********************************************************/
/*! exports provided: getInternalReactConstants, attach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getInternalReactConstants\", function() { return getInternalReactConstants; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attach\", function() { return attach; });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"../react-devtools-shared/node_modules/semver/semver.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/types */ \"../react-devtools-shared/src/types.js\");\n/* harmony import */ var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\n/* harmony import */ var react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-devtools-shared/src/storage */ \"../react-devtools-shared/src/storage.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"../react-devtools-shared/src/backend/utils.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var react_debug_tools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-debug-tools */ \"../../build/oss-experimental/react-debug-tools/index.js\");\n/* harmony import */ var react_debug_tools__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_debug_tools__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./console */ \"../react-devtools-shared/src/backend/console.js\");\n/* harmony import */ var _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ReactSymbols */ \"../react-devtools-shared/src/backend/ReactSymbols.js\");\n/* harmony import */ var react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-devtools-feature-flags */ \"../react-devtools-shared/src/config/DevToolsFeatureFlags.extension-oss.js\");\n/* harmony import */ var shared_objectIs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! shared/objectIs */ \"../shared/objectIs.js\");\n/* harmony import */ var shared_isArray__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! shared/isArray */ \"../shared/isArray.js\");\n/* harmony import */ var shared_hasOwnProperty__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! shared/hasOwnProperty */ \"../shared/hasOwnProperty.js\");\n/* harmony import */ var _StyleX_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./StyleX/utils */ \"../react-devtools-shared/src/backend/StyleX/utils.js\");\n/* harmony import */ var react_reconciler_src_ReactWorkTags__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! react-reconciler/src/ReactWorkTags */ \"../react-reconciler/src/ReactWorkTags.js\");\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getFiberFlags(fiber) {\n  // The name of this field changed from \"effectTag\" to \"flags\"\n  return fiber.flags !== undefined ? fiber.flags : fiber.effectTag;\n} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\n\nconst getCurrentTime = typeof performance === 'object' && typeof performance.now === 'function' ? () => performance.now() : () => Date.now();\nfunction getInternalReactConstants(version) {\n  const ReactTypeOfSideEffect = {\n    DidCapture: 0b10000000,\n    NoFlags: 0b00,\n    PerformedWork: 0b01,\n    Placement: 0b10,\n    Incomplete: 0b10000000000000,\n    Hydrating: 0b1000000000000\n  }; // **********************************************************\n  // The section below is copied from files in React repo.\n  // Keep it in sync, and add version guards if it changes.\n  //\n  // Technically these priority levels are invalid for versions before 16.9,\n  // but 16.9 is the first version to report priority level to DevTools,\n  // so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.\n\n  let ReactPriorityLevels = {\n    ImmediatePriority: 99,\n    UserBlockingPriority: 98,\n    NormalPriority: 97,\n    LowPriority: 96,\n    IdlePriority: 95,\n    NoPriority: 90\n  };\n\n  if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gt\"])(version, '17.0.2')) {\n    ReactPriorityLevels = {\n      ImmediatePriority: 1,\n      UserBlockingPriority: 2,\n      NormalPriority: 3,\n      LowPriority: 4,\n      IdlePriority: 5,\n      NoPriority: 0\n    };\n  }\n\n  let StrictModeBits = 0;\n\n  if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gte\"])(version, '18.0.0-alpha')) {\n    // 18+\n    StrictModeBits = 0b011000;\n  } else if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gte\"])(version, '16.9.0')) {\n    // 16.9 - 17\n    StrictModeBits = 0b1;\n  } else if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gte\"])(version, '16.3.0')) {\n    // 16.3 - 16.8\n    StrictModeBits = 0b10;\n  }\n\n  let ReactTypeOfWork = null; // **********************************************************\n  // The section below is copied from files in React repo.\n  // Keep it in sync, and add version guards if it changes.\n  //\n  // TODO Update the gt() check below to be gte() whichever the next version number is.\n  // Currently the version in Git is 17.0.2 (but that version has not been/may not end up being released).\n\n  if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gt\"])(version, '17.0.1')) {\n    ReactTypeOfWork = {\n      CacheComponent: 24,\n      // Experimental\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: 23,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: 22,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: 21,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      YieldComponent: -1 // Removed\n\n    };\n  } else if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gte\"])(version, '17.0.0-alpha')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: 24,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: 23,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: 21,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      YieldComponent: -1 // Removed\n\n    };\n  } else if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gte\"])(version, '16.6.0-beta.0')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: -1,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      YieldComponent: -1 // Removed\n\n    };\n  } else if (Object(semver__WEBPACK_IMPORTED_MODULE_0__[\"gte\"])(version, '16.4.3-alpha')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 2,\n      ContextConsumer: 11,\n      ContextProvider: 12,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: -1,\n      // Doesn't exist yet\n      ForwardRef: 13,\n      Fragment: 9,\n      FunctionComponent: 0,\n      HostComponent: 7,\n      HostPortal: 6,\n      HostRoot: 5,\n      HostText: 8,\n      IncompleteClassComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 4,\n      LazyComponent: -1,\n      // Doesn't exist yet\n      LegacyHiddenComponent: -1,\n      MemoComponent: -1,\n      // Doesn't exist yet\n      Mode: 10,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 15,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: -1,\n      // Doesn't exist yet\n      SuspenseComponent: 16,\n      SuspenseListComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1 // Removed\n\n    };\n  } else {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 2,\n      ContextConsumer: 12,\n      ContextProvider: 13,\n      CoroutineComponent: 7,\n      CoroutineHandlerPhase: 8,\n      DehydratedSuspenseComponent: -1,\n      // Doesn't exist yet\n      ForwardRef: 14,\n      Fragment: 10,\n      FunctionComponent: 1,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostText: 6,\n      IncompleteClassComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 0,\n      LazyComponent: -1,\n      // Doesn't exist yet\n      LegacyHiddenComponent: -1,\n      MemoComponent: -1,\n      // Doesn't exist yet\n      Mode: 11,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 15,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: -1,\n      // Doesn't exist yet\n      SuspenseComponent: 16,\n      SuspenseListComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: 9\n    };\n  } // **********************************************************\n  // End of copied code.\n  // **********************************************************\n\n\n  function getTypeSymbol(type) {\n    const symbolOrNumber = typeof type === 'object' && type !== null ? type.$$typeof : type; // $FlowFixMe Flow doesn't know about typeof \"symbol\"\n\n    return typeof symbolOrNumber === 'symbol' ? symbolOrNumber.toString() : symbolOrNumber;\n  }\n\n  const {\n    CacheComponent,\n    ClassComponent,\n    IncompleteClassComponent,\n    FunctionComponent,\n    IndeterminateComponent,\n    ForwardRef,\n    HostRoot,\n    HostComponent,\n    HostPortal,\n    HostText,\n    Fragment,\n    LazyComponent,\n    LegacyHiddenComponent,\n    MemoComponent,\n    OffscreenComponent,\n    Profiler,\n    ScopeComponent,\n    SimpleMemoComponent,\n    SuspenseComponent,\n    SuspenseListComponent\n  } = ReactTypeOfWork;\n\n  function resolveFiberType(type) {\n    const typeSymbol = getTypeSymbol(type);\n\n    switch (typeSymbol) {\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"MEMO_NUMBER\"]:\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"MEMO_SYMBOL_STRING\"]:\n        // recursively resolving memo type in case of memo(forwardRef(Component))\n        return resolveFiberType(type.type);\n\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"FORWARD_REF_NUMBER\"]:\n      case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"FORWARD_REF_SYMBOL_STRING\"]:\n        return type.render;\n\n      default:\n        return type;\n    }\n  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n  function getDisplayNameForFiber(fiber) {\n    const {\n      elementType,\n      type,\n      tag\n    } = fiber;\n    let resolvedType = type;\n\n    if (typeof type === 'object' && type !== null) {\n      resolvedType = resolveFiberType(type);\n    }\n\n    let resolvedContext = null;\n\n    switch (tag) {\n      case CacheComponent:\n        return 'Cache';\n\n      case ClassComponent:\n      case IncompleteClassComponent:\n        return Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDisplayName\"])(resolvedType);\n\n      case FunctionComponent:\n      case IndeterminateComponent:\n        return Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDisplayName\"])(resolvedType);\n\n      case ForwardRef:\n        // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37\n        return type && type.displayName || Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDisplayName\"])(resolvedType, 'Anonymous');\n\n      case HostRoot:\n        const fiberRoot = fiber.stateNode;\n\n        if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n          return fiberRoot._debugRootType;\n        }\n\n        return null;\n\n      case HostComponent:\n        return type;\n\n      case HostPortal:\n      case HostText:\n      case Fragment:\n        return null;\n\n      case LazyComponent:\n        // This display name will not be user visible.\n        // Once a Lazy component loads its inner component, React replaces the tag and type.\n        // This display name will only show up in console logs when DevTools DEBUG mode is on.\n        return 'Lazy';\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        return elementType && elementType.displayName || type && type.displayName || Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDisplayName\"])(resolvedType, 'Anonymous');\n\n      case SuspenseComponent:\n        return 'Suspense';\n\n      case LegacyHiddenComponent:\n        return 'LegacyHidden';\n\n      case OffscreenComponent:\n        return 'Offscreen';\n\n      case ScopeComponent:\n        return 'Scope';\n\n      case SuspenseListComponent:\n        return 'SuspenseList';\n\n      case Profiler:\n        return 'Profiler';\n\n      default:\n        const typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_SYMBOL_STRING\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"DEPRECATED_ASYNC_MODE_SYMBOL_STRING\"]:\n            return null;\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_SYMBOL_STRING\"]:\n            // 16.3.0 exposed the context object as \"context\"\n            // PR #12501 changed it to \"_context\" for 16.3.1+\n            // NOTE Keep in sync with inspectElementRaw()\n            resolvedContext = fiber.type._context || fiber.type.context;\n            return `${resolvedContext.displayName || 'Context'}.Provider`;\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_SYMBOL_STRING\"]:\n            // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n            // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n            // NOTE Keep in sync with inspectElementRaw()\n            resolvedContext = fiber.type._context || fiber.type; // NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'\n            // If you change the name, figure out a more resilient way to detect it.\n\n            return `${resolvedContext.displayName || 'Context'}.Consumer`;\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_SYMBOL_STRING\"]:\n            return null;\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROFILER_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROFILER_SYMBOL_STRING\"]:\n            return `Profiler(${fiber.memoizedProps.id})`;\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"SCOPE_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"SCOPE_SYMBOL_STRING\"]:\n            return 'Scope';\n\n          default:\n            // Unknown element type.\n            // This may mean a new element type that has not yet been added to DevTools.\n            return null;\n        }\n\n    }\n  }\n\n  return {\n    getDisplayNameForFiber,\n    getTypeSymbol,\n    ReactPriorityLevels,\n    ReactTypeOfWork,\n    ReactTypeOfSideEffect,\n    StrictModeBits\n  };\n}\nfunction attach(hook, rendererID, renderer, global) {\n  // Newer versions of the reconciler package also specific reconciler version.\n  // If that version number is present, use it.\n  // Third party renderer versions may not match the reconciler version,\n  // and the latter is what's important in terms of tags and symbols.\n  const version = renderer.reconcilerVersion || renderer.version;\n  const {\n    getDisplayNameForFiber,\n    getTypeSymbol,\n    ReactPriorityLevels,\n    ReactTypeOfWork,\n    ReactTypeOfSideEffect,\n    StrictModeBits\n  } = getInternalReactConstants(version);\n  const {\n    DidCapture,\n    Hydrating,\n    NoFlags,\n    PerformedWork,\n    Placement\n  } = ReactTypeOfSideEffect;\n  const {\n    CacheComponent,\n    ClassComponent,\n    ContextConsumer,\n    DehydratedSuspenseComponent,\n    ForwardRef,\n    Fragment,\n    FunctionComponent,\n    HostRoot,\n    HostPortal,\n    HostComponent,\n    HostText,\n    IncompleteClassComponent,\n    IndeterminateComponent,\n    LegacyHiddenComponent,\n    MemoComponent,\n    OffscreenComponent,\n    SimpleMemoComponent,\n    SuspenseComponent,\n    SuspenseListComponent\n  } = ReactTypeOfWork;\n  const {\n    ImmediatePriority,\n    UserBlockingPriority,\n    NormalPriority,\n    LowPriority,\n    IdlePriority,\n    NoPriority\n  } = ReactPriorityLevels;\n  const {\n    overrideHookState,\n    overrideHookStateDeletePath,\n    overrideHookStateRenamePath,\n    overrideProps,\n    overridePropsDeletePath,\n    overridePropsRenamePath,\n    scheduleRefresh,\n    setErrorHandler,\n    setSuspenseHandler,\n    scheduleUpdate\n  } = renderer;\n  const supportsTogglingError = typeof setErrorHandler === 'function' && typeof scheduleUpdate === 'function';\n  const supportsTogglingSuspense = typeof setSuspenseHandler === 'function' && typeof scheduleUpdate === 'function';\n\n  if (typeof scheduleRefresh === 'function') {\n    // When Fast Refresh updates a component, the frontend may need to purge cached information.\n    // For example, ASTs cached for the component (for named hooks) may no longer be valid.\n    // Send a signal to the frontend to purge this cached information.\n    // The \"fastRefreshScheduled\" dispatched is global (not Fiber or even Renderer specific).\n    // This is less effecient since it means the front-end will need to purge the entire cache,\n    // but this is probably an okay trade off in order to reduce coupling between the DevTools and Fast Refresh.\n    renderer.scheduleRefresh = (...args) => {\n      try {\n        hook.emit('fastRefreshScheduled');\n      } finally {\n        return scheduleRefresh(...args);\n      }\n    };\n  } // Tracks Fibers with recently changed number of error/warning messages.\n  // These collections store the Fiber rather than the ID,\n  // in order to avoid generating an ID for Fibers that never get mounted\n  // (due to e.g. Suspense or error boundaries).\n  // onErrorOrWarning() adds Fibers and recordPendingErrorsAndWarnings() later clears them.\n\n\n  const fibersWithChangedErrorOrWarningCounts = new Set();\n  const pendingFiberToErrorsMap = new Map();\n  const pendingFiberToWarningsMap = new Map(); // Mapping of fiber IDs to error/warning messages and counts.\n\n  const fiberIDToErrorsMap = new Map();\n  const fiberIDToWarningsMap = new Map();\n\n  function clearErrorsAndWarnings() {\n    // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n    for (const id of fiberIDToErrorsMap.keys()) {\n      const fiber = idToArbitraryFiberMap.get(id);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n        updateMostRecentlyInspectedElementIfNecessary(id);\n      }\n    } // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n\n    for (const id of fiberIDToWarningsMap.keys()) {\n      const fiber = idToArbitraryFiberMap.get(id);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n        updateMostRecentlyInspectedElementIfNecessary(id);\n      }\n    }\n\n    fiberIDToErrorsMap.clear();\n    fiberIDToWarningsMap.clear();\n    flushPendingEvents();\n  }\n\n  function clearMessageCountHelper(fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {\n    const fiber = idToArbitraryFiberMap.get(fiberID);\n\n    if (fiber != null) {\n      // Throw out any pending changes.\n      pendingFiberToErrorsMap.delete(fiber);\n\n      if (fiberIDToMessageCountMap.has(fiberID)) {\n        fiberIDToMessageCountMap.delete(fiberID); // If previous flushed counts have changed, schedule an update too.\n\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n        flushPendingEvents();\n        updateMostRecentlyInspectedElementIfNecessary(fiberID);\n      } else {\n        fibersWithChangedErrorOrWarningCounts.delete(fiber);\n      }\n    }\n  }\n\n  function clearErrorsForFiberID(fiberID) {\n    clearMessageCountHelper(fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);\n  }\n\n  function clearWarningsForFiberID(fiberID) {\n    clearMessageCountHelper(fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);\n  }\n\n  function updateMostRecentlyInspectedElementIfNecessary(fiberID) {\n    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberID) {\n      hasElementUpdatedSinceLastInspected = true;\n    }\n  } // Called when an error or warning is logged during render, commit, or passive (including unmount functions).\n\n\n  function onErrorOrWarning(fiber, type, args) {\n    if (type === 'error') {\n      const maybeID = getFiberIDUnsafe(fiber); // if this is an error simulated by us to trigger error boundary, ignore\n\n      if (maybeID != null && forceErrorForFiberIDs.get(maybeID) === true) {\n        return;\n      }\n    }\n\n    const message = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"format\"])(...args);\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n      debug('onErrorOrWarning', fiber, null, `${type}: \"${message}\"`);\n    } // Mark this Fiber as needed its warning/error count updated during the next flush.\n\n\n    fibersWithChangedErrorOrWarningCounts.add(fiber); // Track the warning/error for later.\n\n    const fiberMap = type === 'error' ? pendingFiberToErrorsMap : pendingFiberToWarningsMap;\n    const messageMap = fiberMap.get(fiber);\n\n    if (messageMap != null) {\n      const count = messageMap.get(message) || 0;\n      messageMap.set(message, count + 1);\n    } else {\n      fiberMap.set(fiber, new Map([[message, 1]]));\n    } // Passive effects may trigger errors or warnings too;\n    // In this case, we should wait until the rest of the passive effects have run,\n    // but we shouldn't wait until the next commit because that might be a long time.\n    // This would also cause \"tearing\" between an inspected Component and the tree view.\n    // Then again we don't want to flush too soon because this could be an error during async rendering.\n    // Use a debounce technique to ensure that we'll eventually flush.\n\n\n    flushPendingErrorsAndWarningsAfterDelay();\n  } // Patching the console enables DevTools to do a few useful things:\n  // * Append component stacks to warnings and error messages\n  // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)\n  //\n  // Don't patch in test environments because we don't want to interfere with Jest's own console overrides.\n\n\n  if (true) {\n    Object(_console__WEBPACK_IMPORTED_MODULE_7__[\"registerRenderer\"])(renderer, onErrorOrWarning); // The renderer interface can't read these preferences directly,\n    // because it is stored in localStorage within the context of the extension.\n    // It relies on the extension to pass the preference through via the global.\n\n    const appendComponentStack = window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ !== false;\n    const breakOnConsoleErrors = window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ === true;\n    const showInlineWarningsAndErrors = window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ !== false;\n    const hideConsoleLogsInStrictMode = window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ === true;\n    const browserTheme = window.__REACT_DEVTOOLS_BROWSER_THEME__;\n    Object(_console__WEBPACK_IMPORTED_MODULE_7__[\"patch\"])({\n      appendComponentStack,\n      breakOnConsoleErrors,\n      showInlineWarningsAndErrors,\n      hideConsoleLogsInStrictMode,\n      browserTheme\n    });\n  }\n\n  const debug = (name, fiber, parentFiber, extraString = '') => {\n    if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n      const displayName = fiber.tag + ':' + (getDisplayNameForFiber(fiber) || 'null');\n      const maybeID = getFiberIDUnsafe(fiber) || '<no id>';\n      const parentDisplayName = parentFiber ? parentFiber.tag + ':' + (getDisplayNameForFiber(parentFiber) || 'null') : '';\n      const maybeParentID = parentFiber ? getFiberIDUnsafe(parentFiber) || '<no-id>' : '';\n      console.groupCollapsed(`[renderer] %c${name} %c${displayName} (${maybeID}) %c${parentFiber ? `${parentDisplayName} (${maybeParentID})` : ''} %c${extraString}`, 'color: red; font-weight: bold;', 'color: blue;', 'color: purple;', 'color: black;');\n      console.log(new Error().stack.split('\\n').slice(1).join('\\n'));\n      console.groupEnd();\n    }\n  }; // Configurable Components tree filters.\n\n\n  const hideElementsWithDisplayNames = new Set();\n  const hideElementsWithPaths = new Set();\n  const hideElementsWithTypes = new Set(); // Highlight updates\n\n  let traceUpdatesEnabled = false;\n  const traceUpdatesForNodes = new Set();\n\n  function applyComponentFilters(componentFilters) {\n    hideElementsWithTypes.clear();\n    hideElementsWithDisplayNames.clear();\n    hideElementsWithPaths.clear();\n    componentFilters.forEach(componentFilter => {\n      if (!componentFilter.isEnabled) {\n        return;\n      }\n\n      switch (componentFilter.type) {\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ComponentFilterDisplayName\"]:\n          if (componentFilter.isValid && componentFilter.value !== '') {\n            hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, 'i'));\n          }\n\n          break;\n\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ComponentFilterElementType\"]:\n          hideElementsWithTypes.add(componentFilter.value);\n          break;\n\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ComponentFilterLocation\"]:\n          if (componentFilter.isValid && componentFilter.value !== '') {\n            hideElementsWithPaths.add(new RegExp(componentFilter.value, 'i'));\n          }\n\n          break;\n\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ComponentFilterHOC\"]:\n          hideElementsWithDisplayNames.add(new RegExp('\\\\('));\n          break;\n\n        default:\n          console.warn(`Invalid component filter type \"${componentFilter.type}\"`);\n          break;\n      }\n    });\n  } // The renderer interface can't read saved component filters directly,\n  // because they are stored in localStorage within the context of the extension.\n  // Instead it relies on the extension to pass filters through.\n\n\n  if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {\n    applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);\n  } else {\n    // Unfortunately this feature is not expected to work for React Native for now.\n    // It would be annoying for us to spam YellowBox warnings with unactionable stuff,\n    // so for now just skip this message...\n    //console.warn('⚛️ DevTools: Could not locate saved component filters');\n    // Fallback to assuming the default filters in this case.\n    applyComponentFilters(Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getDefaultComponentFilters\"])());\n  } // If necessary, we can revisit optimizing this operation.\n  // For example, we could add a new recursive unmount tree operation.\n  // The unmount operations are already significantly smaller than mount operations though.\n  // This is something to keep in mind for later.\n\n\n  function updateComponentFilters(componentFilters) {\n    if (isProfiling) {\n      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.\n      // If necessary, we could support this- but it doesn't seem like a necessary use case.\n      throw Error('Cannot modify filter preferences while profiling');\n    } // Recursively unmount all roots.\n\n\n    hook.getFiberRoots(rendererID).forEach(root => {\n      currentRootID = getOrGenerateFiberID(root.current); // The TREE_OPERATION_REMOVE_ROOT operation serves two purposes:\n      // 1. It avoids sending unnecessary bridge traffic to clear a root.\n      // 2. It preserves Fiber IDs when remounting (below) which in turn ID to error/warning mapping.\n\n      pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_REMOVE_ROOT\"]);\n      flushPendingEvents(root);\n      currentRootID = -1;\n    });\n    applyComponentFilters(componentFilters); // Reset pseudo counters so that new path selections will be persisted.\n\n    rootDisplayNameCounter.clear(); // Recursively re-mount all roots with new filter criteria applied.\n\n    hook.getFiberRoots(rendererID).forEach(root => {\n      currentRootID = getOrGenerateFiberID(root.current);\n      setRootPseudoKey(currentRootID, root.current);\n      mountFiberRecursively(root.current, null, false, false);\n      flushPendingEvents(root);\n      currentRootID = -1;\n    }); // Also re-evaluate all error and warning counts given the new filters.\n\n    reevaluateErrorsAndWarnings();\n    flushPendingEvents();\n  } // NOTICE Keep in sync with get*ForFiber methods\n\n\n  function shouldFilterFiber(fiber) {\n    const {\n      _debugSource,\n      tag,\n      type\n    } = fiber;\n\n    switch (tag) {\n      case DehydratedSuspenseComponent:\n        // TODO: ideally we would show dehydrated Suspense immediately.\n        // However, it has some special behavior (like disconnecting\n        // an alternate and turning into real Suspense) which breaks DevTools.\n        // For now, ignore it, and only show it once it gets hydrated.\n        // https://github.com/bvaughn/react-devtools-experimental/issues/197\n        return true;\n\n      case HostPortal:\n      case HostText:\n      case Fragment:\n      case LegacyHiddenComponent:\n      case OffscreenComponent:\n        return true;\n\n      case HostRoot:\n        // It is never valid to filter the root element.\n        return false;\n\n      default:\n        const typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_SYMBOL_STRING\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"DEPRECATED_ASYNC_MODE_SYMBOL_STRING\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_SYMBOL_STRING\"]:\n            return true;\n\n          default:\n            break;\n        }\n\n    }\n\n    const elementType = getElementTypeForFiber(fiber);\n\n    if (hideElementsWithTypes.has(elementType)) {\n      return true;\n    }\n\n    if (hideElementsWithDisplayNames.size > 0) {\n      const displayName = getDisplayNameForFiber(fiber);\n\n      if (displayName != null) {\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n        for (const displayNameRegExp of hideElementsWithDisplayNames) {\n          if (displayNameRegExp.test(displayName)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (_debugSource != null && hideElementsWithPaths.size > 0) {\n      const {\n        fileName\n      } = _debugSource; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n      for (const pathRegExp of hideElementsWithPaths) {\n        if (pathRegExp.test(fileName)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n  function getElementTypeForFiber(fiber) {\n    const {\n      type,\n      tag\n    } = fiber;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n        return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"];\n\n      case FunctionComponent:\n      case IndeterminateComponent:\n        return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeFunction\"];\n\n      case ForwardRef:\n        return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeForwardRef\"];\n\n      case HostRoot:\n        return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeRoot\"];\n\n      case HostComponent:\n        return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeHostComponent\"];\n\n      case HostPortal:\n      case HostText:\n      case Fragment:\n        return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeOtherOrUnknown\"];\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeMemo\"];\n\n      case SuspenseComponent:\n        return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeSuspense\"];\n\n      case SuspenseListComponent:\n        return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeSuspenseList\"];\n\n      default:\n        const typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONCURRENT_MODE_SYMBOL_STRING\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"DEPRECATED_ASYNC_MODE_SYMBOL_STRING\"]:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeOtherOrUnknown\"];\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_SYMBOL_STRING\"]:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeContext\"];\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_SYMBOL_STRING\"]:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeContext\"];\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"STRICT_MODE_SYMBOL_STRING\"]:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeOtherOrUnknown\"];\n\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROFILER_NUMBER\"]:\n          case _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROFILER_SYMBOL_STRING\"]:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeProfiler\"];\n\n          default:\n            return react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeOtherOrUnknown\"];\n        }\n\n    }\n  } // Map of one or more Fibers in a pair to their unique id number.\n  // We track both Fibers to support Fast Refresh,\n  // which may forcefully replace one of the pair as part of hot reloading.\n  // In that case it's still important to be able to locate the previous ID during subsequent renders.\n\n\n  const fiberToIDMap = new Map(); // Map of id to one (arbitrary) Fiber in a pair.\n  // This Map is used to e.g. get the display name for a Fiber or schedule an update,\n  // operations that should be the same whether the current and work-in-progress Fiber is used.\n\n  const idToArbitraryFiberMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.\n  // This is so that we can quickly capture a snapshot of those values if profiling starts.\n  // If we didn't store these values, we'd have to crawl the tree when profiling started,\n  // and use a slow path to find each of the current Fibers.\n\n  const idToTreeBaseDurationMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.\n  // This map enables us to filter these times by root when sending them to the frontend.\n\n  const idToRootMap = new Map(); // When a mount or update is in progress, this value tracks the root that is being operated on.\n\n  let currentRootID = -1; // Returns the unique ID for a Fiber or generates and caches a new one if the Fiber hasn't been seen before.\n  // Once this method has been called for a Fiber, untrackFiberID() should always be called later to avoid leaking.\n\n  function getOrGenerateFiberID(fiber) {\n    let id = null;\n\n    if (fiberToIDMap.has(fiber)) {\n      id = fiberToIDMap.get(fiber);\n    } else {\n      const {\n        alternate\n      } = fiber;\n\n      if (alternate !== null && fiberToIDMap.has(alternate)) {\n        id = fiberToIDMap.get(alternate);\n      }\n    }\n\n    let didGenerateID = false;\n\n    if (id === null) {\n      didGenerateID = true;\n      id = Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getUID\"])();\n    } // This refinement is for Flow purposes only.\n\n\n    const refinedID = id; // Make sure we're tracking this Fiber\n    // e.g. if it just mounted or an error was logged during initial render.\n\n    if (!fiberToIDMap.has(fiber)) {\n      fiberToIDMap.set(fiber, refinedID);\n      idToArbitraryFiberMap.set(refinedID, fiber);\n    } // Also make sure we're tracking its alternate,\n    // e.g. in case this is the first update after mount.\n\n\n    const {\n      alternate\n    } = fiber;\n\n    if (alternate !== null) {\n      if (!fiberToIDMap.has(alternate)) {\n        fiberToIDMap.set(alternate, refinedID);\n      }\n    }\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n      if (didGenerateID) {\n        debug('getOrGenerateFiberID()', fiber, fiber.return, 'Generated a new UID');\n      }\n    }\n\n    return refinedID;\n  } // Returns an ID if one has already been generated for the Fiber or throws.\n\n\n  function getFiberIDThrows(fiber) {\n    const maybeID = getFiberIDUnsafe(fiber);\n\n    if (maybeID !== null) {\n      return maybeID;\n    }\n\n    throw Error(`Could not find ID for Fiber \"${getDisplayNameForFiber(fiber) || ''}\"`);\n  } // Returns an ID if one has already been generated for the Fiber or null if one has not been generated.\n  // Use this method while e.g. logging to avoid over-retaining Fibers.\n\n\n  function getFiberIDUnsafe(fiber) {\n    if (fiberToIDMap.has(fiber)) {\n      return fiberToIDMap.get(fiber);\n    } else {\n      const {\n        alternate\n      } = fiber;\n\n      if (alternate !== null && fiberToIDMap.has(alternate)) {\n        return fiberToIDMap.get(alternate);\n      }\n    }\n\n    return null;\n  } // Removes a Fiber (and its alternate) from the Maps used to track their id.\n  // This method should always be called when a Fiber is unmounting.\n\n\n  function untrackFiberID(fiber) {\n    if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n      debug('untrackFiberID()', fiber, fiber.return, 'schedule after delay');\n    } // Untrack Fibers after a slight delay in order to support a Fast Refresh edge case:\n    // 1. Component type is updated and Fast Refresh schedules an update+remount.\n    // 2. flushPendingErrorsAndWarningsAfterDelay() runs, sees the old Fiber is no longer mounted\n    //    (it's been disconnected by Fast Refresh), and calls untrackFiberID() to clear it from the Map.\n    // 3. React flushes pending passive effects before it runs the next render,\n    //    which logs an error or warning, which causes a new ID to be generated for this Fiber.\n    // 4. DevTools now tries to unmount the old Component with the new ID.\n    //\n    // The underlying problem here is the premature clearing of the Fiber ID,\n    // but DevTools has no way to detect that a given Fiber has been scheduled for Fast Refresh.\n    // (The \"_debugNeedsRemount\" flag won't necessarily be set.)\n    //\n    // The best we can do is to delay untracking by a small amount,\n    // and give React time to process the Fast Refresh delay.\n\n\n    untrackFibersSet.add(fiber); // React may detach alternate pointers during unmount;\n    // Since our untracking code is async, we should explicily track the pending alternate here as well.\n\n    const alternate = fiber.alternate;\n\n    if (alternate !== null) {\n      untrackFibersSet.add(alternate);\n    }\n\n    if (untrackFibersTimeoutID === null) {\n      untrackFibersTimeoutID = setTimeout(untrackFibers, 1000);\n    }\n  }\n\n  const untrackFibersSet = new Set();\n  let untrackFibersTimeoutID = null;\n\n  function untrackFibers() {\n    if (untrackFibersTimeoutID !== null) {\n      clearTimeout(untrackFibersTimeoutID);\n      untrackFibersTimeoutID = null;\n    }\n\n    untrackFibersSet.forEach(fiber => {\n      const fiberID = getFiberIDUnsafe(fiber);\n\n      if (fiberID !== null) {\n        idToArbitraryFiberMap.delete(fiberID); // Also clear any errors/warnings associated with this fiber.\n\n        clearErrorsForFiberID(fiberID);\n        clearWarningsForFiberID(fiberID);\n      }\n\n      fiberToIDMap.delete(fiber);\n      const {\n        alternate\n      } = fiber;\n\n      if (alternate !== null) {\n        fiberToIDMap.delete(alternate);\n      }\n\n      if (forceErrorForFiberIDs.has(fiberID)) {\n        forceErrorForFiberIDs.delete(fiberID);\n\n        if (forceErrorForFiberIDs.size === 0 && setErrorHandler != null) {\n          setErrorHandler(shouldErrorFiberAlwaysNull);\n        }\n      }\n    });\n    untrackFibersSet.clear();\n  }\n\n  function getChangeDescription(prevFiber, nextFiber) {\n    switch (getElementTypeForFiber(nextFiber)) {\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"]:\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeFunction\"]:\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeMemo\"]:\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeForwardRef\"]:\n        if (prevFiber === null) {\n          return {\n            context: null,\n            didHooksChange: false,\n            isFirstMount: true,\n            props: null,\n            state: null\n          };\n        } else {\n          const data = {\n            context: getContextChangedKeys(nextFiber),\n            didHooksChange: false,\n            isFirstMount: false,\n            props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),\n            state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)\n          }; // Only traverse the hooks list once, depending on what info we're returning.\n\n          if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_9__[\"enableProfilerChangedHookIndices\"]) {\n            const indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);\n            data.hooks = indices;\n            data.didHooksChange = indices !== null && indices.length > 0;\n          } else {\n            data.didHooksChange = didHooksChange(prevFiber.memoizedState, nextFiber.memoizedState);\n          }\n\n          return data;\n        }\n\n      default:\n        return null;\n    }\n  }\n\n  function updateContextsForFiber(fiber) {\n    switch (getElementTypeForFiber(fiber)) {\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"]:\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeForwardRef\"]:\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeFunction\"]:\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeMemo\"]:\n        if (idToContextsMap !== null) {\n          const id = getFiberIDThrows(fiber);\n          const contexts = getContextsForFiber(fiber);\n\n          if (contexts !== null) {\n            idToContextsMap.set(id, contexts);\n          }\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  } // Differentiates between a null context value and no context.\n\n\n  const NO_CONTEXT = {};\n\n  function getContextsForFiber(fiber) {\n    let legacyContext = NO_CONTEXT;\n    let modernContext = NO_CONTEXT;\n\n    switch (getElementTypeForFiber(fiber)) {\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"]:\n        const instance = fiber.stateNode;\n\n        if (instance != null) {\n          if (instance.constructor && instance.constructor.contextType != null) {\n            modernContext = instance.context;\n          } else {\n            legacyContext = instance.context;\n\n            if (legacyContext && Object.keys(legacyContext).length === 0) {\n              legacyContext = NO_CONTEXT;\n            }\n          }\n        }\n\n        return [legacyContext, modernContext];\n\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeForwardRef\"]:\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeFunction\"]:\n      case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeMemo\"]:\n        const dependencies = fiber.dependencies;\n\n        if (dependencies && dependencies.firstContext) {\n          modernContext = dependencies.firstContext;\n        }\n\n        return [legacyContext, modernContext];\n\n      default:\n        return null;\n    }\n  } // Record all contexts at the time profiling is started.\n  // Fibers only store the current context value,\n  // so we need to track them separately in order to determine changed keys.\n\n\n  function crawlToInitializeContextsMap(fiber) {\n    updateContextsForFiber(fiber);\n    let current = fiber.child;\n\n    while (current !== null) {\n      crawlToInitializeContextsMap(current);\n      current = current.sibling;\n    }\n  }\n\n  function getContextChangedKeys(fiber) {\n    if (idToContextsMap !== null) {\n      const id = getFiberIDThrows(fiber);\n      const prevContexts = idToContextsMap.has(id) ? idToContextsMap.get(id) : null;\n      const nextContexts = getContextsForFiber(fiber);\n\n      if (prevContexts == null || nextContexts == null) {\n        return null;\n      }\n\n      const [prevLegacyContext, prevModernContext] = prevContexts;\n      const [nextLegacyContext, nextModernContext] = nextContexts;\n\n      switch (getElementTypeForFiber(fiber)) {\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"]:\n          if (prevContexts && nextContexts) {\n            if (nextLegacyContext !== NO_CONTEXT) {\n              return getChangedKeys(prevLegacyContext, nextLegacyContext);\n            } else if (nextModernContext !== NO_CONTEXT) {\n              return prevModernContext !== nextModernContext;\n            }\n          }\n\n          break;\n\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeForwardRef\"]:\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeFunction\"]:\n        case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeMemo\"]:\n          if (nextModernContext !== NO_CONTEXT) {\n            let prevContext = prevModernContext;\n            let nextContext = nextModernContext;\n\n            while (prevContext && nextContext) {\n              // Note this only works for versions of React that support this key (e.v. 18+)\n              // For older versions, there's no good way to read the current context value after render has completed.\n              // This is because React maintains a stack of context values during render,\n              // but by the time DevTools is called, render has finished and the stack is empty.\n              if (!Object(shared_objectIs__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(prevContext.memoizedValue, nextContext.memoizedValue)) {\n                return true;\n              }\n\n              prevContext = prevContext.next;\n              nextContext = nextContext.next;\n            }\n\n            return false;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return null;\n  }\n\n  function areHookInputsEqual(nextDeps, prevDeps) {\n    if (prevDeps === null) {\n      return false;\n    }\n\n    for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n      if (Object(shared_objectIs__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(nextDeps[i], prevDeps[i])) {\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  function isEffect(memoizedState) {\n    if (memoizedState === null || typeof memoizedState !== 'object') {\n      return false;\n    }\n\n    const {\n      deps\n    } = memoizedState;\n    const boundHasOwnProperty = shared_hasOwnProperty__WEBPACK_IMPORTED_MODULE_12__[\"default\"].bind(memoizedState);\n    return boundHasOwnProperty('create') && boundHasOwnProperty('destroy') && boundHasOwnProperty('deps') && boundHasOwnProperty('next') && boundHasOwnProperty('tag') && (deps === null || Object(shared_isArray__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(deps));\n  }\n\n  function didHookChange(prev, next) {\n    const prevMemoizedState = prev.memoizedState;\n    const nextMemoizedState = next.memoizedState;\n\n    if (isEffect(prevMemoizedState) && isEffect(nextMemoizedState)) {\n      return prevMemoizedState !== nextMemoizedState && !areHookInputsEqual(nextMemoizedState.deps, prevMemoizedState.deps);\n    }\n\n    return nextMemoizedState !== prevMemoizedState;\n  }\n\n  function didHooksChange(prev, next) {\n    if (prev == null || next == null) {\n      return false;\n    } // We can't report anything meaningful for hooks changes.\n\n\n    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n      while (next !== null) {\n        if (didHookChange(prev, next)) {\n          return true;\n        } else {\n          next = next.next;\n          prev = prev.next;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function getChangedHooksIndices(prev, next) {\n    if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_9__[\"enableProfilerChangedHookIndices\"]) {\n      if (prev == null || next == null) {\n        return null;\n      }\n\n      const indices = [];\n      let index = 0;\n\n      if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n        while (next !== null) {\n          if (didHookChange(prev, next)) {\n            indices.push(index);\n          }\n\n          next = next.next;\n          prev = prev.next;\n          index++;\n        }\n      }\n\n      return indices;\n    }\n\n    return null;\n  }\n\n  function getChangedKeys(prev, next) {\n    if (prev == null || next == null) {\n      return null;\n    } // We can't report anything meaningful for hooks changes.\n\n\n    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n      return null;\n    }\n\n    const keys = new Set([...Object.keys(prev), ...Object.keys(next)]);\n    const changedKeys = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n    for (const key of keys) {\n      if (prev[key] !== next[key]) {\n        changedKeys.push(key);\n      }\n    }\n\n    return changedKeys;\n  } // eslint-disable-next-line no-unused-vars\n\n\n  function didFiberRender(prevFiber, nextFiber) {\n    switch (nextFiber.tag) {\n      case ClassComponent:\n      case FunctionComponent:\n      case ContextConsumer:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        // For types that execute user code, we check PerformedWork effect.\n        // We don't reflect bailouts (either referential or sCU) in DevTools.\n        // eslint-disable-next-line no-bitwise\n        return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;\n      // Note: ContextConsumer only gets PerformedWork effect in 16.3.3+\n      // so it won't get highlighted with React 16.3.0 to 16.3.2.\n\n      default:\n        // For host components and other types, we compare inputs\n        // to determine whether something is an update.\n        return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;\n    }\n  }\n\n  const pendingOperations = [];\n  const pendingRealUnmountedIDs = [];\n  const pendingSimulatedUnmountedIDs = [];\n  let pendingOperationsQueue = [];\n  const pendingStringTable = new Map();\n  let pendingStringTableLength = 0;\n  let pendingUnmountedRootID = null;\n\n  function pushOperation(op) {\n    if (true) {\n      if (!Number.isInteger(op)) {\n        console.error('pushOperation() was called but the value is not an integer.', op);\n      }\n    }\n\n    pendingOperations.push(op);\n  }\n\n  function flushOrQueueOperations(operations) {\n    if (operations.length === 3) {\n      // This operations array is a no op: [renderer ID, root ID, string table size (0)]\n      // We can usually skip sending updates like this across the bridge, unless we're Profiling.\n      // In that case, even though the tree didn't change– some Fibers may have still rendered.\n      if (!isProfiling || currentCommitProfilingMetadata == null || currentCommitProfilingMetadata.durations.length === 0) {\n        return;\n      }\n    }\n\n    if (pendingOperationsQueue !== null) {\n      pendingOperationsQueue.push(operations);\n    } else {\n      hook.emit('operations', operations);\n    }\n  }\n\n  let flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;\n\n  function clearPendingErrorsAndWarningsAfterDelay() {\n    if (flushPendingErrorsAndWarningsAfterDelayTimeoutID !== null) {\n      clearTimeout(flushPendingErrorsAndWarningsAfterDelayTimeoutID);\n      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;\n    }\n  }\n\n  function flushPendingErrorsAndWarningsAfterDelay() {\n    clearPendingErrorsAndWarningsAfterDelay();\n    flushPendingErrorsAndWarningsAfterDelayTimeoutID = setTimeout(() => {\n      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;\n\n      if (pendingOperations.length > 0) {\n        // On the off chance that something else has pushed pending operations,\n        // we should bail on warnings; it's probably not safe to push midway.\n        return;\n      }\n\n      recordPendingErrorsAndWarnings();\n\n      if (pendingOperations.length === 0) {\n        // No warnings or errors to flush; we can bail out early here too.\n        return;\n      } // We can create a smaller operations array than flushPendingEvents()\n      // because we only need to flush warning and error counts.\n      // Only a few pieces of fixed information are required up front.\n\n\n      const operations = new Array(3 + pendingOperations.length);\n      operations[0] = rendererID;\n      operations[1] = currentRootID;\n      operations[2] = 0; // String table size\n\n      for (let j = 0; j < pendingOperations.length; j++) {\n        operations[3 + j] = pendingOperations[j];\n      }\n\n      flushOrQueueOperations(operations);\n      pendingOperations.length = 0;\n    }, 1000);\n  }\n\n  function reevaluateErrorsAndWarnings() {\n    fibersWithChangedErrorOrWarningCounts.clear();\n    fiberIDToErrorsMap.forEach((countMap, fiberID) => {\n      const fiber = idToArbitraryFiberMap.get(fiberID);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n      }\n    });\n    fiberIDToWarningsMap.forEach((countMap, fiberID) => {\n      const fiber = idToArbitraryFiberMap.get(fiberID);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n      }\n    });\n    recordPendingErrorsAndWarnings();\n  }\n\n  function mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {\n    let newCount = 0;\n    let messageCountMap = fiberIDToMessageCountMap.get(fiberID);\n    const pendingMessageCountMap = pendingFiberToMessageCountMap.get(fiber);\n\n    if (pendingMessageCountMap != null) {\n      if (messageCountMap == null) {\n        messageCountMap = pendingMessageCountMap;\n        fiberIDToMessageCountMap.set(fiberID, pendingMessageCountMap);\n      } else {\n        // This Flow refinement should not be necessary and yet...\n        const refinedMessageCountMap = messageCountMap;\n        pendingMessageCountMap.forEach((pendingCount, message) => {\n          const previousCount = refinedMessageCountMap.get(message) || 0;\n          refinedMessageCountMap.set(message, previousCount + pendingCount);\n        });\n      }\n    }\n\n    if (!shouldFilterFiber(fiber)) {\n      if (messageCountMap != null) {\n        messageCountMap.forEach(count => {\n          newCount += count;\n        });\n      }\n    }\n\n    pendingFiberToMessageCountMap.delete(fiber);\n    return newCount;\n  }\n\n  function recordPendingErrorsAndWarnings() {\n    clearPendingErrorsAndWarningsAfterDelay();\n    fibersWithChangedErrorOrWarningCounts.forEach(fiber => {\n      const fiberID = getFiberIDUnsafe(fiber);\n\n      if (fiberID === null) {// Don't send updates for Fibers that didn't mount due to e.g. Suspense or an error boundary.\n      } else {\n        const errorCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);\n        const warningCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);\n        pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS\"]);\n        pushOperation(fiberID);\n        pushOperation(errorCount);\n        pushOperation(warningCount);\n      } // Always clean up so that we don't leak.\n\n\n      pendingFiberToErrorsMap.delete(fiber);\n      pendingFiberToWarningsMap.delete(fiber);\n    });\n    fibersWithChangedErrorOrWarningCounts.clear();\n  }\n\n  function flushPendingEvents(root) {\n    // Add any pending errors and warnings to the operations array.\n    // We do this just before flushing, so we can ignore errors for no-longer-mounted Fibers.\n    recordPendingErrorsAndWarnings();\n\n    if (pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingSimulatedUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {\n      // If we aren't profiling, we can just bail out here.\n      // No use sending an empty update over the bridge.\n      //\n      // The Profiler stores metadata for each commit and reconstructs the app tree per commit using:\n      // (1) an initial tree snapshot and\n      // (2) the operations array for each commit\n      // Because of this, it's important that the operations and metadata arrays align,\n      // So it's important not to omit even empty operations while profiling is active.\n      if (!isProfiling) {\n        return;\n      }\n    }\n\n    const numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);\n    const operations = new Array( // Identify which renderer this update is coming from.\n    2 + // [rendererID, rootFiberID]\n    // How big is the string table?\n    1 + // [stringTableLength]\n    // Then goes the actual string table.\n    pendingStringTableLength + ( // All unmounts are batched in a single message.\n    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]\n    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations\n    pendingOperations.length); // Identify which renderer this update is coming from.\n    // This enables roots to be mapped to renderers,\n    // Which in turn enables fiber props, states, and hooks to be inspected.\n\n    let i = 0;\n    operations[i++] = rendererID;\n    operations[i++] = currentRootID; // Now fill in the string table.\n    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]\n\n    operations[i++] = pendingStringTableLength;\n    pendingStringTable.forEach((entry, stringKey) => {\n      const encodedString = entry.encodedString; // Don't use the string length.\n      // It won't work for multibyte characters (like emoji).\n\n      const length = encodedString.length;\n      operations[i++] = length;\n\n      for (let j = 0; j < length; j++) {\n        operations[i + j] = encodedString[j];\n      }\n\n      i += length;\n    });\n\n    if (numUnmountIDs > 0) {\n      // All unmounts except roots are batched in a single message.\n      operations[i++] = _constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_REMOVE\"]; // The first number is how many unmounted IDs we're gonna send.\n\n      operations[i++] = numUnmountIDs; // Fill in the real unmounts in the reverse order.\n      // They were inserted parents-first by React, but we want children-first.\n      // So we traverse our array backwards.\n\n      for (let j = pendingRealUnmountedIDs.length - 1; j >= 0; j--) {\n        operations[i++] = pendingRealUnmountedIDs[j];\n      } // Fill in the simulated unmounts (hidden Suspense subtrees) in their order.\n      // (We want children to go before parents.)\n      // They go *after* the real unmounts because we know for sure they won't be\n      // children of already pushed \"real\" IDs. If they were, we wouldn't be able\n      // to discover them during the traversal, as they would have been deleted.\n\n\n      for (let j = 0; j < pendingSimulatedUnmountedIDs.length; j++) {\n        operations[i + j] = pendingSimulatedUnmountedIDs[j];\n      }\n\n      i += pendingSimulatedUnmountedIDs.length; // The root ID should always be unmounted last.\n\n      if (pendingUnmountedRootID !== null) {\n        operations[i] = pendingUnmountedRootID;\n        i++;\n      }\n    } // Fill in the rest of the operations.\n\n\n    for (let j = 0; j < pendingOperations.length; j++) {\n      operations[i + j] = pendingOperations[j];\n    }\n\n    i += pendingOperations.length; // Let the frontend know about tree operations.\n\n    flushOrQueueOperations(operations); // Reset all of the pending state now that we've told the frontend about it.\n\n    pendingOperations.length = 0;\n    pendingRealUnmountedIDs.length = 0;\n    pendingSimulatedUnmountedIDs.length = 0;\n    pendingUnmountedRootID = null;\n    pendingStringTable.clear();\n    pendingStringTableLength = 0;\n  }\n\n  function getStringID(string) {\n    if (string === null) {\n      return 0;\n    }\n\n    const existingEntry = pendingStringTable.get(string);\n\n    if (existingEntry !== undefined) {\n      return existingEntry.id;\n    }\n\n    const id = pendingStringTable.size + 1;\n    const encodedString = Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"utfEncodeString\"])(string);\n    pendingStringTable.set(string, {\n      encodedString,\n      id\n    }); // The string table total length needs to account both for the string length,\n    // and for the array item that contains the length itself.\n    //\n    // Don't use string length for this table.\n    // It won't work for multibyte characters (like emoji).\n\n    pendingStringTableLength += encodedString.length + 1;\n    return id;\n  }\n\n  function recordMount(fiber, parentFiber) {\n    const isRoot = fiber.tag === HostRoot;\n    const id = getOrGenerateFiberID(fiber);\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n      debug('recordMount()', fiber, parentFiber);\n    }\n\n    const hasOwnerMetadata = fiber.hasOwnProperty('_debugOwner');\n    const isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');\n\n    if (isRoot) {\n      pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_ADD\"]);\n      pushOperation(id);\n      pushOperation(react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeRoot\"]);\n      pushOperation((fiber.mode & StrictModeBits) !== 0 ? 1 : 0);\n      pushOperation(isProfilingSupported ? 1 : 0);\n      pushOperation(StrictModeBits !== 0 ? 1 : 0);\n      pushOperation(hasOwnerMetadata ? 1 : 0);\n\n      if (isProfiling) {\n        if (displayNamesByRootID !== null) {\n          displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));\n        }\n      }\n    } else {\n      const {\n        key\n      } = fiber;\n      const displayName = getDisplayNameForFiber(fiber);\n      const elementType = getElementTypeForFiber(fiber);\n      const {\n        _debugOwner\n      } = fiber; // Ideally we should call getFiberIDThrows() for _debugOwner,\n      // since owners are almost always higher in the tree (and so have already been processed),\n      // but in some (rare) instances reported in open source, a descendant mounts before an owner.\n      // Since this is a DEV only field it's probably okay to also just lazily generate and ID here if needed.\n      // See https://github.com/facebook/react/issues/21445\n\n      const ownerID = _debugOwner != null ? getOrGenerateFiberID(_debugOwner) : 0;\n      const parentID = parentFiber ? getFiberIDThrows(parentFiber) : 0;\n      const displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified\n      // in such a way as to bypass the default stringification of the \"key\" property.\n\n      const keyString = key === null ? null : String(key);\n      const keyStringID = getStringID(keyString);\n      pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_ADD\"]);\n      pushOperation(id);\n      pushOperation(elementType);\n      pushOperation(parentID);\n      pushOperation(ownerID);\n      pushOperation(displayNameStringID);\n      pushOperation(keyStringID); // If this subtree has a new mode, let the frontend know.\n\n      if ((fiber.mode & StrictModeBits) !== 0 && (parentFiber.mode & StrictModeBits) === 0) {\n        pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_SET_SUBTREE_MODE\"]);\n        pushOperation(id);\n        pushOperation(react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"StrictMode\"]);\n      }\n    }\n\n    if (isProfilingSupported) {\n      idToRootMap.set(id, currentRootID);\n      recordProfilingDurations(fiber);\n    }\n  }\n\n  function recordUnmount(fiber, isSimulated) {\n    if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n      debug('recordUnmount()', fiber, null, isSimulated ? 'unmount is simulated' : '');\n    }\n\n    if (trackedPathMatchFiber !== null) {\n      // We're in the process of trying to restore previous selection.\n      // If this fiber matched but is being unmounted, there's no use trying.\n      // Reset the state so we don't keep holding onto it.\n      if (fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {\n        setTrackedPath(null);\n      }\n    }\n\n    const unsafeID = getFiberIDUnsafe(fiber);\n\n    if (unsafeID === null) {\n      // If we've never seen this Fiber, it might be inside of a legacy render Suspense fragment (so the store is not even aware of it).\n      // In that case we can just ignore it or it will cause errors later on.\n      // One example of this is a Lazy component that never resolves before being unmounted.\n      //\n      // This also might indicate a Fast Refresh force-remount scenario.\n      //\n      // TODO: This is fragile and can obscure actual bugs.\n      return;\n    } // Flow refinement.\n\n\n    const id = unsafeID;\n    const isRoot = fiber.tag === HostRoot;\n\n    if (isRoot) {\n      // Roots must be removed only after all children (pending and simulated) have been removed.\n      // So we track it separately.\n      pendingUnmountedRootID = id;\n    } else if (!shouldFilterFiber(fiber)) {\n      // To maintain child-first ordering,\n      // we'll push it into one of these queues,\n      // and later arrange them in the correct order.\n      if (isSimulated) {\n        pendingSimulatedUnmountedIDs.push(id);\n      } else {\n        pendingRealUnmountedIDs.push(id);\n      }\n    }\n\n    if (!fiber._debugNeedsRemount) {\n      untrackFiberID(fiber);\n      const isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');\n\n      if (isProfilingSupported) {\n        idToRootMap.delete(id);\n        idToTreeBaseDurationMap.delete(id);\n      }\n    }\n  }\n\n  function mountFiberRecursively(firstChild, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {\n    // Iterate over siblings rather than recursing.\n    // This reduces the chance of stack overflow for wide trees (e.g. lists with many items).\n    let fiber = firstChild;\n\n    while (fiber !== null) {\n      // Generate an ID even for filtered Fibers, in case it's needed later (e.g. for Profiling).\n      getOrGenerateFiberID(fiber);\n\n      if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n        debug('mountFiberRecursively()', fiber, parentFiber);\n      } // If we have the tree selection from previous reload, try to match this Fiber.\n      // Also remember whether to do the same for siblings.\n\n\n      const mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);\n      const shouldIncludeInTree = !shouldFilterFiber(fiber);\n\n      if (shouldIncludeInTree) {\n        recordMount(fiber, parentFiber);\n      }\n\n      if (traceUpdatesEnabled) {\n        if (traceNearestHostComponentUpdate) {\n          const elementType = getElementTypeForFiber(fiber); // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n\n          if (elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeHostComponent\"]) {\n            traceUpdatesForNodes.add(fiber.stateNode);\n            traceNearestHostComponentUpdate = false;\n          }\n        } // We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,\n        // because we don't want to highlight every host node inside of a newly mounted subtree.\n\n      }\n\n      const isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;\n\n      if (isSuspense) {\n        const isTimedOut = fiber.memoizedState !== null;\n\n        if (isTimedOut) {\n          // Special case: if Suspense mounts in a timed-out state,\n          // get the fallback child from the inner fragment and mount\n          // it as if it was our own child. Updates handle this too.\n          const primaryChildFragment = fiber.child;\n          const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n          const fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;\n\n          if (fallbackChild !== null) {\n            mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n          }\n        } else {\n          let primaryChild = null;\n          const areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;\n\n          if (areSuspenseChildrenConditionallyWrapped) {\n            primaryChild = fiber.child;\n          } else if (fiber.child !== null) {\n            primaryChild = fiber.child.child;\n          }\n\n          if (primaryChild !== null) {\n            mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n          }\n        }\n      } else {\n        if (fiber.child !== null) {\n          mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n        }\n      } // We're exiting this Fiber now, and entering its siblings.\n      // If we have selection to restore, we might need to re-activate tracking.\n\n\n      updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);\n      fiber = traverseSiblings ? fiber.sibling : null;\n    }\n  } // We use this to simulate unmounting for Suspense trees\n  // when we switch from primary to fallback.\n\n\n  function unmountFiberChildrenRecursively(fiber) {\n    if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n      debug('unmountFiberChildrenRecursively()', fiber);\n    } // We might meet a nested Suspense on our way.\n\n\n    const isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent && fiber.memoizedState !== null;\n    let child = fiber.child;\n\n    if (isTimedOutSuspense) {\n      // If it's showing fallback tree, let's traverse it instead.\n      const primaryChildFragment = fiber.child;\n      const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null; // Skip over to the real Fiber child.\n\n      child = fallbackChildFragment ? fallbackChildFragment.child : null;\n    }\n\n    while (child !== null) {\n      // Record simulated unmounts children-first.\n      // We skip nodes without return because those are real unmounts.\n      if (child.return !== null) {\n        unmountFiberChildrenRecursively(child);\n        recordUnmount(child, true);\n      }\n\n      child = child.sibling;\n    }\n  }\n\n  function recordProfilingDurations(fiber) {\n    const id = getFiberIDThrows(fiber);\n    const {\n      actualDuration,\n      treeBaseDuration\n    } = fiber;\n    idToTreeBaseDurationMap.set(id, treeBaseDuration || 0);\n\n    if (isProfiling) {\n      const {\n        alternate\n      } = fiber; // It's important to update treeBaseDuration even if the current Fiber did not render,\n      // because it's possible that one of its descendants did.\n\n      if (alternate == null || treeBaseDuration !== alternate.treeBaseDuration) {\n        // Tree base duration updates are included in the operations typed array.\n        // So we have to convert them from milliseconds to microseconds so we can send them as ints.\n        const convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);\n        pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_UPDATE_TREE_BASE_DURATION\"]);\n        pushOperation(id);\n        pushOperation(convertedTreeBaseDuration);\n      }\n\n      if (alternate == null || didFiberRender(alternate, fiber)) {\n        if (actualDuration != null) {\n          // The actual duration reported by React includes time spent working on children.\n          // This is useful information, but it's also useful to be able to exclude child durations.\n          // The frontend can't compute this, since the immediate children may have been filtered out.\n          // So we need to do this on the backend.\n          // Note that this calculated self duration is not the same thing as the base duration.\n          // The two are calculated differently (tree duration does not accumulate).\n          let selfDuration = actualDuration;\n          let child = fiber.child;\n\n          while (child !== null) {\n            selfDuration -= child.actualDuration || 0;\n            child = child.sibling;\n          } // If profiling is active, store durations for elements that were rendered during the commit.\n          // Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.\n          // In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)\n          // In other cases (e.g. Memo) actualDuration might be greater than 0 even if we \"bailed out\".\n\n\n          const metadata = currentCommitProfilingMetadata;\n          metadata.durations.push(id, actualDuration, selfDuration);\n          metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);\n\n          if (recordChangeDescriptions) {\n            const changeDescription = getChangeDescription(alternate, fiber);\n\n            if (changeDescription !== null) {\n              if (metadata.changeDescriptions !== null) {\n                metadata.changeDescriptions.set(id, changeDescription);\n              }\n            }\n\n            updateContextsForFiber(fiber);\n          }\n        }\n      }\n    }\n  }\n\n  function recordResetChildren(fiber, childSet) {\n    if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n      debug('recordResetChildren()', childSet, fiber);\n    } // The frontend only really cares about the displayName, key, and children.\n    // The first two don't really change, so we are only concerned with the order of children here.\n    // This is trickier than a simple comparison though, since certain types of fibers are filtered.\n\n\n    const nextChildren = []; // This is a naive implementation that shallowly recourses children.\n    // We might want to revisit this if it proves to be too inefficient.\n\n    let child = childSet;\n\n    while (child !== null) {\n      findReorderedChildrenRecursively(child, nextChildren);\n      child = child.sibling;\n    }\n\n    const numChildren = nextChildren.length;\n\n    if (numChildren < 2) {\n      // No need to reorder.\n      return;\n    }\n\n    pushOperation(_constants__WEBPACK_IMPORTED_MODULE_5__[\"TREE_OPERATION_REORDER_CHILDREN\"]);\n    pushOperation(getFiberIDThrows(fiber));\n    pushOperation(numChildren);\n\n    for (let i = 0; i < nextChildren.length; i++) {\n      pushOperation(nextChildren[i]);\n    }\n  }\n\n  function findReorderedChildrenRecursively(fiber, nextChildren) {\n    if (!shouldFilterFiber(fiber)) {\n      nextChildren.push(getFiberIDThrows(fiber));\n    } else {\n      let child = fiber.child;\n      const isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;\n\n      if (isTimedOutSuspense) {\n        // Special case: if Suspense mounts in a timed-out state,\n        // get the fallback child from the inner fragment,\n        // and skip over the primary child.\n        const primaryChildFragment = fiber.child;\n        const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n        const fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;\n\n        if (fallbackChild !== null) {\n          child = fallbackChild;\n        }\n      }\n\n      while (child !== null) {\n        findReorderedChildrenRecursively(child, nextChildren);\n        child = child.sibling;\n      }\n    }\n  } // Returns whether closest unfiltered fiber parent needs to reset its child list.\n\n\n  function updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {\n    const id = getOrGenerateFiberID(nextFiber);\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_5__[\"__DEBUG__\"]) {\n      debug('updateFiberRecursively()', nextFiber, parentFiber);\n    }\n\n    if (traceUpdatesEnabled) {\n      const elementType = getElementTypeForFiber(nextFiber);\n\n      if (traceNearestHostComponentUpdate) {\n        // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n        if (elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeHostComponent\"]) {\n          traceUpdatesForNodes.add(nextFiber.stateNode);\n          traceNearestHostComponentUpdate = false;\n        }\n      } else {\n        if (elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeFunction\"] || elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"] || elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeContext\"] || elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeMemo\"] || elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeForwardRef\"]) {\n          // Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).\n          traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);\n        }\n      }\n    }\n\n    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id && didFiberRender(prevFiber, nextFiber)) {\n      // If this Fiber has updated, clear cached inspected data.\n      // If it is inspected again, it may need to be re-run to obtain updated hooks values.\n      hasElementUpdatedSinceLastInspected = true;\n    }\n\n    const shouldIncludeInTree = !shouldFilterFiber(nextFiber);\n    const isSuspense = nextFiber.tag === SuspenseComponent;\n    let shouldResetChildren = false; // The behavior of timed-out Suspense trees is unique.\n    // Rather than unmount the timed out content (and possibly lose important state),\n    // React re-parents this content within a hidden Fragment while the fallback is showing.\n    // This behavior doesn't need to be observable in the DevTools though.\n    // It might even result in a bad user experience for e.g. node selection in the Elements panel.\n    // The easiest fix is to strip out the intermediate Fragment fibers,\n    // so the Elements panel and Profiler don't need to special case them.\n    // Suspense components only have a non-null memoizedState if they're timed-out.\n\n    const prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;\n    const nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null; // The logic below is inspired by the code paths in updateSuspenseComponent()\n    // inside ReactFiberBeginWork in the React source code.\n\n    if (prevDidTimeout && nextDidTimeOut) {\n      // Fallback -> Fallback:\n      // 1. Reconcile fallback set.\n      const nextFiberChild = nextFiber.child;\n      const nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null; // Note: We can't use nextFiber.child.sibling.alternate\n      // because the set is special and alternate may not exist.\n\n      const prevFiberChild = prevFiber.child;\n      const prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;\n\n      if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {\n        shouldResetChildren = true;\n      }\n    } else if (prevDidTimeout && !nextDidTimeOut) {\n      // Fallback -> Primary:\n      // 1. Unmount fallback set\n      // Note: don't emulate fallback unmount because React actually did it.\n      // 2. Mount primary set\n      const nextPrimaryChildSet = nextFiber.child;\n\n      if (nextPrimaryChildSet !== null) {\n        mountFiberRecursively(nextPrimaryChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);\n      }\n\n      shouldResetChildren = true;\n    } else if (!prevDidTimeout && nextDidTimeOut) {\n      // Primary -> Fallback:\n      // 1. Hide primary set\n      // This is not a real unmount, so it won't get reported by React.\n      // We need to manually walk the previous tree and record unmounts.\n      unmountFiberChildrenRecursively(prevFiber); // 2. Mount fallback set\n\n      const nextFiberChild = nextFiber.child;\n      const nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null;\n\n      if (nextFallbackChildSet != null) {\n        mountFiberRecursively(nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);\n        shouldResetChildren = true;\n      }\n    } else {\n      // Common case: Primary -> Primary.\n      // This is the same code path as for non-Suspense fibers.\n      if (nextFiber.child !== prevFiber.child) {\n        // If the first child is different, we need to traverse them.\n        // Each next child will be either a new child (mount) or an alternate (update).\n        let nextChild = nextFiber.child;\n        let prevChildAtSameIndex = prevFiber.child;\n\n        while (nextChild) {\n          // We already know children will be referentially different because\n          // they are either new mounts or alternates of previous children.\n          // Schedule updates and mounts depending on whether alternates exist.\n          // We don't track deletions here because they are reported separately.\n          if (nextChild.alternate) {\n            const prevChild = nextChild.alternate;\n\n            if (updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {\n              // If a nested tree child order changed but it can't handle its own\n              // child order invalidation (e.g. because it's filtered out like host nodes),\n              // propagate the need to reset child order upwards to this Fiber.\n              shouldResetChildren = true;\n            } // However we also keep track if the order of the children matches\n            // the previous order. They are always different referentially, but\n            // if the instances line up conceptually we'll want to know that.\n\n\n            if (prevChild !== prevChildAtSameIndex) {\n              shouldResetChildren = true;\n            }\n          } else {\n            mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, false, traceNearestHostComponentUpdate);\n            shouldResetChildren = true;\n          } // Try the next child.\n\n\n          nextChild = nextChild.sibling; // Advance the pointer in the previous list so that we can\n          // keep comparing if they line up.\n\n          if (!shouldResetChildren && prevChildAtSameIndex !== null) {\n            prevChildAtSameIndex = prevChildAtSameIndex.sibling;\n          }\n        } // If we have no more children, but used to, they don't line up.\n\n\n        if (prevChildAtSameIndex !== null) {\n          shouldResetChildren = true;\n        }\n      } else {\n        if (traceUpdatesEnabled) {\n          // If we're tracing updates and we've bailed out before reaching a host node,\n          // we should fall back to recursively marking the nearest host descendants for highlight.\n          if (traceNearestHostComponentUpdate) {\n            const hostFibers = findAllCurrentHostFibers(getFiberIDThrows(nextFiber));\n            hostFibers.forEach(hostFiber => {\n              traceUpdatesForNodes.add(hostFiber.stateNode);\n            });\n          }\n        }\n      }\n    }\n\n    if (shouldIncludeInTree) {\n      const isProfilingSupported = nextFiber.hasOwnProperty('treeBaseDuration');\n\n      if (isProfilingSupported) {\n        recordProfilingDurations(nextFiber);\n      }\n    }\n\n    if (shouldResetChildren) {\n      // We need to crawl the subtree for closest non-filtered Fibers\n      // so that we can display them in a flat children set.\n      if (shouldIncludeInTree) {\n        // Normally, search for children from the rendered child.\n        let nextChildSet = nextFiber.child;\n\n        if (nextDidTimeOut) {\n          // Special case: timed-out Suspense renders the fallback set.\n          const nextFiberChild = nextFiber.child;\n          nextChildSet = nextFiberChild ? nextFiberChild.sibling : null;\n        }\n\n        if (nextChildSet != null) {\n          recordResetChildren(nextFiber, nextChildSet);\n        } // We've handled the child order change for this Fiber.\n        // Since it's included, there's no need to invalidate parent child order.\n\n\n        return false;\n      } else {\n        // Let the closest unfiltered parent Fiber reset its child order instead.\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  function cleanup() {// We don't patch any methods so there is no cleanup.\n  }\n\n  function rootSupportsProfiling(root) {\n    if (root.memoizedInteractions != null) {\n      // v16 builds include this field for the scheduler/tracing API.\n      return true;\n    } else if (root.current != null && root.current.hasOwnProperty('treeBaseDuration')) {\n      // The scheduler/tracing API was removed in v17 though\n      // so we need to check a non-root Fiber.\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function flushInitialOperations() {\n    const localPendingOperationsQueue = pendingOperationsQueue;\n    pendingOperationsQueue = null;\n\n    if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {\n      // We may have already queued up some operations before the frontend connected\n      // If so, let the frontend know about them.\n      localPendingOperationsQueue.forEach(operations => {\n        hook.emit('operations', operations);\n      });\n    } else {\n      // Before the traversals, remember to start tracking\n      // our path in case we have selection to restore.\n      if (trackedPath !== null) {\n        mightBeOnTrackedPath = true;\n      } // If we have not been profiling, then we can just walk the tree and build up its current state as-is.\n\n\n      hook.getFiberRoots(rendererID).forEach(root => {\n        currentRootID = getOrGenerateFiberID(root.current);\n        setRootPseudoKey(currentRootID, root.current); // Handle multi-renderer edge-case where only some v16 renderers support profiling.\n\n        if (isProfiling && rootSupportsProfiling(root)) {\n          // If profiling is active, store commit time and duration.\n          // The frontend may request this information after profiling has stopped.\n          currentCommitProfilingMetadata = {\n            changeDescriptions: recordChangeDescriptions ? new Map() : null,\n            durations: [],\n            commitTime: getCurrentTime() - profilingStartTime,\n            maxActualDuration: 0,\n            priorityLevel: null,\n            updaters: getUpdatersList(root),\n            effectDuration: null,\n            passiveEffectDuration: null\n          };\n        }\n\n        mountFiberRecursively(root.current, null, false, false);\n        flushPendingEvents(root);\n        currentRootID = -1;\n      });\n    }\n  }\n\n  function getUpdatersList(root) {\n    return root.memoizedUpdaters != null ? Array.from(root.memoizedUpdaters).map(fiberToSerializedElement) : null;\n  }\n\n  function handleCommitFiberUnmount(fiber) {\n    // This is not recursive.\n    // We can't traverse fibers after unmounting so instead\n    // we rely on React telling us about each unmount.\n    recordUnmount(fiber, false);\n  }\n\n  function handlePostCommitFiberRoot(root) {\n    if (isProfiling && rootSupportsProfiling(root)) {\n      if (currentCommitProfilingMetadata !== null) {\n        const {\n          effectDuration,\n          passiveEffectDuration\n        } = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"getEffectDurations\"])(root);\n        currentCommitProfilingMetadata.effectDuration = effectDuration;\n        currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;\n      }\n    }\n  }\n\n  function handleCommitFiberRoot(root, priorityLevel) {\n    const current = root.current;\n    const alternate = current.alternate; // Flush any pending Fibers that we are untracking before processing the new commit.\n    // If we don't do this, we might end up double-deleting Fibers in some cases (like Legacy Suspense).\n\n    untrackFibers();\n    currentRootID = getOrGenerateFiberID(current); // Before the traversals, remember to start tracking\n    // our path in case we have selection to restore.\n\n    if (trackedPath !== null) {\n      mightBeOnTrackedPath = true;\n    }\n\n    if (traceUpdatesEnabled) {\n      traceUpdatesForNodes.clear();\n    } // Handle multi-renderer edge-case where only some v16 renderers support profiling.\n\n\n    const isProfilingSupported = rootSupportsProfiling(root);\n\n    if (isProfiling && isProfilingSupported) {\n      // If profiling is active, store commit time and duration.\n      // The frontend may request this information after profiling has stopped.\n      currentCommitProfilingMetadata = {\n        changeDescriptions: recordChangeDescriptions ? new Map() : null,\n        durations: [],\n        commitTime: getCurrentTime() - profilingStartTime,\n        maxActualDuration: 0,\n        priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel),\n        updaters: getUpdatersList(root),\n        // Initialize to null; if new enough React version is running,\n        // these values will be read during separate handlePostCommitFiberRoot() call.\n        effectDuration: null,\n        passiveEffectDuration: null\n      };\n    }\n\n    if (alternate) {\n      // TODO: relying on this seems a bit fishy.\n      const wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\n      const isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n      if (!wasMounted && isMounted) {\n        // Mount a new root.\n        setRootPseudoKey(currentRootID, current);\n        mountFiberRecursively(current, null, false, false);\n      } else if (wasMounted && isMounted) {\n        // Update an existing root.\n        updateFiberRecursively(current, alternate, null, false);\n      } else if (wasMounted && !isMounted) {\n        // Unmount an existing root.\n        removeRootPseudoKey(currentRootID);\n        recordUnmount(current, false);\n      }\n    } else {\n      // Mount a new root.\n      setRootPseudoKey(currentRootID, current);\n      mountFiberRecursively(current, null, false, false);\n    }\n\n    if (isProfiling && isProfilingSupported) {\n      // Make sure at least one Fiber performed work during this commit.\n      // If not, don't send it to the frontend; showing an empty commit in the Profiler is confusing.\n      if (currentCommitProfilingMetadata != null && currentCommitProfilingMetadata.durations.length > 0) {\n        const commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);\n\n        if (commitProfilingMetadata != null) {\n          commitProfilingMetadata.push(currentCommitProfilingMetadata);\n        } else {\n          rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);\n        }\n      }\n    } // We're done here.\n\n\n    flushPendingEvents(root);\n\n    if (traceUpdatesEnabled) {\n      hook.emit('traceUpdates', traceUpdatesForNodes);\n    }\n\n    currentRootID = -1;\n  }\n\n  function findAllCurrentHostFibers(id) {\n    const fibers = [];\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (!fiber) {\n      return fibers;\n    } // Next we'll drill down this component to find all HostComponent/Text.\n\n\n    let node = fiber;\n\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        fibers.push(node);\n      } else if (node.child) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === fiber) {\n        return fibers;\n      }\n\n      while (!node.sibling) {\n        if (!node.return || node.return === fiber) {\n          return fibers;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    } // Flow needs the return here, but ESLint complains about it.\n    // eslint-disable-next-line no-unreachable\n\n\n    return fibers;\n  }\n\n  function findNativeNodesForFiberID(id) {\n    try {\n      let fiber = findCurrentFiberUsingSlowPathById(id);\n\n      if (fiber === null) {\n        return null;\n      } // Special case for a timed-out Suspense.\n\n\n      const isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;\n\n      if (isTimedOutSuspense) {\n        // A timed-out Suspense's findDOMNode is useless.\n        // Try our best to find the fallback directly.\n        const maybeFallbackFiber = fiber.child && fiber.child.sibling;\n\n        if (maybeFallbackFiber != null) {\n          fiber = maybeFallbackFiber;\n        }\n      }\n\n      const hostFibers = findAllCurrentHostFibers(id);\n      return hostFibers.map(hostFiber => hostFiber.stateNode).filter(Boolean);\n    } catch (err) {\n      // The fiber might have unmounted by now.\n      return null;\n    }\n  }\n\n  function getDisplayNameForFiberID(id) {\n    const fiber = idToArbitraryFiberMap.get(id);\n    return fiber != null ? getDisplayNameForFiber(fiber) : null;\n  }\n\n  function getFiberIDForNative(hostInstance, findNearestUnfilteredAncestor = false) {\n    let fiber = renderer.findFiberByHostInstance(hostInstance);\n\n    if (fiber != null) {\n      if (findNearestUnfilteredAncestor) {\n        while (fiber !== null && shouldFilterFiber(fiber)) {\n          fiber = fiber.return;\n        }\n      }\n\n      return getFiberIDThrows(fiber);\n    }\n\n    return null;\n  } // This function is copied from React and should be kept in sync:\n  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js\n\n\n  function assertIsMounted(fiber) {\n    if (getNearestMountedFiber(fiber) !== fiber) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n  } // This function is copied from React and should be kept in sync:\n  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js\n\n\n  function getNearestMountedFiber(fiber) {\n    let node = fiber;\n    let nearestMounted = fiber;\n\n    if (!fiber.alternate) {\n      // If there is no alternate, this might be a new tree that isn't inserted\n      // yet. If it is, then it will have a pending insertion effect on it.\n      let nextNode = node;\n\n      do {\n        node = nextNode;\n\n        if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n          // This is an insertion or in-progress hydration. The nearest possible\n          // mounted fiber is the parent but we need to continue to figure out\n          // if that one is still mounted.\n          nearestMounted = node.return;\n        }\n\n        nextNode = node.return;\n      } while (nextNode);\n    } else {\n      while (node.return) {\n        node = node.return;\n      }\n    }\n\n    if (node.tag === HostRoot) {\n      // TODO: Check if this was a nested HostRoot when used with\n      // renderContainerIntoSubtree.\n      return nearestMounted;\n    } // If we didn't hit the root, that means that we're in an disconnected tree\n    // that has been unmounted.\n\n\n    return null;\n  } // This function is copied from React and should be kept in sync:\n  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js\n  // It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).\n  // BEGIN copied code\n\n\n  function findCurrentFiberUsingSlowPathById(id) {\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      console.warn(`Could not find Fiber with id \"${id}\"`);\n      return null;\n    }\n\n    const alternate = fiber.alternate;\n\n    if (!alternate) {\n      // If there is no alternate, then we only need to check if it is mounted.\n      const nearestMounted = getNearestMountedFiber(fiber);\n\n      if (nearestMounted === null) {\n        throw new Error('Unable to find node on an unmounted component.');\n      }\n\n      if (nearestMounted !== fiber) {\n        return null;\n      }\n\n      return fiber;\n    } // If we have two possible branches, we'll walk backwards up to the root\n    // to see what path the root points to. On the way we may hit one of the\n    // special cases and we'll deal with them.\n\n\n    let a = fiber;\n    let b = alternate;\n\n    while (true) {\n      const parentA = a.return;\n\n      if (parentA === null) {\n        // We're at the root.\n        break;\n      }\n\n      const parentB = parentA.alternate;\n\n      if (parentB === null) {\n        // There is no alternate. This is an unusual case. Currently, it only\n        // happens when a Suspense component is hidden. An extra fragment fiber\n        // is inserted in between the Suspense fiber and its children. Skip\n        // over this extra fragment fiber and proceed to the next parent.\n        const nextParent = parentA.return;\n\n        if (nextParent !== null) {\n          a = b = nextParent;\n          continue;\n        } // If there's no parent, we're at the root.\n\n\n        break;\n      } // If both copies of the parent fiber point to the same child, we can\n      // assume that the child is current. This happens when we bailout on low\n      // priority: the bailed out fiber's child reuses the current child.\n\n\n      if (parentA.child === parentB.child) {\n        let child = parentA.child;\n\n        while (child) {\n          if (child === a) {\n            // We've determined that A is the current branch.\n            assertIsMounted(parentA);\n            return fiber;\n          }\n\n          if (child === b) {\n            // We've determined that B is the current branch.\n            assertIsMounted(parentA);\n            return alternate;\n          }\n\n          child = child.sibling;\n        } // We should never have an alternate for any mounting node. So the only\n        // way this could possibly happen is if this was unmounted, if at all.\n\n\n        throw new Error('Unable to find node on an unmounted component.');\n      }\n\n      if (a.return !== b.return) {\n        // The return pointer of A and the return pointer of B point to different\n        // fibers. We assume that return pointers never criss-cross, so A must\n        // belong to the child set of A.return, and B must belong to the child\n        // set of B.return.\n        a = parentA;\n        b = parentB;\n      } else {\n        // The return pointers point to the same fiber. We'll have to use the\n        // default, slow path: scan the child sets of each parent alternate to see\n        // which child belongs to which set.\n        //\n        // Search parent A's child set\n        let didFindChild = false;\n        let child = parentA.child;\n\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentA;\n            b = parentB;\n            break;\n          }\n\n          if (child === b) {\n            didFindChild = true;\n            b = parentA;\n            a = parentB;\n            break;\n          }\n\n          child = child.sibling;\n        }\n\n        if (!didFindChild) {\n          // Search parent B's child set\n          child = parentB.child;\n\n          while (child) {\n            if (child === a) {\n              didFindChild = true;\n              a = parentB;\n              b = parentA;\n              break;\n            }\n\n            if (child === b) {\n              didFindChild = true;\n              b = parentB;\n              a = parentA;\n              break;\n            }\n\n            child = child.sibling;\n          }\n\n          if (!didFindChild) {\n            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n          }\n        }\n      }\n\n      if (a.alternate !== b) {\n        throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } // If the root is not a host container, we're in a disconnected tree. I.e.\n    // unmounted.\n\n\n    if (a.tag !== HostRoot) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.stateNode.current === a) {\n      // We've determined that A is the current branch.\n      return fiber;\n    } // Otherwise B has to be current branch.\n\n\n    return alternate;\n  } // END copied code\n\n\n  function prepareViewAttributeSource(id, path) {\n    if (isMostRecentlyInspectedElement(id)) {\n      window.$attribute = Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getInObject\"])(mostRecentlyInspectedElement, path);\n    }\n  }\n\n  function prepareViewElementSource(id) {\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      console.warn(`Could not find Fiber with id \"${id}\"`);\n      return;\n    }\n\n    const {\n      elementType,\n      tag,\n      type\n    } = fiber;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n      case IndeterminateComponent:\n      case FunctionComponent:\n        global.$type = type;\n        break;\n\n      case ForwardRef:\n        global.$type = type.render;\n        break;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        global.$type = elementType != null && elementType.type != null ? elementType.type : type;\n        break;\n\n      default:\n        global.$type = null;\n        break;\n    }\n  }\n\n  function fiberToSerializedElement(fiber) {\n    return {\n      displayName: getDisplayNameForFiber(fiber) || 'Anonymous',\n      id: getFiberIDThrows(fiber),\n      key: fiber.key,\n      type: getElementTypeForFiber(fiber)\n    };\n  }\n\n  function getOwnersList(id) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber == null) {\n      return null;\n    }\n\n    const {\n      _debugOwner\n    } = fiber;\n    const owners = [fiberToSerializedElement(fiber)];\n\n    if (_debugOwner) {\n      let owner = _debugOwner;\n\n      while (owner !== null) {\n        owners.unshift(fiberToSerializedElement(owner));\n        owner = owner._debugOwner || null;\n      }\n    }\n\n    return owners;\n  } // Fast path props lookup for React Native style editor.\n  // Could use inspectElementRaw() but that would require shallow rendering hooks components,\n  // and could also mess with memoization.\n\n\n  function getInstanceAndStyle(id) {\n    let instance = null;\n    let style = null;\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      instance = fiber.stateNode;\n\n      if (fiber.memoizedProps !== null) {\n        style = fiber.memoizedProps.style;\n      }\n    }\n\n    return {\n      instance,\n      style\n    };\n  }\n\n  function isErrorBoundary(fiber) {\n    const {\n      tag,\n      type\n    } = fiber;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n        const instance = fiber.stateNode;\n        return typeof type.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function';\n\n      default:\n        return false;\n    }\n  }\n\n  function getNearestErrorBoundaryID(fiber) {\n    let parent = fiber.return;\n\n    while (parent !== null) {\n      if (isErrorBoundary(parent)) {\n        return getFiberIDUnsafe(parent);\n      }\n\n      parent = parent.return;\n    }\n\n    return null;\n  }\n\n  function inspectElementRaw(id) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber == null) {\n      return null;\n    }\n\n    const {\n      _debugOwner,\n      _debugSource,\n      stateNode,\n      key,\n      memoizedProps,\n      memoizedState,\n      dependencies,\n      tag,\n      type\n    } = fiber;\n    const elementType = getElementTypeForFiber(fiber);\n    const usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies); // TODO Show custom UI for Cache like we do for Suspense\n    // For now, just hide state data entirely since it's not meant to be inspected.\n\n    const showState = !usesHooks && tag !== CacheComponent;\n    const typeSymbol = getTypeSymbol(type);\n    let canViewSource = false;\n    let context = null;\n\n    if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {\n      canViewSource = true;\n\n      if (stateNode && stateNode.context != null) {\n        // Don't show an empty context object for class components that don't use the context API.\n        const shouldHideContext = elementType === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_1__[\"ElementTypeClass\"] && !(type.contextTypes || type.contextType);\n\n        if (!shouldHideContext) {\n          context = stateNode.context;\n        }\n      }\n    } else if (typeSymbol === _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_NUMBER\"] || typeSymbol === _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"CONTEXT_SYMBOL_STRING\"]) {\n      // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n      // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n      // NOTE Keep in sync with getDisplayNameForFiber()\n      const consumerResolvedContext = type._context || type; // Global context value.\n\n      context = consumerResolvedContext._currentValue || null; // Look for overridden value.\n\n      let current = fiber.return;\n\n      while (current !== null) {\n        const currentType = current.type;\n        const currentTypeSymbol = getTypeSymbol(currentType);\n\n        if (currentTypeSymbol === _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_NUMBER\"] || currentTypeSymbol === _ReactSymbols__WEBPACK_IMPORTED_MODULE_8__[\"PROVIDER_SYMBOL_STRING\"]) {\n          // 16.3.0 exposed the context object as \"context\"\n          // PR #12501 changed it to \"_context\" for 16.3.1+\n          // NOTE Keep in sync with getDisplayNameForFiber()\n          const providerResolvedContext = currentType._context || currentType.context;\n\n          if (providerResolvedContext === consumerResolvedContext) {\n            context = current.memoizedProps.value;\n            break;\n          }\n        }\n\n        current = current.return;\n      }\n    }\n\n    let hasLegacyContext = false;\n\n    if (context !== null) {\n      hasLegacyContext = !!type.contextTypes; // To simplify hydration and display logic for context, wrap in a value object.\n      // Otherwise simple values (e.g. strings, booleans) become harder to handle.\n\n      context = {\n        value: context\n      };\n    }\n\n    let owners = null;\n\n    if (_debugOwner) {\n      owners = [];\n      let owner = _debugOwner;\n\n      while (owner !== null) {\n        owners.push(fiberToSerializedElement(owner));\n        owner = owner._debugOwner || null;\n      }\n    }\n\n    const isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;\n    let hooks = null;\n\n    if (usesHooks) {\n      const originalConsoleMethods = {}; // Temporarily disable all console logging before re-running the hook.\n\n      for (const method in console) {\n        try {\n          originalConsoleMethods[method] = console[method]; // $FlowFixMe property error|warn is not writable.\n\n          console[method] = () => {};\n        } catch (error) {}\n      }\n\n      try {\n        hooks = Object(react_debug_tools__WEBPACK_IMPORTED_MODULE_6__[\"inspectHooksOfFiber\"])(fiber, renderer.currentDispatcherRef, true // Include source location info for hooks\n        );\n      } finally {\n        // Restore original console functionality.\n        for (const method in originalConsoleMethods) {\n          try {\n            // $FlowFixMe property error|warn is not writable.\n            console[method] = originalConsoleMethods[method];\n          } catch (error) {}\n        }\n      }\n    }\n\n    let rootType = null;\n    let current = fiber;\n\n    while (current.return !== null) {\n      current = current.return;\n    }\n\n    const fiberRoot = current.stateNode;\n\n    if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n      rootType = fiberRoot._debugRootType;\n    }\n\n    const errors = fiberIDToErrorsMap.get(id) || new Map();\n    const warnings = fiberIDToWarningsMap.get(id) || new Map();\n    const isErrored = (fiber.flags & DidCapture) !== NoFlags || forceErrorForFiberIDs.get(id) === true;\n    let targetErrorBoundaryID;\n\n    if (isErrorBoundary(fiber)) {\n      // if the current inspected element is an error boundary,\n      // either that we want to use it to toggle off error state\n      // or that we allow to force error state on it if it's within another\n      // error boundary\n      targetErrorBoundaryID = isErrored ? id : getNearestErrorBoundaryID(fiber);\n    } else {\n      targetErrorBoundaryID = getNearestErrorBoundaryID(fiber);\n    }\n\n    const plugins = {\n      stylex: null\n    };\n\n    if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_9__[\"enableStyleXFeatures\"]) {\n      if (memoizedProps.hasOwnProperty('xstyle')) {\n        plugins.stylex = Object(_StyleX_utils__WEBPACK_IMPORTED_MODULE_13__[\"getStyleXData\"])(memoizedProps.xstyle);\n      }\n    }\n\n    return {\n      id,\n      // Does the current renderer support editable hooks and function props?\n      canEditHooks: typeof overrideHookState === 'function',\n      canEditFunctionProps: typeof overrideProps === 'function',\n      // Does the current renderer support advanced editing interface?\n      canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === 'function',\n      canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === 'function',\n      canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === 'function',\n      canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === 'function',\n      canToggleError: supportsTogglingError && targetErrorBoundaryID != null,\n      // Is this error boundary in error state.\n      isErrored,\n      targetErrorBoundaryID,\n      canToggleSuspense: supportsTogglingSuspense && ( // If it's showing the real content, we can always flip fallback.\n      !isTimedOutSuspense || // If it's showing fallback because we previously forced it to,\n      // allow toggling it back to remove the fallback override.\n      forceFallbackForSuspenseIDs.has(id)),\n      // Can view component source location.\n      canViewSource,\n      // Does the component have legacy context attached to it.\n      hasLegacyContext,\n      key: key != null ? key : null,\n      displayName: getDisplayNameForFiber(fiber),\n      type: elementType,\n      // Inspectable properties.\n      // TODO Review sanitization approach for the below inspectable values.\n      context,\n      hooks,\n      props: memoizedProps,\n      state: showState ? memoizedState : null,\n      errors: Array.from(errors.entries()),\n      warnings: Array.from(warnings.entries()),\n      // List of owners\n      owners,\n      // Location of component in source code.\n      source: _debugSource || null,\n      rootType,\n      rendererPackageName: renderer.rendererPackageName,\n      rendererVersion: renderer.version,\n      plugins\n    };\n  }\n\n  let mostRecentlyInspectedElement = null;\n  let hasElementUpdatedSinceLastInspected = false;\n  let currentlyInspectedPaths = {};\n\n  function isMostRecentlyInspectedElement(id) {\n    return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id;\n  }\n\n  function isMostRecentlyInspectedElementCurrent(id) {\n    return isMostRecentlyInspectedElement(id) && !hasElementUpdatedSinceLastInspected;\n  } // Track the intersection of currently inspected paths,\n  // so that we can send their data along if the element is re-rendered.\n\n\n  function mergeInspectedPaths(path) {\n    let current = currentlyInspectedPaths;\n    path.forEach(key => {\n      if (!current[key]) {\n        current[key] = {};\n      }\n\n      current = current[key];\n    });\n  }\n\n  function createIsPathAllowed(key, secondaryCategory) {\n    // This function helps prevent previously-inspected paths from being dehydrated in updates.\n    // This is important to avoid a bad user experience where expanded toggles collapse on update.\n    return function isPathAllowed(path) {\n      switch (secondaryCategory) {\n        case 'hooks':\n          if (path.length === 1) {\n            // Never dehydrate the \"hooks\" object at the top levels.\n            return true;\n          }\n\n          if (path[path.length - 2] === 'hookSource' && path[path.length - 1] === 'fileName') {\n            // It's important to preserve the full file name (URL) for hook sources\n            // in case the user has enabled the named hooks feature.\n            // Otherwise the frontend may end up with a partial URL which it can't load.\n            return true;\n          }\n\n          if (path[path.length - 1] === 'subHooks' || path[path.length - 2] === 'subHooks') {\n            // Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,\n            // so it's easiest for now if we just don't break on this boundary.\n            // We can always dehydrate a level deeper (in the value object).\n            return true;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      let current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];\n\n      if (!current) {\n        return false;\n      }\n\n      for (let i = 0; i < path.length; i++) {\n        current = current[path[i]];\n\n        if (!current) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  }\n\n  function updateSelectedElement(inspectedElement) {\n    const {\n      hooks,\n      id,\n      props\n    } = inspectedElement;\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      console.warn(`Could not find Fiber with id \"${id}\"`);\n      return;\n    }\n\n    const {\n      elementType,\n      stateNode,\n      tag,\n      type\n    } = fiber;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n      case IndeterminateComponent:\n        global.$r = stateNode;\n        break;\n\n      case FunctionComponent:\n        global.$r = {\n          hooks,\n          props,\n          type\n        };\n        break;\n\n      case ForwardRef:\n        global.$r = {\n          hooks,\n          props,\n          type: type.render\n        };\n        break;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        global.$r = {\n          hooks,\n          props,\n          type: elementType != null && elementType.type != null ? elementType.type : type\n        };\n        break;\n\n      default:\n        global.$r = null;\n        break;\n    }\n  }\n\n  function storeAsGlobal(id, path, count) {\n    if (isMostRecentlyInspectedElement(id)) {\n      const value = Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getInObject\"])(mostRecentlyInspectedElement, path);\n      const key = `$reactTemp${count}`;\n      window[key] = value;\n      console.log(key);\n      console.log(value);\n    }\n  }\n\n  function copyElementPath(id, path) {\n    if (isMostRecentlyInspectedElement(id)) {\n      Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"copyToClipboard\"])(Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getInObject\"])(mostRecentlyInspectedElement, path));\n    }\n  }\n\n  function inspectElement(requestID, id, path, forceFullData) {\n    if (path !== null) {\n      mergeInspectedPaths(path);\n    }\n\n    if (isMostRecentlyInspectedElement(id) && !forceFullData) {\n      if (!hasElementUpdatedSinceLastInspected) {\n        if (path !== null) {\n          let secondaryCategory = null;\n\n          if (path[0] === 'hooks') {\n            secondaryCategory = 'hooks';\n          } // If this element has not been updated since it was last inspected,\n          // we can just return the subset of data in the newly-inspected path.\n\n\n          return {\n            id,\n            responseID: requestID,\n            type: 'hydrated-path',\n            path,\n            value: Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"getInObject\"])(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)\n          };\n        } else {\n          // If this element has not been updated since it was last inspected, we don't need to return it.\n          // Instead we can just return the ID to indicate that it has not changed.\n          return {\n            id,\n            responseID: requestID,\n            type: 'no-change'\n          };\n        }\n      }\n    } else {\n      currentlyInspectedPaths = {};\n    }\n\n    hasElementUpdatedSinceLastInspected = false;\n\n    try {\n      mostRecentlyInspectedElement = inspectElementRaw(id);\n    } catch (error) {\n      console.error('Error inspecting element.\\n\\n', error);\n      return {\n        type: 'error',\n        id,\n        responseID: requestID,\n        message: error.message,\n        stack: error.stack\n      };\n    }\n\n    if (mostRecentlyInspectedElement === null) {\n      return {\n        id,\n        responseID: requestID,\n        type: 'not-found'\n      };\n    } // Any time an inspected element has an update,\n    // we should update the selected $r value as wel.\n    // Do this before dehydration (cleanForBridge).\n\n\n    updateSelectedElement(mostRecentlyInspectedElement); // Clone before cleaning so that we preserve the full data.\n    // This will enable us to send patches without re-inspecting if hydrated paths are requested.\n    // (Reducing how often we shallow-render is a better DX for function components that use hooks.)\n\n    const cleanedInspectedElement = { ...mostRecentlyInspectedElement\n    };\n    cleanedInspectedElement.context = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(cleanedInspectedElement.context, createIsPathAllowed('context', null));\n    cleanedInspectedElement.hooks = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(cleanedInspectedElement.hooks, createIsPathAllowed('hooks', 'hooks'));\n    cleanedInspectedElement.props = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(cleanedInspectedElement.props, createIsPathAllowed('props', null));\n    cleanedInspectedElement.state = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"cleanForBridge\"])(cleanedInspectedElement.state, createIsPathAllowed('state', null));\n    return {\n      id,\n      responseID: requestID,\n      type: 'full-data',\n      value: cleanedInspectedElement\n    };\n  }\n\n  function logElementToConsole(id) {\n    function fiberToNode(fiber) {\n      if (fiber.tag === HostText) {\n        return undefined;\n      }\n\n      const id = fiberToSerializedElement(fiber).id;\n      const rawElement = inspectElementRaw(id);\n      const node = {\n        id: id.toString(),\n        name: rawElement.displayName\n      };\n\n      if (rawElement.owners) {\n        node.owner = rawElement.owners[0].id.toString();\n      }\n\n      node.children = [];\n      let childFiber = fiber.child;\n\n      while (childFiber) {\n        const childNode = fiberToNode(childFiber);\n\n        if (childNode) {\n          node.children.push(childNode);\n        }\n\n        childFiber = childFiber.sibling;\n      }\n\n      return node;\n    } // console.log('backend renderer');\n\n\n    const result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);\n\n    if (result === null) {\n      console.warn(`Could not find Fiber with id \"${id}\"`);\n      return;\n    }\n\n    const tree = fiberToNode(findCurrentFiberUsingSlowPathById(result.id));\n    console.log('Copy this:', tree); // const supportsGroup = typeof console.groupCollapsed === 'function';\n    // if (supportsGroup) {\n    //   console.groupCollapsed(\n    //     `[Click to expand] %c<${result.displayName || 'Component'} />`,\n    //     // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.\n    //     'color: var(--dom-tag-name-color); font-weight: normal;',\n    //   );\n    // }\n    // if (result.props !== null) {\n    //   console.log('Props:', result.props);\n    // }\n    // if (result.state !== null) {\n    //   console.log('State:', result.state);\n    // }\n    // if (result.hooks !== null) {\n    //   console.log('Hooks:', result.hooks);\n    // }\n    // const nativeNodes = findNativeNodesForFiberID(id);\n    // if (nativeNodes !== null) {\n    //   console.log('Nodes:', nativeNodes);\n    // }\n    // if (result.source !== null) {\n    //   console.log('Location:', result.source);\n    // }\n    // if (window.chrome || /firefox/i.test(navigator.userAgent)) {\n    //   console.log(\n    //     'Right-click any value to save it as a global variable for further inspection.',\n    //   );\n    // }\n    // if (supportsGroup) {\n    //   console.groupEnd();\n    // }\n  }\n\n  function deletePath(type, id, hookID, path) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      const instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          path = path.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (path.length === 0) {// Simple context value (noop)\n              } else {\n                Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"deletePathInObject\"])(instance.context, path);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookStateDeletePath === 'function') {\n            overrideHookStateDeletePath(fiber, hookID, path);\n          }\n\n          break;\n\n        case 'props':\n          if (instance === null) {\n            if (typeof overridePropsDeletePath === 'function') {\n              overridePropsDeletePath(fiber, path);\n            }\n          } else {\n            fiber.pendingProps = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"copyWithDelete\"])(instance.props, path);\n            instance.forceUpdate();\n          }\n\n          break;\n\n        case 'state':\n          Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"deletePathInObject\"])(instance.state, path);\n          instance.forceUpdate();\n          break;\n      }\n    }\n  }\n\n  function renamePath(type, id, hookID, oldPath, newPath) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      const instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          oldPath = oldPath.slice(1);\n          newPath = newPath.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (oldPath.length === 0) {// Simple context value (noop)\n              } else {\n                Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"renamePathInObject\"])(instance.context, oldPath, newPath);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookStateRenamePath === 'function') {\n            overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);\n          }\n\n          break;\n\n        case 'props':\n          if (instance === null) {\n            if (typeof overridePropsRenamePath === 'function') {\n              overridePropsRenamePath(fiber, oldPath, newPath);\n            }\n          } else {\n            fiber.pendingProps = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"copyWithRename\"])(instance.props, oldPath, newPath);\n            instance.forceUpdate();\n          }\n\n          break;\n\n        case 'state':\n          Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"renamePathInObject\"])(instance.state, oldPath, newPath);\n          instance.forceUpdate();\n          break;\n      }\n    }\n  }\n\n  function overrideValueAtPath(type, id, hookID, path, value) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      const instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          path = path.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (path.length === 0) {\n                // Simple context value\n                instance.context = value;\n              } else {\n                Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"setInObject\"])(instance.context, path, value);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookState === 'function') {\n            overrideHookState(fiber, hookID, path, value);\n          }\n\n          break;\n\n        case 'props':\n          switch (fiber.tag) {\n            case ClassComponent:\n              fiber.pendingProps = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[\"copyWithSet\"])(instance.props, path, value);\n              instance.forceUpdate();\n              break;\n\n            default:\n              if (typeof overrideProps === 'function') {\n                overrideProps(fiber, path, value);\n              }\n\n              break;\n          }\n\n          break;\n\n        case 'state':\n          switch (fiber.tag) {\n            case ClassComponent:\n              Object(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__[\"setInObject\"])(instance.state, path, value);\n              instance.forceUpdate();\n              break;\n          }\n\n          break;\n      }\n    }\n  }\n\n  let currentCommitProfilingMetadata = null;\n  let displayNamesByRootID = null;\n  let idToContextsMap = null;\n  let initialTreeBaseDurationsMap = null;\n  let initialIDToRootMap = null;\n  let isProfiling = false;\n  let profilingStartTime = 0;\n  let recordChangeDescriptions = false;\n  let rootToCommitProfilingMetadataMap = null;\n\n  function getProfilingData() {\n    const dataForRoots = [];\n\n    if (rootToCommitProfilingMetadataMap === null) {\n      throw Error('getProfilingData() called before any profiling data was recorded');\n    }\n\n    rootToCommitProfilingMetadataMap.forEach((commitProfilingMetadata, rootID) => {\n      const commitData = [];\n      const initialTreeBaseDurations = [];\n      const displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || 'Unknown';\n\n      if (initialTreeBaseDurationsMap != null) {\n        initialTreeBaseDurationsMap.forEach((treeBaseDuration, id) => {\n          if (initialIDToRootMap != null && initialIDToRootMap.get(id) === rootID) {\n            // We don't need to convert milliseconds to microseconds in this case,\n            // because the profiling summary is JSON serialized.\n            initialTreeBaseDurations.push([id, treeBaseDuration]);\n          }\n        });\n      }\n\n      commitProfilingMetadata.forEach((commitProfilingData, commitIndex) => {\n        const {\n          changeDescriptions,\n          durations,\n          effectDuration,\n          maxActualDuration,\n          passiveEffectDuration,\n          priorityLevel,\n          commitTime,\n          updaters\n        } = commitProfilingData;\n        const fiberActualDurations = [];\n        const fiberSelfDurations = [];\n\n        for (let i = 0; i < durations.length; i += 3) {\n          const fiberID = durations[i];\n          fiberActualDurations.push([fiberID, durations[i + 1]]);\n          fiberSelfDurations.push([fiberID, durations[i + 2]]);\n        }\n\n        commitData.push({\n          changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,\n          duration: maxActualDuration,\n          effectDuration,\n          fiberActualDurations,\n          fiberSelfDurations,\n          passiveEffectDuration,\n          priorityLevel,\n          timestamp: commitTime,\n          updaters\n        });\n      });\n      dataForRoots.push({\n        commitData,\n        displayName,\n        initialTreeBaseDurations,\n        rootID\n      });\n    });\n    return {\n      dataForRoots,\n      rendererID\n    };\n  }\n\n  function startProfiling(shouldRecordChangeDescriptions) {\n    if (isProfiling) {\n      return;\n    }\n\n    recordChangeDescriptions = shouldRecordChangeDescriptions; // Capture initial values as of the time profiling starts.\n    // It's important we snapshot both the durations and the id-to-root map,\n    // since either of these may change during the profiling session\n    // (e.g. when a fiber is re-rendered or when a fiber gets removed).\n\n    displayNamesByRootID = new Map();\n    initialTreeBaseDurationsMap = new Map(idToTreeBaseDurationMap);\n    initialIDToRootMap = new Map(idToRootMap);\n    idToContextsMap = new Map();\n    hook.getFiberRoots(rendererID).forEach(root => {\n      const rootID = getFiberIDThrows(root.current);\n      displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));\n\n      if (shouldRecordChangeDescriptions) {\n        // Record all contexts at the time profiling is started.\n        // Fibers only store the current context value,\n        // so we need to track them separately in order to determine changed keys.\n        crawlToInitializeContextsMap(root.current);\n      }\n    });\n    isProfiling = true;\n    profilingStartTime = getCurrentTime();\n    rootToCommitProfilingMetadataMap = new Map();\n  }\n\n  function stopProfiling() {\n    isProfiling = false;\n    recordChangeDescriptions = false;\n  } // Automatically start profiling so that we don't miss timing info from initial \"mount\".\n\n\n  if (Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_5__[\"SESSION_STORAGE_RELOAD_AND_PROFILE_KEY\"]) === 'true') {\n    startProfiling(Object(react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_3__[\"sessionStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_5__[\"SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY\"]) === 'true');\n  } // React will switch between these implementations depending on whether\n  // we have any manually suspended/errored-out Fibers or not.\n\n\n  function shouldErrorFiberAlwaysNull() {\n    return null;\n  } // Map of id and its force error status: true (error), false (toggled off),\n  // null (do nothing)\n\n\n  const forceErrorForFiberIDs = new Map();\n\n  function shouldErrorFiberAccordingToMap(fiber) {\n    if (typeof setErrorHandler !== 'function') {\n      throw new Error('Expected overrideError() to not get called for earlier React versions.');\n    }\n\n    const id = getFiberIDUnsafe(fiber);\n\n    if (id === null) {\n      return null;\n    }\n\n    let status = null;\n\n    if (forceErrorForFiberIDs.has(id)) {\n      status = forceErrorForFiberIDs.get(id);\n\n      if (status === false) {\n        // TRICKY overrideError adds entries to this Map,\n        // so ideally it would be the method that clears them too,\n        // but that would break the functionality of the feature,\n        // since DevTools needs to tell React to act differently than it normally would\n        // (don't just re-render the failed boundary, but reset its errored state too).\n        // So we can only clear it after telling React to reset the state.\n        // Technically this is premature and we should schedule it for later,\n        // since the render could always fail without committing the updated error boundary,\n        // but since this is a DEV-only feature, the simplicity is worth the trade off.\n        forceErrorForFiberIDs.delete(id);\n\n        if (forceErrorForFiberIDs.size === 0) {\n          // Last override is gone. Switch React back to fast path.\n          setErrorHandler(shouldErrorFiberAlwaysNull);\n        }\n      }\n    }\n\n    return status;\n  }\n\n  function overrideError(id, forceError) {\n    if (typeof setErrorHandler !== 'function' || typeof scheduleUpdate !== 'function') {\n      throw new Error('Expected overrideError() to not get called for earlier React versions.');\n    }\n\n    forceErrorForFiberIDs.set(id, forceError);\n\n    if (forceErrorForFiberIDs.size === 1) {\n      // First override is added. Switch React to slower path.\n      setErrorHandler(shouldErrorFiberAccordingToMap);\n    }\n\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber != null) {\n      scheduleUpdate(fiber);\n    }\n  }\n\n  function shouldSuspendFiberAlwaysFalse() {\n    return false;\n  }\n\n  const forceFallbackForSuspenseIDs = new Set();\n\n  function shouldSuspendFiberAccordingToSet(fiber) {\n    const maybeID = getFiberIDUnsafe(fiber);\n    return maybeID !== null && forceFallbackForSuspenseIDs.has(maybeID);\n  }\n\n  function overrideSuspense(id, forceFallback) {\n    if (typeof setSuspenseHandler !== 'function' || typeof scheduleUpdate !== 'function') {\n      throw new Error('Expected overrideSuspense() to not get called for earlier React versions.');\n    }\n\n    if (forceFallback) {\n      forceFallbackForSuspenseIDs.add(id);\n\n      if (forceFallbackForSuspenseIDs.size === 1) {\n        // First override is added. Switch React to slower path.\n        setSuspenseHandler(shouldSuspendFiberAccordingToSet);\n      }\n    } else {\n      forceFallbackForSuspenseIDs.delete(id);\n\n      if (forceFallbackForSuspenseIDs.size === 0) {\n        // Last override is gone. Switch React back to fast path.\n        setSuspenseHandler(shouldSuspendFiberAlwaysFalse);\n      }\n    }\n\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber != null) {\n      scheduleUpdate(fiber);\n    }\n  } // Remember if we're trying to restore the selection after reload.\n  // In that case, we'll do some extra checks for matching mounts.\n\n\n  let trackedPath = null;\n  let trackedPathMatchFiber = null;\n  let trackedPathMatchDepth = -1;\n  let mightBeOnTrackedPath = false;\n\n  function setTrackedPath(path) {\n    if (path === null) {\n      trackedPathMatchFiber = null;\n      trackedPathMatchDepth = -1;\n      mightBeOnTrackedPath = false;\n    }\n\n    trackedPath = path;\n  } // We call this before traversing a new mount.\n  // It remembers whether this Fiber is the next best match for tracked path.\n  // The return value signals whether we should keep matching siblings or not.\n\n\n  function updateTrackedPathStateBeforeMount(fiber) {\n    if (trackedPath === null || !mightBeOnTrackedPath) {\n      // Fast path: there's nothing to track so do nothing and ignore siblings.\n      return false;\n    }\n\n    const returnFiber = fiber.return;\n    const returnAlternate = returnFiber !== null ? returnFiber.alternate : null; // By now we know there's some selection to restore, and this is a new Fiber.\n    // Is this newly mounted Fiber a direct child of the current best match?\n    // (This will also be true for new roots if we haven't matched anything yet.)\n\n    if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {\n      // Is this the next Fiber we should select? Let's compare the frames.\n      const actualFrame = getPathFrame(fiber);\n      const expectedFrame = trackedPath[trackedPathMatchDepth + 1];\n\n      if (expectedFrame === undefined) {\n        throw new Error('Expected to see a frame at the next depth.');\n      }\n\n      if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {\n        // We have our next match.\n        trackedPathMatchFiber = fiber;\n        trackedPathMatchDepth++; // Are we out of frames to match?\n\n        if (trackedPathMatchDepth === trackedPath.length - 1) {\n          // There's nothing that can possibly match afterwards.\n          // Don't check the children.\n          mightBeOnTrackedPath = false;\n        } else {\n          // Check the children, as they might reveal the next match.\n          mightBeOnTrackedPath = true;\n        } // In either case, since we have a match, we don't need\n        // to check the siblings. They'll never match.\n\n\n        return false;\n      }\n    } // This Fiber's parent is on the path, but this Fiber itself isn't.\n    // There's no need to check its children--they won't be on the path either.\n\n\n    mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.\n\n    return true;\n  }\n\n  function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {\n    // updateTrackedPathStateBeforeMount() told us whether to match siblings.\n    // Now that we're entering siblings, let's use that information.\n    mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;\n  } // Roots don't have a real persistent identity.\n  // A root's \"pseudo key\" is \"childDisplayName:indexWithThatName\".\n  // For example, \"App:0\" or, in case of similar roots, \"Story:0\", \"Story:1\", etc.\n  // We will use this to try to disambiguate roots when restoring selection between reloads.\n\n\n  const rootPseudoKeys = new Map();\n  const rootDisplayNameCounter = new Map();\n\n  function setRootPseudoKey(id, fiber) {\n    const name = getDisplayNameForRoot(fiber);\n    const counter = rootDisplayNameCounter.get(name) || 0;\n    rootDisplayNameCounter.set(name, counter + 1);\n    const pseudoKey = `${name}:${counter}`;\n    rootPseudoKeys.set(id, pseudoKey);\n  }\n\n  function removeRootPseudoKey(id) {\n    const pseudoKey = rootPseudoKeys.get(id);\n\n    if (pseudoKey === undefined) {\n      throw new Error('Expected root pseudo key to be known.');\n    }\n\n    const name = pseudoKey.substring(0, pseudoKey.lastIndexOf(':'));\n    const counter = rootDisplayNameCounter.get(name);\n\n    if (counter === undefined) {\n      throw new Error('Expected counter to be known.');\n    }\n\n    if (counter > 1) {\n      rootDisplayNameCounter.set(name, counter - 1);\n    } else {\n      rootDisplayNameCounter.delete(name);\n    }\n\n    rootPseudoKeys.delete(id);\n  }\n\n  function getDisplayNameForRoot(fiber) {\n    let preferredDisplayName = null;\n    let fallbackDisplayName = null;\n    let child = fiber.child; // Go at most three levels deep into direct children\n    // while searching for a child that has a displayName.\n\n    for (let i = 0; i < 3; i++) {\n      if (child === null) {\n        break;\n      }\n\n      const displayName = getDisplayNameForFiber(child);\n\n      if (displayName !== null) {\n        // Prefer display names that we get from user-defined components.\n        // We want to avoid using e.g. 'Suspense' unless we find nothing else.\n        if (typeof child.type === 'function') {\n          // There's a few user-defined tags, but we'll prefer the ones\n          // that are usually explicitly named (function or class components).\n          preferredDisplayName = displayName;\n        } else if (fallbackDisplayName === null) {\n          fallbackDisplayName = displayName;\n        }\n      }\n\n      if (preferredDisplayName !== null) {\n        break;\n      }\n\n      child = child.child;\n    }\n\n    return preferredDisplayName || fallbackDisplayName || 'Anonymous';\n  }\n\n  function getPathFrame(fiber) {\n    const {\n      key\n    } = fiber;\n    let displayName = getDisplayNameForFiber(fiber);\n    const index = fiber.index;\n\n    switch (fiber.tag) {\n      case HostRoot:\n        // Roots don't have a real displayName, index, or key.\n        // Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).\n        const id = getFiberIDThrows(fiber);\n        const pseudoKey = rootPseudoKeys.get(id);\n\n        if (pseudoKey === undefined) {\n          throw new Error('Expected mounted root to have known pseudo key.');\n        }\n\n        displayName = pseudoKey;\n        break;\n\n      case HostComponent:\n        displayName = fiber.type;\n        break;\n\n      default:\n        break;\n    }\n\n    return {\n      displayName,\n      key,\n      index\n    };\n  } // Produces a serializable representation that does a best effort\n  // of identifying a particular Fiber between page reloads.\n  // The return path will contain Fibers that are \"invisible\" to the store\n  // because their keys and indexes are important to restoring the selection.\n\n\n  function getPathForElement(id) {\n    let fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      return null;\n    }\n\n    const keyPath = [];\n\n    while (fiber !== null) {\n      keyPath.push(getPathFrame(fiber));\n      fiber = fiber.return;\n    }\n\n    keyPath.reverse();\n    return keyPath;\n  }\n\n  function getBestMatchForTrackedPath() {\n    if (trackedPath === null) {\n      // Nothing to match.\n      return null;\n    }\n\n    if (trackedPathMatchFiber === null) {\n      // We didn't find anything.\n      return null;\n    } // Find the closest Fiber store is aware of.\n\n\n    let fiber = trackedPathMatchFiber;\n\n    while (fiber !== null && shouldFilterFiber(fiber)) {\n      fiber = fiber.return;\n    }\n\n    if (fiber === null) {\n      return null;\n    }\n\n    return {\n      id: getFiberIDThrows(fiber),\n      isFullMatch: trackedPathMatchDepth === trackedPath.length - 1\n    };\n  }\n\n  const formatPriorityLevel = priorityLevel => {\n    if (priorityLevel == null) {\n      return 'Unknown';\n    }\n\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        return 'Immediate';\n\n      case UserBlockingPriority:\n        return 'User-Blocking';\n\n      case NormalPriority:\n        return 'Normal';\n\n      case LowPriority:\n        return 'Low';\n\n      case IdlePriority:\n        return 'Idle';\n\n      case NoPriority:\n      default:\n        return 'Unknown';\n    }\n  };\n\n  function setTraceUpdatesEnabled(isEnabled) {\n    traceUpdatesEnabled = isEnabled;\n  }\n\n  return {\n    cleanup,\n    clearErrorsAndWarnings,\n    clearErrorsForFiberID,\n    clearWarningsForFiberID,\n    copyElementPath,\n    deletePath,\n    findNativeNodesForFiberID,\n    flushInitialOperations,\n    getBestMatchForTrackedPath,\n    getDisplayNameForFiberID,\n    getFiberIDForNative,\n    getInstanceAndStyle,\n    getOwnersList,\n    getPathForElement,\n    getProfilingData,\n    handleCommitFiberRoot,\n    handleCommitFiberUnmount,\n    handlePostCommitFiberRoot,\n    inspectElement,\n    logElementToConsole,\n    patchConsoleForStrictMode: _console__WEBPACK_IMPORTED_MODULE_7__[\"patchForStrictMode\"],\n    prepareViewAttributeSource,\n    prepareViewElementSource,\n    overrideError,\n    overrideSuspense,\n    overrideValueAtPath,\n    renamePath,\n    renderer,\n    setTraceUpdatesEnabled,\n    setTrackedPath,\n    startProfiling,\n    stopProfiling,\n    storeAsGlobal,\n    unpatchConsoleForStrictMode: _console__WEBPACK_IMPORTED_MODULE_7__[\"unpatchForStrictMode\"],\n    updateComponentFilters\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3JlbmRlcmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9yZW5kZXJlci5qcz82YTBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge2d0LCBndGV9IGZyb20gJ3NlbXZlcic7XG5pbXBvcnQge1xuICBDb21wb25lbnRGaWx0ZXJEaXNwbGF5TmFtZSxcbiAgQ29tcG9uZW50RmlsdGVyRWxlbWVudFR5cGUsXG4gIENvbXBvbmVudEZpbHRlckhPQyxcbiAgQ29tcG9uZW50RmlsdGVyTG9jYXRpb24sXG4gIEVsZW1lbnRUeXBlQ2xhc3MsXG4gIEVsZW1lbnRUeXBlQ29udGV4dCxcbiAgRWxlbWVudFR5cGVGdW5jdGlvbixcbiAgRWxlbWVudFR5cGVGb3J3YXJkUmVmLFxuICBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQsXG4gIEVsZW1lbnRUeXBlTWVtbyxcbiAgRWxlbWVudFR5cGVPdGhlck9yVW5rbm93bixcbiAgRWxlbWVudFR5cGVQcm9maWxlcixcbiAgRWxlbWVudFR5cGVSb290LFxuICBFbGVtZW50VHlwZVN1c3BlbnNlLFxuICBFbGVtZW50VHlwZVN1c3BlbnNlTGlzdCxcbiAgU3RyaWN0TW9kZSxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy90eXBlcyc7XG5pbXBvcnQge1xuICBkZWxldGVQYXRoSW5PYmplY3QsXG4gIGdldERpc3BsYXlOYW1lLFxuICBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycyxcbiAgZ2V0SW5PYmplY3QsXG4gIGdldFVJRCxcbiAgcmVuYW1lUGF0aEluT2JqZWN0LFxuICBzZXRJbk9iamVjdCxcbiAgdXRmRW5jb2RlU3RyaW5nLFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3V0aWxzJztcbmltcG9ydCB7c2Vzc2lvblN0b3JhZ2VHZXRJdGVtfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3N0b3JhZ2UnO1xuaW1wb3J0IHtcbiAgY2xlYW5Gb3JCcmlkZ2UsXG4gIGNvcHlUb0NsaXBib2FyZCxcbiAgY29weVdpdGhEZWxldGUsXG4gIGNvcHlXaXRoUmVuYW1lLFxuICBjb3B5V2l0aFNldCxcbiAgZ2V0RWZmZWN0RHVyYXRpb25zLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIF9fREVCVUdfXyxcbiAgU0VTU0lPTl9TVE9SQUdFX1JFTE9BRF9BTkRfUFJPRklMRV9LRVksXG4gIFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVksXG4gIFRSRUVfT1BFUkFUSU9OX0FERCxcbiAgVFJFRV9PUEVSQVRJT05fUkVNT1ZFLFxuICBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCxcbiAgVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTixcbiAgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERSxcbiAgVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUyxcbiAgVFJFRV9PUEVSQVRJT05fVVBEQVRFX1RSRUVfQkFTRV9EVVJBVElPTixcbn0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7aW5zcGVjdEhvb2tzT2ZGaWJlcn0gZnJvbSAncmVhY3QtZGVidWctdG9vbHMnO1xuaW1wb3J0IHtcbiAgcGF0Y2ggYXMgcGF0Y2hDb25zb2xlLFxuICByZWdpc3RlclJlbmRlcmVyIGFzIHJlZ2lzdGVyUmVuZGVyZXJXaXRoQ29uc29sZSxcbiAgcGF0Y2hGb3JTdHJpY3RNb2RlIGFzIHBhdGNoQ29uc29sZUZvclN0cmljdE1vZGUsXG4gIHVucGF0Y2hGb3JTdHJpY3RNb2RlIGFzIHVucGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZSxcbn0gZnJvbSAnLi9jb25zb2xlJztcbmltcG9ydCB7XG4gIENPTkNVUlJFTlRfTU9ERV9OVU1CRVIsXG4gIENPTkNVUlJFTlRfTU9ERV9TWU1CT0xfU1RSSU5HLFxuICBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORyxcbiAgUFJPVklERVJfTlVNQkVSLFxuICBQUk9WSURFUl9TWU1CT0xfU1RSSU5HLFxuICBDT05URVhUX05VTUJFUixcbiAgQ09OVEVYVF9TWU1CT0xfU1RSSU5HLFxuICBTVFJJQ1RfTU9ERV9OVU1CRVIsXG4gIFNUUklDVF9NT0RFX1NZTUJPTF9TVFJJTkcsXG4gIFBST0ZJTEVSX05VTUJFUixcbiAgUFJPRklMRVJfU1lNQk9MX1NUUklORyxcbiAgU0NPUEVfTlVNQkVSLFxuICBTQ09QRV9TWU1CT0xfU1RSSU5HLFxuICBGT1JXQVJEX1JFRl9OVU1CRVIsXG4gIEZPUldBUkRfUkVGX1NZTUJPTF9TVFJJTkcsXG4gIE1FTU9fTlVNQkVSLFxuICBNRU1PX1NZTUJPTF9TVFJJTkcsXG59IGZyb20gJy4vUmVhY3RTeW1ib2xzJztcbmltcG9ydCB7Zm9ybWF0fSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIGVuYWJsZVByb2ZpbGVyQ2hhbmdlZEhvb2tJbmRpY2VzLFxuICBlbmFibGVTdHlsZVhGZWF0dXJlcyxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtZmVhdHVyZS1mbGFncyc7XG5pbXBvcnQgaXMgZnJvbSAnc2hhcmVkL29iamVjdElzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJ3NoYXJlZC9pc0FycmF5JztcbmltcG9ydCBoYXNPd25Qcm9wZXJ0eSBmcm9tICdzaGFyZWQvaGFzT3duUHJvcGVydHknO1xuaW1wb3J0IHtnZXRTdHlsZVhEYXRhfSBmcm9tICcuL1N0eWxlWC91dGlscyc7XG5cbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RJbnRlcm5hbFR5cGVzJztcbmltcG9ydCB0eXBlIHtcbiAgQ2hhbmdlRGVzY3JpcHRpb24sXG4gIENvbW1pdERhdGFCYWNrZW5kLFxuICBEZXZUb29sc0hvb2ssXG4gIEluc3BlY3RlZEVsZW1lbnQsXG4gIEluc3BlY3RlZEVsZW1lbnRQYXlsb2FkLFxuICBJbnN0YW5jZUFuZFN0eWxlLFxuICBOYXRpdmVUeXBlLFxuICBQYXRoRnJhbWUsXG4gIFBhdGhNYXRjaCxcbiAgUHJvZmlsaW5nRGF0YUJhY2tlbmQsXG4gIFByb2ZpbGluZ0RhdGFGb3JSb290QmFja2VuZCxcbiAgUmVhY3RSZW5kZXJlcixcbiAgUmVuZGVyZXJJbnRlcmZhY2UsXG4gIFNlcmlhbGl6ZWRFbGVtZW50LFxuICBXb3JrVGFnTWFwLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB0eXBlIHtcbiAgQ29tcG9uZW50RmlsdGVyLFxuICBFbGVtZW50VHlwZSxcbiAgUGx1Z2lucyxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy90eXBlcyc7XG5pbXBvcnQge0hvc3RUZXh0fSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdFdvcmtUYWdzJztcblxudHlwZSBnZXREaXNwbGF5TmFtZUZvckZpYmVyVHlwZSA9IChmaWJlcjogRmliZXIpID0+IHN0cmluZyB8IG51bGw7XG50eXBlIGdldFR5cGVTeW1ib2xUeXBlID0gKHR5cGU6IGFueSkgPT4gU3ltYm9sIHwgbnVtYmVyO1xuXG50eXBlIFJlYWN0UHJpb3JpdHlMZXZlbHNUeXBlID0ge3xcbiAgSW1tZWRpYXRlUHJpb3JpdHk6IG51bWJlcixcbiAgVXNlckJsb2NraW5nUHJpb3JpdHk6IG51bWJlcixcbiAgTm9ybWFsUHJpb3JpdHk6IG51bWJlcixcbiAgTG93UHJpb3JpdHk6IG51bWJlcixcbiAgSWRsZVByaW9yaXR5OiBudW1iZXIsXG4gIE5vUHJpb3JpdHk6IG51bWJlcixcbnx9O1xuXG50eXBlIFJlYWN0VHlwZU9mU2lkZUVmZmVjdFR5cGUgPSB7fFxuICBEaWRDYXB0dXJlOiBudW1iZXIsXG4gIE5vRmxhZ3M6IG51bWJlcixcbiAgUGVyZm9ybWVkV29yazogbnVtYmVyLFxuICBQbGFjZW1lbnQ6IG51bWJlcixcbiAgSW5jb21wbGV0ZTogbnVtYmVyLFxuICBIeWRyYXRpbmc6IG51bWJlcixcbnx9O1xuXG5mdW5jdGlvbiBnZXRGaWJlckZsYWdzKGZpYmVyOiBGaWJlcik6IG51bWJlciB7XG4gIC8vIFRoZSBuYW1lIG9mIHRoaXMgZmllbGQgY2hhbmdlZCBmcm9tIFwiZWZmZWN0VGFnXCIgdG8gXCJmbGFnc1wiXG4gIHJldHVybiBmaWJlci5mbGFncyAhPT0gdW5kZWZpbmVkID8gZmliZXIuZmxhZ3MgOiAoZmliZXI6IGFueSkuZWZmZWN0VGFnO1xufVxuXG4vLyBTb21lIGVudmlyb25tZW50cyAoZS5nLiBSZWFjdCBOYXRpdmUgLyBIZXJtZXMpIGRvbid0IHN1cHBvcnQgdGhlIHBlcmZvcm1hbmNlIEFQSSB5ZXQuXG5jb25zdCBnZXRDdXJyZW50VGltZSA9XG4gIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gKCkgPT4gcGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbFJlYWN0Q29uc3RhbnRzKFxuICB2ZXJzaW9uOiBzdHJpbmcsXG4pOiB7fFxuICBnZXREaXNwbGF5TmFtZUZvckZpYmVyOiBnZXREaXNwbGF5TmFtZUZvckZpYmVyVHlwZSxcbiAgZ2V0VHlwZVN5bWJvbDogZ2V0VHlwZVN5bWJvbFR5cGUsXG4gIFJlYWN0UHJpb3JpdHlMZXZlbHM6IFJlYWN0UHJpb3JpdHlMZXZlbHNUeXBlLFxuICBSZWFjdFR5cGVPZlNpZGVFZmZlY3Q6IFJlYWN0VHlwZU9mU2lkZUVmZmVjdFR5cGUsXG4gIFJlYWN0VHlwZU9mV29yazogV29ya1RhZ01hcCxcbiAgU3RyaWN0TW9kZUJpdHM6IG51bWJlcixcbnx9IHtcbiAgY29uc3QgUmVhY3RUeXBlT2ZTaWRlRWZmZWN0OiBSZWFjdFR5cGVPZlNpZGVFZmZlY3RUeXBlID0ge1xuICAgIERpZENhcHR1cmU6IDBiMTAwMDAwMDAsXG4gICAgTm9GbGFnczogMGIwMCxcbiAgICBQZXJmb3JtZWRXb3JrOiAwYjAxLFxuICAgIFBsYWNlbWVudDogMGIxMCxcbiAgICBJbmNvbXBsZXRlOiAwYjEwMDAwMDAwMDAwMDAwLFxuICAgIEh5ZHJhdGluZzogMGIxMDAwMDAwMDAwMDAwLFxuICB9O1xuXG4gIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgLy8gVGhlIHNlY3Rpb24gYmVsb3cgaXMgY29waWVkIGZyb20gZmlsZXMgaW4gUmVhY3QgcmVwby5cbiAgLy8gS2VlcCBpdCBpbiBzeW5jLCBhbmQgYWRkIHZlcnNpb24gZ3VhcmRzIGlmIGl0IGNoYW5nZXMuXG4gIC8vXG4gIC8vIFRlY2huaWNhbGx5IHRoZXNlIHByaW9yaXR5IGxldmVscyBhcmUgaW52YWxpZCBmb3IgdmVyc2lvbnMgYmVmb3JlIDE2LjksXG4gIC8vIGJ1dCAxNi45IGlzIHRoZSBmaXJzdCB2ZXJzaW9uIHRvIHJlcG9ydCBwcmlvcml0eSBsZXZlbCB0byBEZXZUb29scyxcbiAgLy8gc28gd2UgY2FuIGF2b2lkIGNoZWNraW5nIGZvciBlYXJsaWVyIHZlcnNpb25zIGFuZCBzdXBwb3J0IHByZS0xNi45IGNhbmFyeSByZWxlYXNlcyBpbiB0aGUgcHJvY2Vzcy5cbiAgbGV0IFJlYWN0UHJpb3JpdHlMZXZlbHM6IFJlYWN0UHJpb3JpdHlMZXZlbHNUeXBlID0ge1xuICAgIEltbWVkaWF0ZVByaW9yaXR5OiA5OSxcbiAgICBVc2VyQmxvY2tpbmdQcmlvcml0eTogOTgsXG4gICAgTm9ybWFsUHJpb3JpdHk6IDk3LFxuICAgIExvd1ByaW9yaXR5OiA5NixcbiAgICBJZGxlUHJpb3JpdHk6IDk1LFxuICAgIE5vUHJpb3JpdHk6IDkwLFxuICB9O1xuXG4gIGlmIChndCh2ZXJzaW9uLCAnMTcuMC4yJykpIHtcbiAgICBSZWFjdFByaW9yaXR5TGV2ZWxzID0ge1xuICAgICAgSW1tZWRpYXRlUHJpb3JpdHk6IDEsXG4gICAgICBVc2VyQmxvY2tpbmdQcmlvcml0eTogMixcbiAgICAgIE5vcm1hbFByaW9yaXR5OiAzLFxuICAgICAgTG93UHJpb3JpdHk6IDQsXG4gICAgICBJZGxlUHJpb3JpdHk6IDUsXG4gICAgICBOb1ByaW9yaXR5OiAwLFxuICAgIH07XG4gIH1cblxuICBsZXQgU3RyaWN0TW9kZUJpdHMgPSAwO1xuICBpZiAoZ3RlKHZlcnNpb24sICcxOC4wLjAtYWxwaGEnKSkge1xuICAgIC8vIDE4K1xuICAgIFN0cmljdE1vZGVCaXRzID0gMGIwMTEwMDA7XG4gIH0gZWxzZSBpZiAoZ3RlKHZlcnNpb24sICcxNi45LjAnKSkge1xuICAgIC8vIDE2LjkgLSAxN1xuICAgIFN0cmljdE1vZGVCaXRzID0gMGIxO1xuICB9IGVsc2UgaWYgKGd0ZSh2ZXJzaW9uLCAnMTYuMy4wJykpIHtcbiAgICAvLyAxNi4zIC0gMTYuOFxuICAgIFN0cmljdE1vZGVCaXRzID0gMGIxMDtcbiAgfVxuXG4gIGxldCBSZWFjdFR5cGVPZldvcms6IFdvcmtUYWdNYXAgPSAoKG51bGw6IGFueSk6IFdvcmtUYWdNYXApO1xuXG4gIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgLy8gVGhlIHNlY3Rpb24gYmVsb3cgaXMgY29waWVkIGZyb20gZmlsZXMgaW4gUmVhY3QgcmVwby5cbiAgLy8gS2VlcCBpdCBpbiBzeW5jLCBhbmQgYWRkIHZlcnNpb24gZ3VhcmRzIGlmIGl0IGNoYW5nZXMuXG4gIC8vXG4gIC8vIFRPRE8gVXBkYXRlIHRoZSBndCgpIGNoZWNrIGJlbG93IHRvIGJlIGd0ZSgpIHdoaWNoZXZlciB0aGUgbmV4dCB2ZXJzaW9uIG51bWJlciBpcy5cbiAgLy8gQ3VycmVudGx5IHRoZSB2ZXJzaW9uIGluIEdpdCBpcyAxNy4wLjIgKGJ1dCB0aGF0IHZlcnNpb24gaGFzIG5vdCBiZWVuL21heSBub3QgZW5kIHVwIGJlaW5nIHJlbGVhc2VkKS5cbiAgaWYgKGd0KHZlcnNpb24sICcxNy4wLjEnKSkge1xuICAgIFJlYWN0VHlwZU9mV29yayA9IHtcbiAgICAgIENhY2hlQ29tcG9uZW50OiAyNCwgLy8gRXhwZXJpbWVudGFsXG4gICAgICBDbGFzc0NvbXBvbmVudDogMSxcbiAgICAgIENvbnRleHRDb25zdW1lcjogOSxcbiAgICAgIENvbnRleHRQcm92aWRlcjogMTAsXG4gICAgICBDb3JvdXRpbmVDb21wb25lbnQ6IC0xLCAvLyBSZW1vdmVkXG4gICAgICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IC0xLCAvLyBSZW1vdmVkXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IDE4LCAvLyBCZWhpbmQgYSBmbGFnXG4gICAgICBGb3J3YXJkUmVmOiAxMSxcbiAgICAgIEZyYWdtZW50OiA3LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDAsXG4gICAgICBIb3N0Q29tcG9uZW50OiA1LFxuICAgICAgSG9zdFBvcnRhbDogNCxcbiAgICAgIEhvc3RSb290OiAzLFxuICAgICAgSG9zdFRleHQ6IDYsXG4gICAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6IDE3LFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDogMixcbiAgICAgIExhenlDb21wb25lbnQ6IDE2LFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAyMyxcbiAgICAgIE1lbW9Db21wb25lbnQ6IDE0LFxuICAgICAgTW9kZTogOCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudDogMjIsIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDEyLFxuICAgICAgU2NvcGVDb21wb25lbnQ6IDIxLCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IDE1LFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDEzLFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAxOSwgLy8gRXhwZXJpbWVudGFsXG4gICAgICBZaWVsZENvbXBvbmVudDogLTEsIC8vIFJlbW92ZWRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGd0ZSh2ZXJzaW9uLCAnMTcuMC4wLWFscGhhJykpIHtcbiAgICBSZWFjdFR5cGVPZldvcmsgPSB7XG4gICAgICBDYWNoZUNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBDbGFzc0NvbXBvbmVudDogMSxcbiAgICAgIENvbnRleHRDb25zdW1lcjogOSxcbiAgICAgIENvbnRleHRQcm92aWRlcjogMTAsXG4gICAgICBDb3JvdXRpbmVDb21wb25lbnQ6IC0xLCAvLyBSZW1vdmVkXG4gICAgICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IC0xLCAvLyBSZW1vdmVkXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IDE4LCAvLyBCZWhpbmQgYSBmbGFnXG4gICAgICBGb3J3YXJkUmVmOiAxMSxcbiAgICAgIEZyYWdtZW50OiA3LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDAsXG4gICAgICBIb3N0Q29tcG9uZW50OiA1LFxuICAgICAgSG9zdFBvcnRhbDogNCxcbiAgICAgIEhvc3RSb290OiAzLFxuICAgICAgSG9zdFRleHQ6IDYsXG4gICAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6IDE3LFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDogMixcbiAgICAgIExhenlDb21wb25lbnQ6IDE2LFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAyNCxcbiAgICAgIE1lbW9Db21wb25lbnQ6IDE0LFxuICAgICAgTW9kZTogOCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudDogMjMsIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDEyLFxuICAgICAgU2NvcGVDb21wb25lbnQ6IDIxLCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IDE1LFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDEzLFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAxOSwgLy8gRXhwZXJpbWVudGFsXG4gICAgICBZaWVsZENvbXBvbmVudDogLTEsIC8vIFJlbW92ZWRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGd0ZSh2ZXJzaW9uLCAnMTYuNi4wLWJldGEuMCcpKSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDEsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDksXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEwLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiAtMSwgLy8gUmVtb3ZlZFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiAtMSwgLy8gUmVtb3ZlZFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAxOCwgLy8gQmVoaW5kIGEgZmxhZ1xuICAgICAgRm9yd2FyZFJlZjogMTEsXG4gICAgICBGcmFnbWVudDogNyxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAwLFxuICAgICAgSG9zdENvbXBvbmVudDogNSxcbiAgICAgIEhvc3RQb3J0YWw6IDQsXG4gICAgICBIb3N0Um9vdDogMyxcbiAgICAgIEhvc3RUZXh0OiA2LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAxNyxcbiAgICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IDIsXG4gICAgICBMYXp5Q29tcG9uZW50OiAxNixcbiAgICAgIExlZ2FjeUhpZGRlbkNvbXBvbmVudDogLTEsXG4gICAgICBNZW1vQ29tcG9uZW50OiAxNCxcbiAgICAgIE1vZGU6IDgsXG4gICAgICBPZmZzY3JlZW5Db21wb25lbnQ6IC0xLCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFByb2ZpbGVyOiAxMixcbiAgICAgIFNjb3BlQ29tcG9uZW50OiAtMSwgLy8gRXhwZXJpbWVudGFsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50OiAxNSxcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50OiAxMyxcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudDogMTksIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgWWllbGRDb21wb25lbnQ6IC0xLCAvLyBSZW1vdmVkXG4gICAgfTtcbiAgfSBlbHNlIGlmIChndGUodmVyc2lvbiwgJzE2LjQuMy1hbHBoYScpKSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDIsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDExLFxuICAgICAgQ29udGV4dFByb3ZpZGVyOiAxMixcbiAgICAgIENvcm91dGluZUNvbXBvbmVudDogLTEsIC8vIFJlbW92ZWRcbiAgICAgIENvcm91dGluZUhhbmRsZXJQaGFzZTogLTEsIC8vIFJlbW92ZWRcbiAgICAgIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBGb3J3YXJkUmVmOiAxMyxcbiAgICAgIEZyYWdtZW50OiA5LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDAsXG4gICAgICBIb3N0Q29tcG9uZW50OiA3LFxuICAgICAgSG9zdFBvcnRhbDogNixcbiAgICAgIEhvc3RSb290OiA1LFxuICAgICAgSG9zdFRleHQ6IDgsXG4gICAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDogNCxcbiAgICAgIExhenlDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAtMSxcbiAgICAgIE1lbW9Db21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgTW9kZTogMTAsXG4gICAgICBPZmZzY3JlZW5Db21wb25lbnQ6IC0xLCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFByb2ZpbGVyOiAxNSxcbiAgICAgIFNjb3BlQ29tcG9uZW50OiAtMSwgLy8gRXhwZXJpbWVudGFsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50OiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50OiAxNixcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBZaWVsZENvbXBvbmVudDogLTEsIC8vIFJlbW92ZWRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIFJlYWN0VHlwZU9mV29yayA9IHtcbiAgICAgIENhY2hlQ29tcG9uZW50OiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIENsYXNzQ29tcG9uZW50OiAyLFxuICAgICAgQ29udGV4dENvbnN1bWVyOiAxMixcbiAgICAgIENvbnRleHRQcm92aWRlcjogMTMsXG4gICAgICBDb3JvdXRpbmVDb21wb25lbnQ6IDcsXG4gICAgICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IDgsXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgRm9yd2FyZFJlZjogMTQsXG4gICAgICBGcmFnbWVudDogMTAsXG4gICAgICBGdW5jdGlvbkNvbXBvbmVudDogMSxcbiAgICAgIEhvc3RDb21wb25lbnQ6IDUsXG4gICAgICBIb3N0UG9ydGFsOiA0LFxuICAgICAgSG9zdFJvb3Q6IDMsXG4gICAgICBIb3N0VGV4dDogNixcbiAgICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiAwLFxuICAgICAgTGF6eUNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQ6IC0xLFxuICAgICAgTWVtb0NvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBNb2RlOiAxMSxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudDogLTEsIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDE1LFxuICAgICAgU2NvcGVDb21wb25lbnQ6IC0xLCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDE2LFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFlpZWxkQ29tcG9uZW50OiA5LFxuICAgIH07XG4gIH1cbiAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAvLyBFbmQgb2YgY29waWVkIGNvZGUuXG4gIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBmdW5jdGlvbiBnZXRUeXBlU3ltYm9sKHR5cGU6IGFueSk6IFN5bWJvbCB8IG51bWJlciB7XG4gICAgY29uc3Qgc3ltYm9sT3JOdW1iZXIgPVxuICAgICAgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgPyB0eXBlLiQkdHlwZW9mIDogdHlwZTtcblxuICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgdHlwZW9mIFwic3ltYm9sXCJcbiAgICByZXR1cm4gdHlwZW9mIHN5bWJvbE9yTnVtYmVyID09PSAnc3ltYm9sJ1xuICAgICAgPyBzeW1ib2xPck51bWJlci50b1N0cmluZygpXG4gICAgICA6IHN5bWJvbE9yTnVtYmVyO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIENhY2hlQ29tcG9uZW50LFxuICAgIENsYXNzQ29tcG9uZW50LFxuICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCxcbiAgICBGdW5jdGlvbkNvbXBvbmVudCxcbiAgICBJbmRldGVybWluYXRlQ29tcG9uZW50LFxuICAgIEZvcndhcmRSZWYsXG4gICAgSG9zdFJvb3QsXG4gICAgSG9zdENvbXBvbmVudCxcbiAgICBIb3N0UG9ydGFsLFxuICAgIEhvc3RUZXh0LFxuICAgIEZyYWdtZW50LFxuICAgIExhenlDb21wb25lbnQsXG4gICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50LFxuICAgIE1lbW9Db21wb25lbnQsXG4gICAgT2Zmc2NyZWVuQ29tcG9uZW50LFxuICAgIFByb2ZpbGVyLFxuICAgIFNjb3BlQ29tcG9uZW50LFxuICAgIFNpbXBsZU1lbW9Db21wb25lbnQsXG4gICAgU3VzcGVuc2VDb21wb25lbnQsXG4gICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50LFxuICB9ID0gUmVhY3RUeXBlT2ZXb3JrO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVGaWJlclR5cGUodHlwZTogYW55KSB7XG4gICAgY29uc3QgdHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2wodHlwZSk7XG4gICAgc3dpdGNoICh0eXBlU3ltYm9sKSB7XG4gICAgICBjYXNlIE1FTU9fTlVNQkVSOlxuICAgICAgY2FzZSBNRU1PX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHJlc29sdmluZyBtZW1vIHR5cGUgaW4gY2FzZSBvZiBtZW1vKGZvcndhcmRSZWYoQ29tcG9uZW50KSlcbiAgICAgICAgcmV0dXJuIHJlc29sdmVGaWJlclR5cGUodHlwZS50eXBlKTtcbiAgICAgIGNhc2UgRk9SV0FSRF9SRUZfTlVNQkVSOlxuICAgICAgY2FzZSBGT1JXQVJEX1JFRl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICByZXR1cm4gdHlwZS5yZW5kZXI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBOT1RJQ0UgS2VlcCBpbiBzeW5jIHdpdGggc2hvdWxkRmlsdGVyRmliZXIoKSBhbmQgb3RoZXIgZ2V0KkZvckZpYmVyIG1ldGhvZHNcbiAgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcjogRmliZXIpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCB7ZWxlbWVudFR5cGUsIHR5cGUsIHRhZ30gPSBmaWJlcjtcblxuICAgIGxldCByZXNvbHZlZFR5cGUgPSB0eXBlO1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZpYmVyVHlwZSh0eXBlKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZWRDb250ZXh0OiBhbnkgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUocmVzb2x2ZWRUeXBlKTtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShyZXNvbHZlZFR5cGUpO1xuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICAvLyBNaXJyb3IgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvN2MyMWJmNzJhY2U3NzA5NGZkMTkxMGNjMzUwYTU0ODI4N2VmODM1MC9wYWNrYWdlcy9zaGFyZWQvZ2V0Q29tcG9uZW50TmFtZS5qcyNMMjctTDM3XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHR5cGUgJiYgdHlwZS5kaXNwbGF5TmFtZSkgfHxcbiAgICAgICAgICBnZXREaXNwbGF5TmFtZShyZXNvbHZlZFR5cGUsICdBbm9ueW1vdXMnKVxuICAgICAgICApO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgY29uc3QgZmliZXJSb290ID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoZmliZXJSb290ICE9IG51bGwgJiYgZmliZXJSb290Ll9kZWJ1Z1Jvb3RUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyUm9vdC5fZGVidWdSb290VHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICAgIC8vIFRoaXMgZGlzcGxheSBuYW1lIHdpbGwgbm90IGJlIHVzZXIgdmlzaWJsZS5cbiAgICAgICAgLy8gT25jZSBhIExhenkgY29tcG9uZW50IGxvYWRzIGl0cyBpbm5lciBjb21wb25lbnQsIFJlYWN0IHJlcGxhY2VzIHRoZSB0YWcgYW5kIHR5cGUuXG4gICAgICAgIC8vIFRoaXMgZGlzcGxheSBuYW1lIHdpbGwgb25seSBzaG93IHVwIGluIGNvbnNvbGUgbG9ncyB3aGVuIERldlRvb2xzIERFQlVHIG1vZGUgaXMgb24uXG4gICAgICAgIHJldHVybiAnTGF6eSc7XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGVsZW1lbnRUeXBlICYmIGVsZW1lbnRUeXBlLmRpc3BsYXlOYW1lKSB8fFxuICAgICAgICAgICh0eXBlICYmIHR5cGUuZGlzcGxheU5hbWUpIHx8XG4gICAgICAgICAgZ2V0RGlzcGxheU5hbWUocmVzb2x2ZWRUeXBlLCAnQW5vbnltb3VzJylcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnTGVnYWN5SGlkZGVuJztcbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG4gICAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ1Njb3BlJztcbiAgICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnN0IHR5cGVTeW1ib2wgPSBnZXRUeXBlU3ltYm9sKHR5cGUpO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZVN5bWJvbCkge1xuICAgICAgICAgIGNhc2UgQ09OQ1VSUkVOVF9NT0RFX05VTUJFUjpcbiAgICAgICAgICBjYXNlIENPTkNVUlJFTlRfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgIGNhc2UgREVQUkVDQVRFRF9BU1lOQ19NT0RFX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBjYXNlIFBST1ZJREVSX05VTUJFUjpcbiAgICAgICAgICBjYXNlIFBST1ZJREVSX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgICAvLyAxNi4zLjAgZXhwb3NlZCB0aGUgY29udGV4dCBvYmplY3QgYXMgXCJjb250ZXh0XCJcbiAgICAgICAgICAgIC8vIFBSICMxMjUwMSBjaGFuZ2VkIGl0IHRvIFwiX2NvbnRleHRcIiBmb3IgMTYuMy4xK1xuICAgICAgICAgICAgLy8gTk9URSBLZWVwIGluIHN5bmMgd2l0aCBpbnNwZWN0RWxlbWVudFJhdygpXG4gICAgICAgICAgICByZXNvbHZlZENvbnRleHQgPSBmaWJlci50eXBlLl9jb250ZXh0IHx8IGZpYmVyLnR5cGUuY29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBgJHtyZXNvbHZlZENvbnRleHQuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnfS5Qcm92aWRlcmA7XG4gICAgICAgICAgY2FzZSBDT05URVhUX05VTUJFUjpcbiAgICAgICAgICBjYXNlIENPTlRFWFRfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICAgIC8vIDE2LjMtMTYuNSByZWFkIGZyb20gXCJ0eXBlXCIgYmVjYXVzZSB0aGUgQ29uc3VtZXIgaXMgdGhlIGFjdHVhbCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICAgIC8vIDE2LjYrIHNob3VsZCByZWFkIGZyb20gXCJ0eXBlLl9jb250ZXh0XCIgYmVjYXVzZSBDb25zdW1lciBjYW4gYmUgZGlmZmVyZW50IChpbiBERVYpLlxuICAgICAgICAgICAgLy8gTk9URSBLZWVwIGluIHN5bmMgd2l0aCBpbnNwZWN0RWxlbWVudFJhdygpXG4gICAgICAgICAgICByZXNvbHZlZENvbnRleHQgPSBmaWJlci50eXBlLl9jb250ZXh0IHx8IGZpYmVyLnR5cGU7XG5cbiAgICAgICAgICAgIC8vIE5PVEU6IFRyYWNlVXBkYXRlc0JhY2tlbmRNYW5hZ2VyIGRlcGVuZHMgb24gdGhlIG5hbWUgZW5kaW5nIGluICcuQ29uc3VtZXInXG4gICAgICAgICAgICAvLyBJZiB5b3UgY2hhbmdlIHRoZSBuYW1lLCBmaWd1cmUgb3V0IGEgbW9yZSByZXNpbGllbnQgd2F5IHRvIGRldGVjdCBpdC5cbiAgICAgICAgICAgIHJldHVybiBgJHtyZXNvbHZlZENvbnRleHQuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnfS5Db25zdW1lcmA7XG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgY2FzZSBQUk9GSUxFUl9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBQUk9GSUxFUl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIGBQcm9maWxlcigke2ZpYmVyLm1lbW9pemVkUHJvcHMuaWR9KWA7XG4gICAgICAgICAgY2FzZSBTQ09QRV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBTQ09QRV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuICdTY29wZSc7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFVua25vd24gZWxlbWVudCB0eXBlLlxuICAgICAgICAgICAgLy8gVGhpcyBtYXkgbWVhbiBhIG5ldyBlbGVtZW50IHR5cGUgdGhhdCBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIERldlRvb2xzLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldERpc3BsYXlOYW1lRm9yRmliZXIsXG4gICAgZ2V0VHlwZVN5bWJvbCxcbiAgICBSZWFjdFByaW9yaXR5TGV2ZWxzLFxuICAgIFJlYWN0VHlwZU9mV29yayxcbiAgICBSZWFjdFR5cGVPZlNpZGVFZmZlY3QsXG4gICAgU3RyaWN0TW9kZUJpdHMsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2goXG4gIGhvb2s6IERldlRvb2xzSG9vayxcbiAgcmVuZGVyZXJJRDogbnVtYmVyLFxuICByZW5kZXJlcjogUmVhY3RSZW5kZXJlcixcbiAgZ2xvYmFsOiBPYmplY3QsXG4pOiBSZW5kZXJlckludGVyZmFjZSB7XG4gIC8vIE5ld2VyIHZlcnNpb25zIG9mIHRoZSByZWNvbmNpbGVyIHBhY2thZ2UgYWxzbyBzcGVjaWZpYyByZWNvbmNpbGVyIHZlcnNpb24uXG4gIC8vIElmIHRoYXQgdmVyc2lvbiBudW1iZXIgaXMgcHJlc2VudCwgdXNlIGl0LlxuICAvLyBUaGlyZCBwYXJ0eSByZW5kZXJlciB2ZXJzaW9ucyBtYXkgbm90IG1hdGNoIHRoZSByZWNvbmNpbGVyIHZlcnNpb24sXG4gIC8vIGFuZCB0aGUgbGF0dGVyIGlzIHdoYXQncyBpbXBvcnRhbnQgaW4gdGVybXMgb2YgdGFncyBhbmQgc3ltYm9scy5cbiAgY29uc3QgdmVyc2lvbiA9IHJlbmRlcmVyLnJlY29uY2lsZXJWZXJzaW9uIHx8IHJlbmRlcmVyLnZlcnNpb247XG5cbiAgY29uc3Qge1xuICAgIGdldERpc3BsYXlOYW1lRm9yRmliZXIsXG4gICAgZ2V0VHlwZVN5bWJvbCxcbiAgICBSZWFjdFByaW9yaXR5TGV2ZWxzLFxuICAgIFJlYWN0VHlwZU9mV29yayxcbiAgICBSZWFjdFR5cGVPZlNpZGVFZmZlY3QsXG4gICAgU3RyaWN0TW9kZUJpdHMsXG4gIH0gPSBnZXRJbnRlcm5hbFJlYWN0Q29uc3RhbnRzKHZlcnNpb24pO1xuICBjb25zdCB7XG4gICAgRGlkQ2FwdHVyZSxcbiAgICBIeWRyYXRpbmcsXG4gICAgTm9GbGFncyxcbiAgICBQZXJmb3JtZWRXb3JrLFxuICAgIFBsYWNlbWVudCxcbiAgfSA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdDtcbiAgY29uc3Qge1xuICAgIENhY2hlQ29tcG9uZW50LFxuICAgIENsYXNzQ29tcG9uZW50LFxuICAgIENvbnRleHRDb25zdW1lcixcbiAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQsXG4gICAgRm9yd2FyZFJlZixcbiAgICBGcmFnbWVudCxcbiAgICBGdW5jdGlvbkNvbXBvbmVudCxcbiAgICBIb3N0Um9vdCxcbiAgICBIb3N0UG9ydGFsLFxuICAgIEhvc3RDb21wb25lbnQsXG4gICAgSG9zdFRleHQsXG4gICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50LFxuICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQsXG4gICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50LFxuICAgIE1lbW9Db21wb25lbnQsXG4gICAgT2Zmc2NyZWVuQ29tcG9uZW50LFxuICAgIFNpbXBsZU1lbW9Db21wb25lbnQsXG4gICAgU3VzcGVuc2VDb21wb25lbnQsXG4gICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50LFxuICB9ID0gUmVhY3RUeXBlT2ZXb3JrO1xuICBjb25zdCB7XG4gICAgSW1tZWRpYXRlUHJpb3JpdHksXG4gICAgVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgTm9ybWFsUHJpb3JpdHksXG4gICAgTG93UHJpb3JpdHksXG4gICAgSWRsZVByaW9yaXR5LFxuICAgIE5vUHJpb3JpdHksXG4gIH0gPSBSZWFjdFByaW9yaXR5TGV2ZWxzO1xuXG4gIGNvbnN0IHtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZSxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHMsXG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgsXG4gICAgc2NoZWR1bGVSZWZyZXNoLFxuICAgIHNldEVycm9ySGFuZGxlcixcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXIsXG4gICAgc2NoZWR1bGVVcGRhdGUsXG4gIH0gPSByZW5kZXJlcjtcbiAgY29uc3Qgc3VwcG9ydHNUb2dnbGluZ0Vycm9yID1cbiAgICB0eXBlb2Ygc2V0RXJyb3JIYW5kbGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHNjaGVkdWxlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCBzdXBwb3J0c1RvZ2dsaW5nU3VzcGVuc2UgPVxuICAgIHR5cGVvZiBzZXRTdXNwZW5zZUhhbmRsZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygc2NoZWR1bGVVcGRhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKHR5cGVvZiBzY2hlZHVsZVJlZnJlc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBXaGVuIEZhc3QgUmVmcmVzaCB1cGRhdGVzIGEgY29tcG9uZW50LCB0aGUgZnJvbnRlbmQgbWF5IG5lZWQgdG8gcHVyZ2UgY2FjaGVkIGluZm9ybWF0aW9uLlxuICAgIC8vIEZvciBleGFtcGxlLCBBU1RzIGNhY2hlZCBmb3IgdGhlIGNvbXBvbmVudCAoZm9yIG5hbWVkIGhvb2tzKSBtYXkgbm8gbG9uZ2VyIGJlIHZhbGlkLlxuICAgIC8vIFNlbmQgYSBzaWduYWwgdG8gdGhlIGZyb250ZW5kIHRvIHB1cmdlIHRoaXMgY2FjaGVkIGluZm9ybWF0aW9uLlxuICAgIC8vIFRoZSBcImZhc3RSZWZyZXNoU2NoZWR1bGVkXCIgZGlzcGF0Y2hlZCBpcyBnbG9iYWwgKG5vdCBGaWJlciBvciBldmVuIFJlbmRlcmVyIHNwZWNpZmljKS5cbiAgICAvLyBUaGlzIGlzIGxlc3MgZWZmZWNpZW50IHNpbmNlIGl0IG1lYW5zIHRoZSBmcm9udC1lbmQgd2lsbCBuZWVkIHRvIHB1cmdlIHRoZSBlbnRpcmUgY2FjaGUsXG4gICAgLy8gYnV0IHRoaXMgaXMgcHJvYmFibHkgYW4gb2theSB0cmFkZSBvZmYgaW4gb3JkZXIgdG8gcmVkdWNlIGNvdXBsaW5nIGJldHdlZW4gdGhlIERldlRvb2xzIGFuZCBGYXN0IFJlZnJlc2guXG4gICAgcmVuZGVyZXIuc2NoZWR1bGVSZWZyZXNoID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhvb2suZW1pdCgnZmFzdFJlZnJlc2hTY2hlZHVsZWQnKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZVJlZnJlc2goLi4uYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFRyYWNrcyBGaWJlcnMgd2l0aCByZWNlbnRseSBjaGFuZ2VkIG51bWJlciBvZiBlcnJvci93YXJuaW5nIG1lc3NhZ2VzLlxuICAvLyBUaGVzZSBjb2xsZWN0aW9ucyBzdG9yZSB0aGUgRmliZXIgcmF0aGVyIHRoYW4gdGhlIElELFxuICAvLyBpbiBvcmRlciB0byBhdm9pZCBnZW5lcmF0aW5nIGFuIElEIGZvciBGaWJlcnMgdGhhdCBuZXZlciBnZXQgbW91bnRlZFxuICAvLyAoZHVlIHRvIGUuZy4gU3VzcGVuc2Ugb3IgZXJyb3IgYm91bmRhcmllcykuXG4gIC8vIG9uRXJyb3JPcldhcm5pbmcoKSBhZGRzIEZpYmVycyBhbmQgcmVjb3JkUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzKCkgbGF0ZXIgY2xlYXJzIHRoZW0uXG4gIGNvbnN0IGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHM6IFNldDxGaWJlcj4gPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHBlbmRpbmdGaWJlclRvRXJyb3JzTWFwOiBNYXA8RmliZXIsIE1hcDxzdHJpbmcsIG51bWJlcj4+ID0gbmV3IE1hcCgpO1xuICBjb25zdCBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwOiBNYXA8RmliZXIsIE1hcDxzdHJpbmcsIG51bWJlcj4+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIE1hcHBpbmcgb2YgZmliZXIgSURzIHRvIGVycm9yL3dhcm5pbmcgbWVzc2FnZXMgYW5kIGNvdW50cy5cbiAgY29uc3QgZmliZXJJRFRvRXJyb3JzTWFwOiBNYXA8bnVtYmVyLCBNYXA8c3RyaW5nLCBudW1iZXI+PiA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZmliZXJJRFRvV2FybmluZ3NNYXA6IE1hcDxudW1iZXIsIE1hcDxzdHJpbmcsIG51bWJlcj4+ID0gbmV3IE1hcCgpO1xuXG4gIGZ1bmN0aW9uIGNsZWFyRXJyb3JzQW5kV2FybmluZ3MoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGZpYmVySURUb0Vycm9yc01hcC5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG4gICAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChmaWJlcik7XG4gICAgICAgIHVwZGF0ZU1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRJZk5lY2Vzc2FyeShpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGZpYmVySURUb1dhcm5pbmdzTWFwLmtleXMoKSkge1xuICAgICAgY29uc3QgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGlkKTtcbiAgICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuYWRkKGZpYmVyKTtcbiAgICAgICAgdXBkYXRlTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudElmTmVjZXNzYXJ5KGlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlcklEVG9FcnJvcnNNYXAuY2xlYXIoKTtcbiAgICBmaWJlcklEVG9XYXJuaW5nc01hcC5jbGVhcigpO1xuXG4gICAgZmx1c2hQZW5kaW5nRXZlbnRzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lc3NhZ2VDb3VudEhlbHBlcihcbiAgICBmaWJlcklEOiBudW1iZXIsXG4gICAgcGVuZGluZ0ZpYmVyVG9NZXNzYWdlQ291bnRNYXA6IE1hcDxGaWJlciwgTWFwPHN0cmluZywgbnVtYmVyPj4sXG4gICAgZmliZXJJRFRvTWVzc2FnZUNvdW50TWFwOiBNYXA8bnVtYmVyLCBNYXA8c3RyaW5nLCBudW1iZXI+PixcbiAgKSB7XG4gICAgY29uc3QgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGZpYmVySUQpO1xuICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICAvLyBUaHJvdyBvdXQgYW55IHBlbmRpbmcgY2hhbmdlcy5cbiAgICAgIHBlbmRpbmdGaWJlclRvRXJyb3JzTWFwLmRlbGV0ZShmaWJlcik7XG5cbiAgICAgIGlmIChmaWJlcklEVG9NZXNzYWdlQ291bnRNYXAuaGFzKGZpYmVySUQpKSB7XG4gICAgICAgIGZpYmVySURUb01lc3NhZ2VDb3VudE1hcC5kZWxldGUoZmliZXJJRCk7XG5cbiAgICAgICAgLy8gSWYgcHJldmlvdXMgZmx1c2hlZCBjb3VudHMgaGF2ZSBjaGFuZ2VkLCBzY2hlZHVsZSBhbiB1cGRhdGUgdG9vLlxuICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChmaWJlcik7XG4gICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cygpO1xuXG4gICAgICAgIHVwZGF0ZU1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRJZk5lY2Vzc2FyeShmaWJlcklEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuZGVsZXRlKGZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckVycm9yc0ZvckZpYmVySUQoZmliZXJJRDogbnVtYmVyKSB7XG4gICAgY2xlYXJNZXNzYWdlQ291bnRIZWxwZXIoXG4gICAgICBmaWJlcklELFxuICAgICAgcGVuZGluZ0ZpYmVyVG9FcnJvcnNNYXAsXG4gICAgICBmaWJlcklEVG9FcnJvcnNNYXAsXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyV2FybmluZ3NGb3JGaWJlcklEKGZpYmVySUQ6IG51bWJlcikge1xuICAgIGNsZWFyTWVzc2FnZUNvdW50SGVscGVyKFxuICAgICAgZmliZXJJRCxcbiAgICAgIHBlbmRpbmdGaWJlclRvV2FybmluZ3NNYXAsXG4gICAgICBmaWJlcklEVG9XYXJuaW5nc01hcCxcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudElmTmVjZXNzYXJ5KFxuICAgIGZpYmVySUQ6IG51bWJlcixcbiAgKTogdm9pZCB7XG4gICAgaWYgKFxuICAgICAgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCAhPT0gbnVsbCAmJlxuICAgICAgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudC5pZCA9PT0gZmliZXJJRFxuICAgICkge1xuICAgICAgaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCB3aGVuIGFuIGVycm9yIG9yIHdhcm5pbmcgaXMgbG9nZ2VkIGR1cmluZyByZW5kZXIsIGNvbW1pdCwgb3IgcGFzc2l2ZSAoaW5jbHVkaW5nIHVubW91bnQgZnVuY3Rpb25zKS5cbiAgZnVuY3Rpb24gb25FcnJvck9yV2FybmluZyhcbiAgICBmaWJlcjogRmliZXIsXG4gICAgdHlwZTogJ2Vycm9yJyB8ICd3YXJuJyxcbiAgICBhcmdzOiAkUmVhZE9ubHlBcnJheTxhbnk+LFxuICApOiB2b2lkIHtcbiAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgY29uc3QgbWF5YmVJRCA9IGdldEZpYmVySURVbnNhZmUoZmliZXIpO1xuICAgICAgLy8gaWYgdGhpcyBpcyBhbiBlcnJvciBzaW11bGF0ZWQgYnkgdXMgdG8gdHJpZ2dlciBlcnJvciBib3VuZGFyeSwgaWdub3JlXG4gICAgICBpZiAobWF5YmVJRCAhPSBudWxsICYmIGZvcmNlRXJyb3JGb3JGaWJlcklEcy5nZXQobWF5YmVJRCkgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gZm9ybWF0KC4uLmFyZ3MpO1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCdvbkVycm9yT3JXYXJuaW5nJywgZmliZXIsIG51bGwsIGAke3R5cGV9OiBcIiR7bWVzc2FnZX1cImApO1xuICAgIH1cblxuICAgIC8vIE1hcmsgdGhpcyBGaWJlciBhcyBuZWVkZWQgaXRzIHdhcm5pbmcvZXJyb3IgY291bnQgdXBkYXRlZCBkdXJpbmcgdGhlIG5leHQgZmx1c2guXG4gICAgZmliZXJzV2l0aENoYW5nZWRFcnJvck9yV2FybmluZ0NvdW50cy5hZGQoZmliZXIpO1xuXG4gICAgLy8gVHJhY2sgdGhlIHdhcm5pbmcvZXJyb3IgZm9yIGxhdGVyLlxuICAgIGNvbnN0IGZpYmVyTWFwID1cbiAgICAgIHR5cGUgPT09ICdlcnJvcicgPyBwZW5kaW5nRmliZXJUb0Vycm9yc01hcCA6IHBlbmRpbmdGaWJlclRvV2FybmluZ3NNYXA7XG4gICAgY29uc3QgbWVzc2FnZU1hcCA9IGZpYmVyTWFwLmdldChmaWJlcik7XG4gICAgaWYgKG1lc3NhZ2VNYXAgIT0gbnVsbCkge1xuICAgICAgY29uc3QgY291bnQgPSBtZXNzYWdlTWFwLmdldChtZXNzYWdlKSB8fCAwO1xuICAgICAgbWVzc2FnZU1hcC5zZXQobWVzc2FnZSwgY291bnQgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmliZXJNYXAuc2V0KGZpYmVyLCBuZXcgTWFwKFtbbWVzc2FnZSwgMV1dKSk7XG4gICAgfVxuXG4gICAgLy8gUGFzc2l2ZSBlZmZlY3RzIG1heSB0cmlnZ2VyIGVycm9ycyBvciB3YXJuaW5ncyB0b287XG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzaG91bGQgd2FpdCB1bnRpbCB0aGUgcmVzdCBvZiB0aGUgcGFzc2l2ZSBlZmZlY3RzIGhhdmUgcnVuLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGRuJ3Qgd2FpdCB1bnRpbCB0aGUgbmV4dCBjb21taXQgYmVjYXVzZSB0aGF0IG1pZ2h0IGJlIGEgbG9uZyB0aW1lLlxuICAgIC8vIFRoaXMgd291bGQgYWxzbyBjYXVzZSBcInRlYXJpbmdcIiBiZXR3ZWVuIGFuIGluc3BlY3RlZCBDb21wb25lbnQgYW5kIHRoZSB0cmVlIHZpZXcuXG4gICAgLy8gVGhlbiBhZ2FpbiB3ZSBkb24ndCB3YW50IHRvIGZsdXNoIHRvbyBzb29uIGJlY2F1c2UgdGhpcyBjb3VsZCBiZSBhbiBlcnJvciBkdXJpbmcgYXN5bmMgcmVuZGVyaW5nLlxuICAgIC8vIFVzZSBhIGRlYm91bmNlIHRlY2huaXF1ZSB0byBlbnN1cmUgdGhhdCB3ZSdsbCBldmVudHVhbGx5IGZsdXNoLlxuICAgIGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheSgpO1xuICB9XG5cbiAgLy8gUGF0Y2hpbmcgdGhlIGNvbnNvbGUgZW5hYmxlcyBEZXZUb29scyB0byBkbyBhIGZldyB1c2VmdWwgdGhpbmdzOlxuICAvLyAqIEFwcGVuZCBjb21wb25lbnQgc3RhY2tzIHRvIHdhcm5pbmdzIGFuZCBlcnJvciBtZXNzYWdlc1xuICAvLyAqIERpc2FibGUgbG9nZ2luZyBkdXJpbmcgcmUtcmVuZGVycyB0byBpbnNwZWN0IGhvb2tzIChzZWUgaW5zcGVjdEhvb2tzT2ZGaWJlcilcbiAgLy9cbiAgLy8gRG9uJ3QgcGF0Y2ggaW4gdGVzdCBlbnZpcm9ubWVudHMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGludGVyZmVyZSB3aXRoIEplc3QncyBvd24gY29uc29sZSBvdmVycmlkZXMuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnKSB7XG4gICAgcmVnaXN0ZXJSZW5kZXJlcldpdGhDb25zb2xlKHJlbmRlcmVyLCBvbkVycm9yT3JXYXJuaW5nKTtcblxuICAgIC8vIFRoZSByZW5kZXJlciBpbnRlcmZhY2UgY2FuJ3QgcmVhZCB0aGVzZSBwcmVmZXJlbmNlcyBkaXJlY3RseSxcbiAgICAvLyBiZWNhdXNlIGl0IGlzIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2Ugd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBleHRlbnNpb24uXG4gICAgLy8gSXQgcmVsaWVzIG9uIHRoZSBleHRlbnNpb24gdG8gcGFzcyB0aGUgcHJlZmVyZW5jZSB0aHJvdWdoIHZpYSB0aGUgZ2xvYmFsLlxuICAgIGNvbnN0IGFwcGVuZENvbXBvbmVudFN0YWNrID1cbiAgICAgIHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0FQUEVORF9DT01QT05FTlRfU1RBQ0tfXyAhPT0gZmFsc2U7XG4gICAgY29uc3QgYnJlYWtPbkNvbnNvbGVFcnJvcnMgPVxuICAgICAgd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQlJFQUtfT05fQ09OU09MRV9FUlJPUlNfXyA9PT0gdHJ1ZTtcbiAgICBjb25zdCBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMgPVxuICAgICAgd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19fICE9PSBmYWxzZTtcbiAgICBjb25zdCBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUgPVxuICAgICAgd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfSElERV9DT05TT0xFX0xPR1NfSU5fU1RSSUNUX01PREVfXyA9PT0gdHJ1ZTtcbiAgICBjb25zdCBicm93c2VyVGhlbWUgPSB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19CUk9XU0VSX1RIRU1FX187XG5cbiAgICBwYXRjaENvbnNvbGUoe1xuICAgICAgYXBwZW5kQ29tcG9uZW50U3RhY2ssXG4gICAgICBicmVha09uQ29uc29sZUVycm9ycyxcbiAgICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyxcbiAgICAgIGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSxcbiAgICAgIGJyb3dzZXJUaGVtZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGRlYnVnID0gKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBmaWJlcjogRmliZXIsXG4gICAgcGFyZW50RmliZXI6ID9GaWJlcixcbiAgICBleHRyYVN0cmluZz86IHN0cmluZyA9ICcnLFxuICApOiB2b2lkID0+IHtcbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBjb25zdCBkaXNwbGF5TmFtZSA9XG4gICAgICAgIGZpYmVyLnRhZyArICc6JyArIChnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnbnVsbCcpO1xuXG4gICAgICBjb25zdCBtYXliZUlEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcikgfHwgJzxubyBpZD4nO1xuICAgICAgY29uc3QgcGFyZW50RGlzcGxheU5hbWUgPSBwYXJlbnRGaWJlclxuICAgICAgICA/IHBhcmVudEZpYmVyLnRhZyArXG4gICAgICAgICAgJzonICtcbiAgICAgICAgICAoZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihwYXJlbnRGaWJlcikgfHwgJ251bGwnKVxuICAgICAgICA6ICcnO1xuICAgICAgY29uc3QgbWF5YmVQYXJlbnRJRCA9IHBhcmVudEZpYmVyXG4gICAgICAgID8gZ2V0RmliZXJJRFVuc2FmZShwYXJlbnRGaWJlcikgfHwgJzxuby1pZD4nXG4gICAgICAgIDogJyc7XG5cbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgICAgIGBbcmVuZGVyZXJdICVjJHtuYW1lfSAlYyR7ZGlzcGxheU5hbWV9ICgke21heWJlSUR9KSAlYyR7XG4gICAgICAgICAgcGFyZW50RmliZXIgPyBgJHtwYXJlbnREaXNwbGF5TmFtZX0gKCR7bWF5YmVQYXJlbnRJRH0pYCA6ICcnXG4gICAgICAgIH0gJWMke2V4dHJhU3RyaW5nfWAsXG4gICAgICAgICdjb2xvcjogcmVkOyBmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgICAnY29sb3I6IGJsdWU7JyxcbiAgICAgICAgJ2NvbG9yOiBwdXJwbGU7JyxcbiAgICAgICAgJ2NvbG9yOiBibGFjazsnLFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBuZXcgRXJyb3IoKS5zdGFja1xuICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAuam9pbignXFxuJyksXG4gICAgICApO1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDb25maWd1cmFibGUgQ29tcG9uZW50cyB0cmVlIGZpbHRlcnMuXG4gIGNvbnN0IGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXM6IFNldDxSZWdFeHA+ID0gbmV3IFNldCgpO1xuICBjb25zdCBoaWRlRWxlbWVudHNXaXRoUGF0aHM6IFNldDxSZWdFeHA+ID0gbmV3IFNldCgpO1xuICBjb25zdCBoaWRlRWxlbWVudHNXaXRoVHlwZXM6IFNldDxFbGVtZW50VHlwZT4gPSBuZXcgU2V0KCk7XG5cbiAgLy8gSGlnaGxpZ2h0IHVwZGF0ZXNcbiAgbGV0IHRyYWNlVXBkYXRlc0VuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgY29uc3QgdHJhY2VVcGRhdGVzRm9yTm9kZXM6IFNldDxOYXRpdmVUeXBlPiA9IG5ldyBTZXQoKTtcblxuICBmdW5jdGlvbiBhcHBseUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVyczogQXJyYXk8Q29tcG9uZW50RmlsdGVyPikge1xuICAgIGhpZGVFbGVtZW50c1dpdGhUeXBlcy5jbGVhcigpO1xuICAgIGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMuY2xlYXIoKTtcbiAgICBoaWRlRWxlbWVudHNXaXRoUGF0aHMuY2xlYXIoKTtcblxuICAgIGNvbXBvbmVudEZpbHRlcnMuZm9yRWFjaChjb21wb25lbnRGaWx0ZXIgPT4ge1xuICAgICAgaWYgKCFjb21wb25lbnRGaWx0ZXIuaXNFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb21wb25lbnRGaWx0ZXIudHlwZSkge1xuICAgICAgICBjYXNlIENvbXBvbmVudEZpbHRlckRpc3BsYXlOYW1lOlxuICAgICAgICAgIGlmIChjb21wb25lbnRGaWx0ZXIuaXNWYWxpZCAmJiBjb21wb25lbnRGaWx0ZXIudmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzLmFkZChcbiAgICAgICAgICAgICAgbmV3IFJlZ0V4cChjb21wb25lbnRGaWx0ZXIudmFsdWUsICdpJyksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZTpcbiAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoVHlwZXMuYWRkKGNvbXBvbmVudEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29tcG9uZW50RmlsdGVyTG9jYXRpb246XG4gICAgICAgICAgaWYgKGNvbXBvbmVudEZpbHRlci5pc1ZhbGlkICYmIGNvbXBvbmVudEZpbHRlci52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGhpZGVFbGVtZW50c1dpdGhQYXRocy5hZGQobmV3IFJlZ0V4cChjb21wb25lbnRGaWx0ZXIudmFsdWUsICdpJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb21wb25lbnRGaWx0ZXJIT0M6XG4gICAgICAgICAgaGlkZUVsZW1lbnRzV2l0aERpc3BsYXlOYW1lcy5hZGQobmV3IFJlZ0V4cCgnXFxcXCgnKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYEludmFsaWQgY29tcG9uZW50IGZpbHRlciB0eXBlIFwiJHtjb21wb25lbnRGaWx0ZXIudHlwZX1cImAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRoZSByZW5kZXJlciBpbnRlcmZhY2UgY2FuJ3QgcmVhZCBzYXZlZCBjb21wb25lbnQgZmlsdGVycyBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB0aGV5IGFyZSBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZXh0ZW5zaW9uLlxuICAvLyBJbnN0ZWFkIGl0IHJlbGllcyBvbiB0aGUgZXh0ZW5zaW9uIHRvIHBhc3MgZmlsdGVycyB0aHJvdWdoLlxuICBpZiAod2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQ09NUE9ORU5UX0ZJTFRFUlNfXyAhPSBudWxsKSB7XG4gICAgYXBwbHlDb21wb25lbnRGaWx0ZXJzKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0NPTVBPTkVOVF9GSUxURVJTX18pO1xuICB9IGVsc2Uge1xuICAgIC8vIFVuZm9ydHVuYXRlbHkgdGhpcyBmZWF0dXJlIGlzIG5vdCBleHBlY3RlZCB0byB3b3JrIGZvciBSZWFjdCBOYXRpdmUgZm9yIG5vdy5cbiAgICAvLyBJdCB3b3VsZCBiZSBhbm5veWluZyBmb3IgdXMgdG8gc3BhbSBZZWxsb3dCb3ggd2FybmluZ3Mgd2l0aCB1bmFjdGlvbmFibGUgc3R1ZmYsXG4gICAgLy8gc28gZm9yIG5vdyBqdXN0IHNraXAgdGhpcyBtZXNzYWdlLi4uXG4gICAgLy9jb25zb2xlLndhcm4oJ+Kam++4jyBEZXZUb29sczogQ291bGQgbm90IGxvY2F0ZSBzYXZlZCBjb21wb25lbnQgZmlsdGVycycpO1xuXG4gICAgLy8gRmFsbGJhY2sgdG8gYXNzdW1pbmcgdGhlIGRlZmF1bHQgZmlsdGVycyBpbiB0aGlzIGNhc2UuXG4gICAgYXBwbHlDb21wb25lbnRGaWx0ZXJzKGdldERlZmF1bHRDb21wb25lbnRGaWx0ZXJzKCkpO1xuICB9XG5cbiAgLy8gSWYgbmVjZXNzYXJ5LCB3ZSBjYW4gcmV2aXNpdCBvcHRpbWl6aW5nIHRoaXMgb3BlcmF0aW9uLlxuICAvLyBGb3IgZXhhbXBsZSwgd2UgY291bGQgYWRkIGEgbmV3IHJlY3Vyc2l2ZSB1bm1vdW50IHRyZWUgb3BlcmF0aW9uLlxuICAvLyBUaGUgdW5tb3VudCBvcGVyYXRpb25zIGFyZSBhbHJlYWR5IHNpZ25pZmljYW50bHkgc21hbGxlciB0aGFuIG1vdW50IG9wZXJhdGlvbnMgdGhvdWdoLlxuICAvLyBUaGlzIGlzIHNvbWV0aGluZyB0byBrZWVwIGluIG1pbmQgZm9yIGxhdGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDb21wb25lbnRGaWx0ZXJzKGNvbXBvbmVudEZpbHRlcnM6IEFycmF5PENvbXBvbmVudEZpbHRlcj4pIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIC8vIFJlLW1vdW50aW5nIGEgdHJlZSB3aGlsZSBwcm9maWxpbmcgaXMgaW4gcHJvZ3Jlc3MgbWlnaHQgYnJlYWsgYSBsb3Qgb2YgYXNzdW1wdGlvbnMuXG4gICAgICAvLyBJZiBuZWNlc3NhcnksIHdlIGNvdWxkIHN1cHBvcnQgdGhpcy0gYnV0IGl0IGRvZXNuJ3Qgc2VlbSBsaWtlIGEgbmVjZXNzYXJ5IHVzZSBjYXNlLlxuICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBtb2RpZnkgZmlsdGVyIHByZWZlcmVuY2VzIHdoaWxlIHByb2ZpbGluZycpO1xuICAgIH1cblxuICAgIC8vIFJlY3Vyc2l2ZWx5IHVubW91bnQgYWxsIHJvb3RzLlxuICAgIGhvb2suZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKS5mb3JFYWNoKHJvb3QgPT4ge1xuICAgICAgY3VycmVudFJvb3RJRCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKHJvb3QuY3VycmVudCk7XG4gICAgICAvLyBUaGUgVFJFRV9PUEVSQVRJT05fUkVNT1ZFX1JPT1Qgb3BlcmF0aW9uIHNlcnZlcyB0d28gcHVycG9zZXM6XG4gICAgICAvLyAxLiBJdCBhdm9pZHMgc2VuZGluZyB1bm5lY2Vzc2FyeSBicmlkZ2UgdHJhZmZpYyB0byBjbGVhciBhIHJvb3QuXG4gICAgICAvLyAyLiBJdCBwcmVzZXJ2ZXMgRmliZXIgSURzIHdoZW4gcmVtb3VudGluZyAoYmVsb3cpIHdoaWNoIGluIHR1cm4gSUQgdG8gZXJyb3Ivd2FybmluZyBtYXBwaW5nLlxuICAgICAgcHVzaE9wZXJhdGlvbihUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCk7XG4gICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdCk7XG4gICAgICBjdXJyZW50Um9vdElEID0gLTE7XG4gICAgfSk7XG5cbiAgICBhcHBseUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVycyk7XG5cbiAgICAvLyBSZXNldCBwc2V1ZG8gY291bnRlcnMgc28gdGhhdCBuZXcgcGF0aCBzZWxlY3Rpb25zIHdpbGwgYmUgcGVyc2lzdGVkLlxuICAgIHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuY2xlYXIoKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IHJlLW1vdW50IGFsbCByb290cyB3aXRoIG5ldyBmaWx0ZXIgY3JpdGVyaWEgYXBwbGllZC5cbiAgICBob29rLmdldEZpYmVyUm9vdHMocmVuZGVyZXJJRCkuZm9yRWFjaChyb290ID0+IHtcbiAgICAgIGN1cnJlbnRSb290SUQgPSBnZXRPckdlbmVyYXRlRmliZXJJRChyb290LmN1cnJlbnQpO1xuICAgICAgc2V0Um9vdFBzZXVkb0tleShjdXJyZW50Um9vdElELCByb290LmN1cnJlbnQpO1xuICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgbnVsbCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KTtcbiAgICAgIGN1cnJlbnRSb290SUQgPSAtMTtcbiAgICB9KTtcblxuICAgIC8vIEFsc28gcmUtZXZhbHVhdGUgYWxsIGVycm9yIGFuZCB3YXJuaW5nIGNvdW50cyBnaXZlbiB0aGUgbmV3IGZpbHRlcnMuXG4gICAgcmVldmFsdWF0ZUVycm9yc0FuZFdhcm5pbmdzKCk7XG4gICAgZmx1c2hQZW5kaW5nRXZlbnRzKCk7XG4gIH1cblxuICAvLyBOT1RJQ0UgS2VlcCBpbiBzeW5jIHdpdGggZ2V0KkZvckZpYmVyIG1ldGhvZHNcbiAgZnVuY3Rpb24gc2hvdWxkRmlsdGVyRmliZXIoZmliZXI6IEZpYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3Qge19kZWJ1Z1NvdXJjZSwgdGFnLCB0eXBlfSA9IGZpYmVyO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAvLyBUT0RPOiBpZGVhbGx5IHdlIHdvdWxkIHNob3cgZGVoeWRyYXRlZCBTdXNwZW5zZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gSG93ZXZlciwgaXQgaGFzIHNvbWUgc3BlY2lhbCBiZWhhdmlvciAobGlrZSBkaXNjb25uZWN0aW5nXG4gICAgICAgIC8vIGFuIGFsdGVybmF0ZSBhbmQgdHVybmluZyBpbnRvIHJlYWwgU3VzcGVuc2UpIHdoaWNoIGJyZWFrcyBEZXZUb29scy5cbiAgICAgICAgLy8gRm9yIG5vdywgaWdub3JlIGl0LCBhbmQgb25seSBzaG93IGl0IG9uY2UgaXQgZ2V0cyBoeWRyYXRlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2J2YXVnaG4vcmVhY3QtZGV2dG9vbHMtZXhwZXJpbWVudGFsL2lzc3Vlcy8xOTdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgLy8gSXQgaXMgbmV2ZXIgdmFsaWQgdG8gZmlsdGVyIHRoZSByb290IGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnN0IHR5cGVTeW1ib2wgPSBnZXRUeXBlU3ltYm9sKHR5cGUpO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZVN5bWJvbCkge1xuICAgICAgICAgIGNhc2UgQ09OQ1VSUkVOVF9NT0RFX05VTUJFUjpcbiAgICAgICAgICBjYXNlIENPTkNVUlJFTlRfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgIGNhc2UgREVQUkVDQVRFRF9BU1lOQ19NT0RFX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudFR5cGUgPSBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKTtcbiAgICBpZiAoaGlkZUVsZW1lbnRzV2l0aFR5cGVzLmhhcyhlbGVtZW50VHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpO1xuICAgICAgaWYgKGRpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICAgICAgZm9yIChjb25zdCBkaXNwbGF5TmFtZVJlZ0V4cCBvZiBoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzKSB7XG4gICAgICAgICAgaWYgKGRpc3BsYXlOYW1lUmVnRXhwLnRlc3QoZGlzcGxheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX2RlYnVnU291cmNlICE9IG51bGwgJiYgaGlkZUVsZW1lbnRzV2l0aFBhdGhzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCB7ZmlsZU5hbWV9ID0gX2RlYnVnU291cmNlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICAgIGZvciAoY29uc3QgcGF0aFJlZ0V4cCBvZiBoaWRlRWxlbWVudHNXaXRoUGF0aHMpIHtcbiAgICAgICAgaWYgKHBhdGhSZWdFeHAudGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE5PVElDRSBLZWVwIGluIHN5bmMgd2l0aCBzaG91bGRGaWx0ZXJGaWJlcigpIGFuZCBvdGhlciBnZXQqRm9yRmliZXIgbWV0aG9kc1xuICBmdW5jdGlvbiBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyOiBGaWJlcik6IEVsZW1lbnRUeXBlIHtcbiAgICBjb25zdCB7dHlwZSwgdGFnfSA9IGZpYmVyO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlQ2xhc3M7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVGdW5jdGlvbjtcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlRm9yd2FyZFJlZjtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZVJvb3Q7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQ7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd247XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZU1lbW87XG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVTdXNwZW5zZTtcbiAgICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVTdXNwZW5zZUxpc3Q7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zdCB0eXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbCh0eXBlKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGVTeW1ib2wpIHtcbiAgICAgICAgICBjYXNlIENPTkNVUlJFTlRfTU9ERV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICBjYXNlIERFUFJFQ0FURURfQVNZTkNfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd247XG4gICAgICAgICAgY2FzZSBQUk9WSURFUl9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBQUk9WSURFUl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlQ29udGV4dDtcbiAgICAgICAgICBjYXNlIENPTlRFWFRfTlVNQkVSOlxuICAgICAgICAgIGNhc2UgQ09OVEVYVF9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlQ29udGV4dDtcbiAgICAgICAgICBjYXNlIFNUUklDVF9NT0RFX05VTUJFUjpcbiAgICAgICAgICBjYXNlIFNUUklDVF9NT0RFX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVPdGhlck9yVW5rbm93bjtcbiAgICAgICAgICBjYXNlIFBST0ZJTEVSX05VTUJFUjpcbiAgICAgICAgICBjYXNlIFBST0ZJTEVSX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVQcm9maWxlcjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd247XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBNYXAgb2Ygb25lIG9yIG1vcmUgRmliZXJzIGluIGEgcGFpciB0byB0aGVpciB1bmlxdWUgaWQgbnVtYmVyLlxuICAvLyBXZSB0cmFjayBib3RoIEZpYmVycyB0byBzdXBwb3J0IEZhc3QgUmVmcmVzaCxcbiAgLy8gd2hpY2ggbWF5IGZvcmNlZnVsbHkgcmVwbGFjZSBvbmUgb2YgdGhlIHBhaXIgYXMgcGFydCBvZiBob3QgcmVsb2FkaW5nLlxuICAvLyBJbiB0aGF0IGNhc2UgaXQncyBzdGlsbCBpbXBvcnRhbnQgdG8gYmUgYWJsZSB0byBsb2NhdGUgdGhlIHByZXZpb3VzIElEIGR1cmluZyBzdWJzZXF1ZW50IHJlbmRlcnMuXG4gIGNvbnN0IGZpYmVyVG9JRE1hcDogTWFwPEZpYmVyLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIE1hcCBvZiBpZCB0byBvbmUgKGFyYml0cmFyeSkgRmliZXIgaW4gYSBwYWlyLlxuICAvLyBUaGlzIE1hcCBpcyB1c2VkIHRvIGUuZy4gZ2V0IHRoZSBkaXNwbGF5IG5hbWUgZm9yIGEgRmliZXIgb3Igc2NoZWR1bGUgYW4gdXBkYXRlLFxuICAvLyBvcGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIHRoZSBzYW1lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYW5kIHdvcmstaW4tcHJvZ3Jlc3MgRmliZXIgaXMgdXNlZC5cbiAgY29uc3QgaWRUb0FyYml0cmFyeUZpYmVyTWFwOiBNYXA8bnVtYmVyLCBGaWJlcj4gPSBuZXcgTWFwKCk7XG5cbiAgLy8gV2hlbiBwcm9maWxpbmcgaXMgc3VwcG9ydGVkLCB3ZSBzdG9yZSB0aGUgbGF0ZXN0IHRyZWUgYmFzZSBkdXJhdGlvbnMgZm9yIGVhY2ggRmliZXIuXG4gIC8vIFRoaXMgaXMgc28gdGhhdCB3ZSBjYW4gcXVpY2tseSBjYXB0dXJlIGEgc25hcHNob3Qgb2YgdGhvc2UgdmFsdWVzIGlmIHByb2ZpbGluZyBzdGFydHMuXG4gIC8vIElmIHdlIGRpZG4ndCBzdG9yZSB0aGVzZSB2YWx1ZXMsIHdlJ2QgaGF2ZSB0byBjcmF3bCB0aGUgdHJlZSB3aGVuIHByb2ZpbGluZyBzdGFydGVkLFxuICAvLyBhbmQgdXNlIGEgc2xvdyBwYXRoIHRvIGZpbmQgZWFjaCBvZiB0aGUgY3VycmVudCBGaWJlcnMuXG4gIGNvbnN0IGlkVG9UcmVlQmFzZUR1cmF0aW9uTWFwOiBNYXA8bnVtYmVyLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIFdoZW4gcHJvZmlsaW5nIGlzIHN1cHBvcnRlZCwgd2Ugc3RvcmUgdGhlIGxhdGVzdCB0cmVlIGJhc2UgZHVyYXRpb25zIGZvciBlYWNoIEZpYmVyLlxuICAvLyBUaGlzIG1hcCBlbmFibGVzIHVzIHRvIGZpbHRlciB0aGVzZSB0aW1lcyBieSByb290IHdoZW4gc2VuZGluZyB0aGVtIHRvIHRoZSBmcm9udGVuZC5cbiAgY29uc3QgaWRUb1Jvb3RNYXA6IE1hcDxudW1iZXIsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG5cbiAgLy8gV2hlbiBhIG1vdW50IG9yIHVwZGF0ZSBpcyBpbiBwcm9ncmVzcywgdGhpcyB2YWx1ZSB0cmFja3MgdGhlIHJvb3QgdGhhdCBpcyBiZWluZyBvcGVyYXRlZCBvbi5cbiAgbGV0IGN1cnJlbnRSb290SUQ6IG51bWJlciA9IC0xO1xuXG4gIC8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBmb3IgYSBGaWJlciBvciBnZW5lcmF0ZXMgYW5kIGNhY2hlcyBhIG5ldyBvbmUgaWYgdGhlIEZpYmVyIGhhc24ndCBiZWVuIHNlZW4gYmVmb3JlLlxuICAvLyBPbmNlIHRoaXMgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZCBmb3IgYSBGaWJlciwgdW50cmFja0ZpYmVySUQoKSBzaG91bGQgYWx3YXlzIGJlIGNhbGxlZCBsYXRlciB0byBhdm9pZCBsZWFraW5nLlxuICBmdW5jdGlvbiBnZXRPckdlbmVyYXRlRmliZXJJRChmaWJlcjogRmliZXIpOiBudW1iZXIge1xuICAgIGxldCBpZCA9IG51bGw7XG4gICAgaWYgKGZpYmVyVG9JRE1hcC5oYXMoZmliZXIpKSB7XG4gICAgICBpZCA9IGZpYmVyVG9JRE1hcC5nZXQoZmliZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7YWx0ZXJuYXRlfSA9IGZpYmVyO1xuICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmaWJlclRvSURNYXAuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgaWQgPSBmaWJlclRvSURNYXAuZ2V0KGFsdGVybmF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRpZEdlbmVyYXRlSUQgPSBmYWxzZTtcbiAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgIGRpZEdlbmVyYXRlSUQgPSB0cnVlO1xuICAgICAgaWQgPSBnZXRVSUQoKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHJlZmluZW1lbnQgaXMgZm9yIEZsb3cgcHVycG9zZXMgb25seS5cbiAgICBjb25zdCByZWZpbmVkSUQgPSAoKGlkOiBhbnkpOiBudW1iZXIpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIHRyYWNraW5nIHRoaXMgRmliZXJcbiAgICAvLyBlLmcuIGlmIGl0IGp1c3QgbW91bnRlZCBvciBhbiBlcnJvciB3YXMgbG9nZ2VkIGR1cmluZyBpbml0aWFsIHJlbmRlci5cbiAgICBpZiAoIWZpYmVyVG9JRE1hcC5oYXMoZmliZXIpKSB7XG4gICAgICBmaWJlclRvSURNYXAuc2V0KGZpYmVyLCByZWZpbmVkSUQpO1xuICAgICAgaWRUb0FyYml0cmFyeUZpYmVyTWFwLnNldChyZWZpbmVkSUQsIGZpYmVyKTtcbiAgICB9XG5cbiAgICAvLyBBbHNvIG1ha2Ugc3VyZSB3ZSdyZSB0cmFja2luZyBpdHMgYWx0ZXJuYXRlLFxuICAgIC8vIGUuZy4gaW4gY2FzZSB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgYWZ0ZXIgbW91bnQuXG4gICAgY29uc3Qge2FsdGVybmF0ZX0gPSBmaWJlcjtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICBpZiAoIWZpYmVyVG9JRE1hcC5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICBmaWJlclRvSURNYXAuc2V0KGFsdGVybmF0ZSwgcmVmaW5lZElEKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBpZiAoZGlkR2VuZXJhdGVJRCkge1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAnZ2V0T3JHZW5lcmF0ZUZpYmVySUQoKScsXG4gICAgICAgICAgZmliZXIsXG4gICAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICAgICdHZW5lcmF0ZWQgYSBuZXcgVUlEJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVmaW5lZElEO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhbiBJRCBpZiBvbmUgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQgZm9yIHRoZSBGaWJlciBvciB0aHJvd3MuXG4gIGZ1bmN0aW9uIGdldEZpYmVySURUaHJvd3MoZmliZXI6IEZpYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBtYXliZUlEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG4gICAgaWYgKG1heWJlSUQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBtYXliZUlEO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGBDb3VsZCBub3QgZmluZCBJRCBmb3IgRmliZXIgXCIke2dldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICcnfVwiYCxcbiAgICApO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhbiBJRCBpZiBvbmUgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQgZm9yIHRoZSBGaWJlciBvciBudWxsIGlmIG9uZSBoYXMgbm90IGJlZW4gZ2VuZXJhdGVkLlxuICAvLyBVc2UgdGhpcyBtZXRob2Qgd2hpbGUgZS5nLiBsb2dnaW5nIHRvIGF2b2lkIG92ZXItcmV0YWluaW5nIEZpYmVycy5cbiAgZnVuY3Rpb24gZ2V0RmliZXJJRFVuc2FmZShmaWJlcjogRmliZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoZmliZXJUb0lETWFwLmhhcyhmaWJlcikpIHtcbiAgICAgIHJldHVybiAoKGZpYmVyVG9JRE1hcC5nZXQoZmliZXIpOiBhbnkpOiBudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7YWx0ZXJuYXRlfSA9IGZpYmVyO1xuICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmaWJlclRvSURNYXAuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgcmV0dXJuICgoZmliZXJUb0lETWFwLmdldChhbHRlcm5hdGUpOiBhbnkpOiBudW1iZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFJlbW92ZXMgYSBGaWJlciAoYW5kIGl0cyBhbHRlcm5hdGUpIGZyb20gdGhlIE1hcHMgdXNlZCB0byB0cmFjayB0aGVpciBpZC5cbiAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIGFsd2F5cyBiZSBjYWxsZWQgd2hlbiBhIEZpYmVyIGlzIHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHVudHJhY2tGaWJlcklEKGZpYmVyOiBGaWJlcikge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCd1bnRyYWNrRmliZXJJRCgpJywgZmliZXIsIGZpYmVyLnJldHVybiwgJ3NjaGVkdWxlIGFmdGVyIGRlbGF5Jyk7XG4gICAgfVxuXG4gICAgLy8gVW50cmFjayBGaWJlcnMgYWZ0ZXIgYSBzbGlnaHQgZGVsYXkgaW4gb3JkZXIgdG8gc3VwcG9ydCBhIEZhc3QgUmVmcmVzaCBlZGdlIGNhc2U6XG4gICAgLy8gMS4gQ29tcG9uZW50IHR5cGUgaXMgdXBkYXRlZCBhbmQgRmFzdCBSZWZyZXNoIHNjaGVkdWxlcyBhbiB1cGRhdGUrcmVtb3VudC5cbiAgICAvLyAyLiBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKSBydW5zLCBzZWVzIHRoZSBvbGQgRmliZXIgaXMgbm8gbG9uZ2VyIG1vdW50ZWRcbiAgICAvLyAgICAoaXQncyBiZWVuIGRpc2Nvbm5lY3RlZCBieSBGYXN0IFJlZnJlc2gpLCBhbmQgY2FsbHMgdW50cmFja0ZpYmVySUQoKSB0byBjbGVhciBpdCBmcm9tIHRoZSBNYXAuXG4gICAgLy8gMy4gUmVhY3QgZmx1c2hlcyBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBiZWZvcmUgaXQgcnVucyB0aGUgbmV4dCByZW5kZXIsXG4gICAgLy8gICAgd2hpY2ggbG9ncyBhbiBlcnJvciBvciB3YXJuaW5nLCB3aGljaCBjYXVzZXMgYSBuZXcgSUQgdG8gYmUgZ2VuZXJhdGVkIGZvciB0aGlzIEZpYmVyLlxuICAgIC8vIDQuIERldlRvb2xzIG5vdyB0cmllcyB0byB1bm1vdW50IHRoZSBvbGQgQ29tcG9uZW50IHdpdGggdGhlIG5ldyBJRC5cbiAgICAvL1xuICAgIC8vIFRoZSB1bmRlcmx5aW5nIHByb2JsZW0gaGVyZSBpcyB0aGUgcHJlbWF0dXJlIGNsZWFyaW5nIG9mIHRoZSBGaWJlciBJRCxcbiAgICAvLyBidXQgRGV2VG9vbHMgaGFzIG5vIHdheSB0byBkZXRlY3QgdGhhdCBhIGdpdmVuIEZpYmVyIGhhcyBiZWVuIHNjaGVkdWxlZCBmb3IgRmFzdCBSZWZyZXNoLlxuICAgIC8vIChUaGUgXCJfZGVidWdOZWVkc1JlbW91bnRcIiBmbGFnIHdvbid0IG5lY2Vzc2FyaWx5IGJlIHNldC4pXG4gICAgLy9cbiAgICAvLyBUaGUgYmVzdCB3ZSBjYW4gZG8gaXMgdG8gZGVsYXkgdW50cmFja2luZyBieSBhIHNtYWxsIGFtb3VudCxcbiAgICAvLyBhbmQgZ2l2ZSBSZWFjdCB0aW1lIHRvIHByb2Nlc3MgdGhlIEZhc3QgUmVmcmVzaCBkZWxheS5cblxuICAgIHVudHJhY2tGaWJlcnNTZXQuYWRkKGZpYmVyKTtcblxuICAgIC8vIFJlYWN0IG1heSBkZXRhY2ggYWx0ZXJuYXRlIHBvaW50ZXJzIGR1cmluZyB1bm1vdW50O1xuICAgIC8vIFNpbmNlIG91ciB1bnRyYWNraW5nIGNvZGUgaXMgYXN5bmMsIHdlIHNob3VsZCBleHBsaWNpbHkgdHJhY2sgdGhlIHBlbmRpbmcgYWx0ZXJuYXRlIGhlcmUgYXMgd2VsbC5cbiAgICBjb25zdCBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgdW50cmFja0ZpYmVyc1NldC5hZGQoYWx0ZXJuYXRlKTtcbiAgICB9XG5cbiAgICBpZiAodW50cmFja0ZpYmVyc1RpbWVvdXRJRCA9PT0gbnVsbCkge1xuICAgICAgdW50cmFja0ZpYmVyc1RpbWVvdXRJRCA9IHNldFRpbWVvdXQodW50cmFja0ZpYmVycywgMTAwMCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdW50cmFja0ZpYmVyc1NldDogU2V0PEZpYmVyPiA9IG5ldyBTZXQoKTtcbiAgbGV0IHVudHJhY2tGaWJlcnNUaW1lb3V0SUQ6IFRpbWVvdXRJRCB8IG51bGwgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHVudHJhY2tGaWJlcnMoKSB7XG4gICAgaWYgKHVudHJhY2tGaWJlcnNUaW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh1bnRyYWNrRmliZXJzVGltZW91dElEKTtcbiAgICAgIHVudHJhY2tGaWJlcnNUaW1lb3V0SUQgPSBudWxsO1xuICAgIH1cblxuICAgIHVudHJhY2tGaWJlcnNTZXQuZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICBjb25zdCBmaWJlcklEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG4gICAgICBpZiAoZmliZXJJRCAhPT0gbnVsbCkge1xuICAgICAgICBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZGVsZXRlKGZpYmVySUQpO1xuXG4gICAgICAgIC8vIEFsc28gY2xlYXIgYW55IGVycm9ycy93YXJuaW5ncyBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWJlci5cbiAgICAgICAgY2xlYXJFcnJvcnNGb3JGaWJlcklEKGZpYmVySUQpO1xuICAgICAgICBjbGVhcldhcm5pbmdzRm9yRmliZXJJRChmaWJlcklEKTtcbiAgICAgIH1cblxuICAgICAgZmliZXJUb0lETWFwLmRlbGV0ZShmaWJlcik7XG5cbiAgICAgIGNvbnN0IHthbHRlcm5hdGV9ID0gZmliZXI7XG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGZpYmVyVG9JRE1hcC5kZWxldGUoYWx0ZXJuYXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlRXJyb3JGb3JGaWJlcklEcy5oYXMoZmliZXJJRCkpIHtcbiAgICAgICAgZm9yY2VFcnJvckZvckZpYmVySURzLmRlbGV0ZShmaWJlcklEKTtcbiAgICAgICAgaWYgKGZvcmNlRXJyb3JGb3JGaWJlcklEcy5zaXplID09PSAwICYmIHNldEVycm9ySGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgc2V0RXJyb3JIYW5kbGVyKHNob3VsZEVycm9yRmliZXJBbHdheXNOdWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHVudHJhY2tGaWJlcnNTZXQuY2xlYXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoYW5nZURlc2NyaXB0aW9uKFxuICAgIHByZXZGaWJlcjogRmliZXIgfCBudWxsLFxuICAgIG5leHRGaWJlcjogRmliZXIsXG4gICk6IENoYW5nZURlc2NyaXB0aW9uIHwgbnVsbCB7XG4gICAgc3dpdGNoIChnZXRFbGVtZW50VHlwZUZvckZpYmVyKG5leHRGaWJlcikpIHtcbiAgICAgIGNhc2UgRWxlbWVudFR5cGVDbGFzczpcbiAgICAgIGNhc2UgRWxlbWVudFR5cGVGdW5jdGlvbjpcbiAgICAgIGNhc2UgRWxlbWVudFR5cGVNZW1vOlxuICAgICAgY2FzZSBFbGVtZW50VHlwZUZvcndhcmRSZWY6XG4gICAgICAgIGlmIChwcmV2RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgICAgIGRpZEhvb2tzQ2hhbmdlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRmlyc3RNb3VudDogdHJ1ZSxcbiAgICAgICAgICAgIHByb3BzOiBudWxsLFxuICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkYXRhOiBDaGFuZ2VEZXNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGdldENvbnRleHRDaGFuZ2VkS2V5cyhuZXh0RmliZXIpLFxuICAgICAgICAgICAgZGlkSG9va3NDaGFuZ2U6IGZhbHNlLFxuICAgICAgICAgICAgaXNGaXJzdE1vdW50OiBmYWxzZSxcbiAgICAgICAgICAgIHByb3BzOiBnZXRDaGFuZ2VkS2V5cyhcbiAgICAgICAgICAgICAgcHJldkZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgIG5leHRGaWJlci5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHN0YXRlOiBnZXRDaGFuZ2VkS2V5cyhcbiAgICAgICAgICAgICAgcHJldkZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICAgIG5leHRGaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gT25seSB0cmF2ZXJzZSB0aGUgaG9va3MgbGlzdCBvbmNlLCBkZXBlbmRpbmcgb24gd2hhdCBpbmZvIHdlJ3JlIHJldHVybmluZy5cbiAgICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJDaGFuZ2VkSG9va0luZGljZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBnZXRDaGFuZ2VkSG9va3NJbmRpY2VzKFxuICAgICAgICAgICAgICBwcmV2RmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dEZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGF0YS5ob29rcyA9IGluZGljZXM7XG4gICAgICAgICAgICBkYXRhLmRpZEhvb2tzQ2hhbmdlID0gaW5kaWNlcyAhPT0gbnVsbCAmJiBpbmRpY2VzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEuZGlkSG9va3NDaGFuZ2UgPSBkaWRIb29rc0NoYW5nZShcbiAgICAgICAgICAgICAgcHJldkZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICAgIG5leHRGaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29udGV4dHNGb3JGaWJlcihmaWJlcjogRmliZXIpIHtcbiAgICBzd2l0Y2ggKGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpKSB7XG4gICAgICBjYXNlIEVsZW1lbnRUeXBlQ2xhc3M6XG4gICAgICBjYXNlIEVsZW1lbnRUeXBlRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgRWxlbWVudFR5cGVGdW5jdGlvbjpcbiAgICAgIGNhc2UgRWxlbWVudFR5cGVNZW1vOlxuICAgICAgICBpZiAoaWRUb0NvbnRleHRzTWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaWQgPSBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKTtcbiAgICAgICAgICBjb25zdCBjb250ZXh0cyA9IGdldENvbnRleHRzRm9yRmliZXIoZmliZXIpO1xuICAgICAgICAgIGlmIChjb250ZXh0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWRUb0NvbnRleHRzTWFwLnNldChpZCwgY29udGV4dHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIERpZmZlcmVudGlhdGVzIGJldHdlZW4gYSBudWxsIGNvbnRleHQgdmFsdWUgYW5kIG5vIGNvbnRleHQuXG4gIGNvbnN0IE5PX0NPTlRFWFQgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRDb250ZXh0c0ZvckZpYmVyKGZpYmVyOiBGaWJlcik6IFtPYmplY3QsIGFueV0gfCBudWxsIHtcbiAgICBsZXQgbGVnYWN5Q29udGV4dCA9IE5PX0NPTlRFWFQ7XG4gICAgbGV0IG1vZGVybkNvbnRleHQgPSBOT19DT05URVhUO1xuXG4gICAgc3dpdGNoIChnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKSkge1xuICAgICAgY2FzZSBFbGVtZW50VHlwZUNsYXNzOlxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnN0YW5jZS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgaW5zdGFuY2UuY29uc3RydWN0b3IuY29udGV4dFR5cGUgIT0gbnVsbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbW9kZXJuQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2FjeUNvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAgICAgICAgICAgaWYgKGxlZ2FjeUNvbnRleHQgJiYgT2JqZWN0LmtleXMobGVnYWN5Q29udGV4dCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGxlZ2FjeUNvbnRleHQgPSBOT19DT05URVhUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2xlZ2FjeUNvbnRleHQsIG1vZGVybkNvbnRleHRdO1xuICAgICAgY2FzZSBFbGVtZW50VHlwZUZvcndhcmRSZWY6XG4gICAgICBjYXNlIEVsZW1lbnRUeXBlRnVuY3Rpb246XG4gICAgICBjYXNlIEVsZW1lbnRUeXBlTWVtbzpcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gZmliZXIuZGVwZW5kZW5jaWVzO1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQpIHtcbiAgICAgICAgICBtb2Rlcm5Db250ZXh0ID0gZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbGVnYWN5Q29udGV4dCwgbW9kZXJuQ29udGV4dF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBSZWNvcmQgYWxsIGNvbnRleHRzIGF0IHRoZSB0aW1lIHByb2ZpbGluZyBpcyBzdGFydGVkLlxuICAvLyBGaWJlcnMgb25seSBzdG9yZSB0aGUgY3VycmVudCBjb250ZXh0IHZhbHVlLFxuICAvLyBzbyB3ZSBuZWVkIHRvIHRyYWNrIHRoZW0gc2VwYXJhdGVseSBpbiBvcmRlciB0byBkZXRlcm1pbmUgY2hhbmdlZCBrZXlzLlxuICBmdW5jdGlvbiBjcmF3bFRvSW5pdGlhbGl6ZUNvbnRleHRzTWFwKGZpYmVyOiBGaWJlcikge1xuICAgIHVwZGF0ZUNvbnRleHRzRm9yRmliZXIoZmliZXIpO1xuICAgIGxldCBjdXJyZW50ID0gZmliZXIuY2hpbGQ7XG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNyYXdsVG9Jbml0aWFsaXplQ29udGV4dHNNYXAoY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRDaGFuZ2VkS2V5cyhmaWJlcjogRmliZXIpOiBudWxsIHwgYm9vbGVhbiB8IEFycmF5PHN0cmluZz4ge1xuICAgIGlmIChpZFRvQ29udGV4dHNNYXAgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGlkID0gZ2V0RmliZXJJRFRocm93cyhmaWJlcik7XG4gICAgICBjb25zdCBwcmV2Q29udGV4dHMgPSBpZFRvQ29udGV4dHNNYXAuaGFzKGlkKVxuICAgICAgICA/IGlkVG9Db250ZXh0c01hcC5nZXQoaWQpXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGNvbnN0IG5leHRDb250ZXh0cyA9IGdldENvbnRleHRzRm9yRmliZXIoZmliZXIpO1xuXG4gICAgICBpZiAocHJldkNvbnRleHRzID09IG51bGwgfHwgbmV4dENvbnRleHRzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtwcmV2TGVnYWN5Q29udGV4dCwgcHJldk1vZGVybkNvbnRleHRdID0gcHJldkNvbnRleHRzO1xuICAgICAgY29uc3QgW25leHRMZWdhY3lDb250ZXh0LCBuZXh0TW9kZXJuQ29udGV4dF0gPSBuZXh0Q29udGV4dHM7XG5cbiAgICAgIHN3aXRjaCAoZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcikpIHtcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZUNsYXNzOlxuICAgICAgICAgIGlmIChwcmV2Q29udGV4dHMgJiYgbmV4dENvbnRleHRzKSB7XG4gICAgICAgICAgICBpZiAobmV4dExlZ2FjeUNvbnRleHQgIT09IE5PX0NPTlRFWFQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5nZWRLZXlzKHByZXZMZWdhY3lDb250ZXh0LCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRNb2Rlcm5Db250ZXh0ICE9PSBOT19DT05URVhUKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcmV2TW9kZXJuQ29udGV4dCAhPT0gbmV4dE1vZGVybkNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZUZ1bmN0aW9uOlxuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlTWVtbzpcbiAgICAgICAgICBpZiAobmV4dE1vZGVybkNvbnRleHQgIT09IE5PX0NPTlRFWFQpIHtcbiAgICAgICAgICAgIGxldCBwcmV2Q29udGV4dCA9IHByZXZNb2Rlcm5Db250ZXh0O1xuICAgICAgICAgICAgbGV0IG5leHRDb250ZXh0ID0gbmV4dE1vZGVybkNvbnRleHQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChwcmV2Q29udGV4dCAmJiBuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgICAvLyBOb3RlIHRoaXMgb25seSB3b3JrcyBmb3IgdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBzdXBwb3J0IHRoaXMga2V5IChlLnYuIDE4KylcbiAgICAgICAgICAgICAgLy8gRm9yIG9sZGVyIHZlcnNpb25zLCB0aGVyZSdzIG5vIGdvb2Qgd2F5IHRvIHJlYWQgdGhlIGN1cnJlbnQgY29udGV4dCB2YWx1ZSBhZnRlciByZW5kZXIgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIFJlYWN0IG1haW50YWlucyBhIHN0YWNrIG9mIGNvbnRleHQgdmFsdWVzIGR1cmluZyByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGJ1dCBieSB0aGUgdGltZSBEZXZUb29scyBpcyBjYWxsZWQsIHJlbmRlciBoYXMgZmluaXNoZWQgYW5kIHRoZSBzdGFjayBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgaWYgKCFpcyhwcmV2Q29udGV4dC5tZW1vaXplZFZhbHVlLCBuZXh0Q29udGV4dC5tZW1vaXplZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcHJldkNvbnRleHQgPSBwcmV2Q29udGV4dC5uZXh0O1xuICAgICAgICAgICAgICBuZXh0Q29udGV4dCA9IG5leHRDb250ZXh0Lm5leHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKFxuICAgIG5leHREZXBzOiBBcnJheTxtaXhlZD4sXG4gICAgcHJldkRlcHM6IEFycmF5PG1peGVkPiB8IG51bGwsXG4gICkge1xuICAgIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFZmZlY3QobWVtb2l6ZWRTdGF0ZSkge1xuICAgIGlmIChtZW1vaXplZFN0YXRlID09PSBudWxsIHx8IHR5cGVvZiBtZW1vaXplZFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7ZGVwc30gPSBtZW1vaXplZFN0YXRlO1xuICAgIGNvbnN0IGJvdW5kSGFzT3duUHJvcGVydHkgPSBoYXNPd25Qcm9wZXJ0eS5iaW5kKG1lbW9pemVkU3RhdGUpO1xuICAgIHJldHVybiAoXG4gICAgICBib3VuZEhhc093blByb3BlcnR5KCdjcmVhdGUnKSAmJlxuICAgICAgYm91bmRIYXNPd25Qcm9wZXJ0eSgnZGVzdHJveScpICYmXG4gICAgICBib3VuZEhhc093blByb3BlcnR5KCdkZXBzJykgJiZcbiAgICAgIGJvdW5kSGFzT3duUHJvcGVydHkoJ25leHQnKSAmJlxuICAgICAgYm91bmRIYXNPd25Qcm9wZXJ0eSgndGFnJykgJiZcbiAgICAgIChkZXBzID09PSBudWxsIHx8IGlzQXJyYXkoZGVwcykpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpZEhvb2tDaGFuZ2UocHJldjogYW55LCBuZXh0OiBhbnkpOiBib29sZWFuIHtcbiAgICBjb25zdCBwcmV2TWVtb2l6ZWRTdGF0ZSA9IHByZXYubWVtb2l6ZWRTdGF0ZTtcbiAgICBjb25zdCBuZXh0TWVtb2l6ZWRTdGF0ZSA9IG5leHQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChpc0VmZmVjdChwcmV2TWVtb2l6ZWRTdGF0ZSkgJiYgaXNFZmZlY3QobmV4dE1lbW9pemVkU3RhdGUpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwcmV2TWVtb2l6ZWRTdGF0ZSAhPT0gbmV4dE1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgIWFyZUhvb2tJbnB1dHNFcXVhbChuZXh0TWVtb2l6ZWRTdGF0ZS5kZXBzLCBwcmV2TWVtb2l6ZWRTdGF0ZS5kZXBzKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRNZW1vaXplZFN0YXRlICE9PSBwcmV2TWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpZEhvb2tzQ2hhbmdlKHByZXY6IGFueSwgbmV4dDogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKHByZXYgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCByZXBvcnQgYW55dGhpbmcgbWVhbmluZ2Z1bCBmb3IgaG9va3MgY2hhbmdlcy5cbiAgICBpZiAoXG4gICAgICBuZXh0Lmhhc093blByb3BlcnR5KCdiYXNlU3RhdGUnKSAmJlxuICAgICAgbmV4dC5oYXNPd25Qcm9wZXJ0eSgnbWVtb2l6ZWRTdGF0ZScpICYmXG4gICAgICBuZXh0Lmhhc093blByb3BlcnR5KCduZXh0JykgJiZcbiAgICAgIG5leHQuaGFzT3duUHJvcGVydHkoJ3F1ZXVlJylcbiAgICApIHtcbiAgICAgIHdoaWxlIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChkaWRIb29rQ2hhbmdlKHByZXYsIG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICAgICAgICBwcmV2ID0gcHJldi5uZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2hhbmdlZEhvb2tzSW5kaWNlcyhwcmV2OiBhbnksIG5leHQ6IGFueSk6IG51bGwgfCBBcnJheTxudW1iZXI+IHtcbiAgICBpZiAoZW5hYmxlUHJvZmlsZXJDaGFuZ2VkSG9va0luZGljZXMpIHtcbiAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgbmV4dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgaWYgKFxuICAgICAgICBuZXh0Lmhhc093blByb3BlcnR5KCdiYXNlU3RhdGUnKSAmJlxuICAgICAgICBuZXh0Lmhhc093blByb3BlcnR5KCdtZW1vaXplZFN0YXRlJykgJiZcbiAgICAgICAgbmV4dC5oYXNPd25Qcm9wZXJ0eSgnbmV4dCcpICYmXG4gICAgICAgIG5leHQuaGFzT3duUHJvcGVydHkoJ3F1ZXVlJylcbiAgICAgICkge1xuICAgICAgICB3aGlsZSAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChkaWRIb29rQ2hhbmdlKHByZXYsIG5leHQpKSB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0O1xuICAgICAgICAgIHByZXYgPSBwcmV2Lm5leHQ7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kaWNlcztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoYW5nZWRLZXlzKHByZXY6IGFueSwgbmV4dDogYW55KTogbnVsbCB8IEFycmF5PHN0cmluZz4ge1xuICAgIGlmIChwcmV2ID09IG51bGwgfHwgbmV4dCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCByZXBvcnQgYW55dGhpbmcgbWVhbmluZ2Z1bCBmb3IgaG9va3MgY2hhbmdlcy5cbiAgICBpZiAoXG4gICAgICBuZXh0Lmhhc093blByb3BlcnR5KCdiYXNlU3RhdGUnKSAmJlxuICAgICAgbmV4dC5oYXNPd25Qcm9wZXJ0eSgnbWVtb2l6ZWRTdGF0ZScpICYmXG4gICAgICBuZXh0Lmhhc093blByb3BlcnR5KCduZXh0JykgJiZcbiAgICAgIG5leHQuaGFzT3duUHJvcGVydHkoJ3F1ZXVlJylcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KFsuLi5PYmplY3Qua2V5cyhwcmV2KSwgLi4uT2JqZWN0LmtleXMobmV4dCldKTtcbiAgICBjb25zdCBjaGFuZ2VkS2V5cyA9IFtdO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mb3Itb2YtbG9vcHMvbm8tZm9yLW9mLWxvb3BzXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKHByZXZba2V5XSAhPT0gbmV4dFtrZXldKSB7XG4gICAgICAgIGNoYW5nZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZEtleXM7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgZnVuY3Rpb24gZGlkRmliZXJSZW5kZXIocHJldkZpYmVyOiBGaWJlciwgbmV4dEZpYmVyOiBGaWJlcik6IGJvb2xlYW4ge1xuICAgIHN3aXRjaCAobmV4dEZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgLy8gRm9yIHR5cGVzIHRoYXQgZXhlY3V0ZSB1c2VyIGNvZGUsIHdlIGNoZWNrIFBlcmZvcm1lZFdvcmsgZWZmZWN0LlxuICAgICAgICAvLyBXZSBkb24ndCByZWZsZWN0IGJhaWxvdXRzIChlaXRoZXIgcmVmZXJlbnRpYWwgb3Igc0NVKSBpbiBEZXZUb29scy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgcmV0dXJuIChnZXRGaWJlckZsYWdzKG5leHRGaWJlcikgJiBQZXJmb3JtZWRXb3JrKSA9PT0gUGVyZm9ybWVkV29yaztcbiAgICAgIC8vIE5vdGU6IENvbnRleHRDb25zdW1lciBvbmx5IGdldHMgUGVyZm9ybWVkV29yayBlZmZlY3QgaW4gMTYuMy4zK1xuICAgICAgLy8gc28gaXQgd29uJ3QgZ2V0IGhpZ2hsaWdodGVkIHdpdGggUmVhY3QgMTYuMy4wIHRvIDE2LjMuMi5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZvciBob3N0IGNvbXBvbmVudHMgYW5kIG90aGVyIHR5cGVzLCB3ZSBjb21wYXJlIGlucHV0c1xuICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBzb21ldGhpbmcgaXMgYW4gdXBkYXRlLlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHByZXZGaWJlci5tZW1vaXplZFByb3BzICE9PSBuZXh0RmliZXIubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgIHByZXZGaWJlci5tZW1vaXplZFN0YXRlICE9PSBuZXh0RmliZXIubWVtb2l6ZWRTdGF0ZSB8fFxuICAgICAgICAgIHByZXZGaWJlci5yZWYgIT09IG5leHRGaWJlci5yZWZcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB0eXBlIE9wZXJhdGlvbnNBcnJheSA9IEFycmF5PG51bWJlcj47XG5cbiAgdHlwZSBTdHJpbmdUYWJsZUVudHJ5ID0ge3xcbiAgICBlbmNvZGVkU3RyaW5nOiBBcnJheTxudW1iZXI+LFxuICAgIGlkOiBudW1iZXIsXG4gIHx9O1xuXG4gIGNvbnN0IHBlbmRpbmdPcGVyYXRpb25zOiBPcGVyYXRpb25zQXJyYXkgPSBbXTtcbiAgY29uc3QgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHM6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgY29uc3QgcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICBsZXQgcGVuZGluZ09wZXJhdGlvbnNRdWV1ZTogQXJyYXk8T3BlcmF0aW9uc0FycmF5PiB8IG51bGwgPSBbXTtcbiAgY29uc3QgcGVuZGluZ1N0cmluZ1RhYmxlOiBNYXA8c3RyaW5nLCBTdHJpbmdUYWJsZUVudHJ5PiA9IG5ldyBNYXAoKTtcbiAgbGV0IHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aDogbnVtYmVyID0gMDtcbiAgbGV0IHBlbmRpbmdVbm1vdW50ZWRSb290SUQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHB1c2hPcGVyYXRpb24ob3A6IG51bWJlcik6IHZvaWQge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob3ApKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ3B1c2hPcGVyYXRpb24oKSB3YXMgY2FsbGVkIGJ1dCB0aGUgdmFsdWUgaXMgbm90IGFuIGludGVnZXIuJyxcbiAgICAgICAgICBvcCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ09wZXJhdGlvbnMucHVzaChvcCk7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaE9yUXVldWVPcGVyYXRpb25zKG9wZXJhdGlvbnM6IE9wZXJhdGlvbnNBcnJheSk6IHZvaWQge1xuICAgIGlmIChvcGVyYXRpb25zLmxlbmd0aCA9PT0gMykge1xuICAgICAgLy8gVGhpcyBvcGVyYXRpb25zIGFycmF5IGlzIGEgbm8gb3A6IFtyZW5kZXJlciBJRCwgcm9vdCBJRCwgc3RyaW5nIHRhYmxlIHNpemUgKDApXVxuICAgICAgLy8gV2UgY2FuIHVzdWFsbHkgc2tpcCBzZW5kaW5nIHVwZGF0ZXMgbGlrZSB0aGlzIGFjcm9zcyB0aGUgYnJpZGdlLCB1bmxlc3Mgd2UncmUgUHJvZmlsaW5nLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCBldmVuIHRob3VnaCB0aGUgdHJlZSBkaWRuJ3QgY2hhbmdl4oCTIHNvbWUgRmliZXJzIG1heSBoYXZlIHN0aWxsIHJlbmRlcmVkLlxuICAgICAgaWYgKFxuICAgICAgICAhaXNQcm9maWxpbmcgfHxcbiAgICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhID09IG51bGwgfHxcbiAgICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhLmR1cmF0aW9ucy5sZW5ndGggPT09IDBcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdPcGVyYXRpb25zUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHBlbmRpbmdPcGVyYXRpb25zUXVldWUucHVzaChvcGVyYXRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9vay5lbWl0KCdvcGVyYXRpb25zJywgb3BlcmF0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheVRpbWVvdXRJRCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gY2xlYXJQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5KCkge1xuICAgIGlmIChmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQpO1xuICAgICAgZmx1c2hQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5VGltZW91dElEID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKSB7XG4gICAgY2xlYXJQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5KCk7XG5cbiAgICBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheVRpbWVvdXRJRCA9IG51bGw7XG5cbiAgICAgIGlmIChwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIE9uIHRoZSBvZmYgY2hhbmNlIHRoYXQgc29tZXRoaW5nIGVsc2UgaGFzIHB1c2hlZCBwZW5kaW5nIG9wZXJhdGlvbnMsXG4gICAgICAgIC8vIHdlIHNob3VsZCBiYWlsIG9uIHdhcm5pbmdzOyBpdCdzIHByb2JhYmx5IG5vdCBzYWZlIHRvIHB1c2ggbWlkd2F5LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpO1xuXG4gICAgICBpZiAocGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIE5vIHdhcm5pbmdzIG9yIGVycm9ycyB0byBmbHVzaDsgd2UgY2FuIGJhaWwgb3V0IGVhcmx5IGhlcmUgdG9vLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGNhbiBjcmVhdGUgYSBzbWFsbGVyIG9wZXJhdGlvbnMgYXJyYXkgdGhhbiBmbHVzaFBlbmRpbmdFdmVudHMoKVxuICAgICAgLy8gYmVjYXVzZSB3ZSBvbmx5IG5lZWQgdG8gZmx1c2ggd2FybmluZyBhbmQgZXJyb3IgY291bnRzLlxuICAgICAgLy8gT25seSBhIGZldyBwaWVjZXMgb2YgZml4ZWQgaW5mb3JtYXRpb24gYXJlIHJlcXVpcmVkIHVwIGZyb250LlxuICAgICAgY29uc3Qgb3BlcmF0aW9uczogT3BlcmF0aW9uc0FycmF5ID0gbmV3IEFycmF5KFxuICAgICAgICAzICsgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIG9wZXJhdGlvbnNbMF0gPSByZW5kZXJlcklEO1xuICAgICAgb3BlcmF0aW9uc1sxXSA9IGN1cnJlbnRSb290SUQ7XG4gICAgICBvcGVyYXRpb25zWzJdID0gMDsgLy8gU3RyaW5nIHRhYmxlIHNpemVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgb3BlcmF0aW9uc1szICsgal0gPSBwZW5kaW5nT3BlcmF0aW9uc1tqXTtcbiAgICAgIH1cblxuICAgICAgZmx1c2hPclF1ZXVlT3BlcmF0aW9ucyhvcGVyYXRpb25zKTtcblxuICAgICAgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9LCAxMDAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVFcnJvcnNBbmRXYXJuaW5ncygpIHtcbiAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmNsZWFyKCk7XG4gICAgZmliZXJJRFRvRXJyb3JzTWFwLmZvckVhY2goKGNvdW50TWFwLCBmaWJlcklEKSA9PiB7XG4gICAgICBjb25zdCBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoZmliZXJJRCk7XG4gICAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChmaWJlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmliZXJJRFRvV2FybmluZ3NNYXAuZm9yRWFjaCgoY291bnRNYXAsIGZpYmVySUQpID0+IHtcbiAgICAgIGNvbnN0IGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChmaWJlcklEKTtcbiAgICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuYWRkKGZpYmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWNvcmRQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3MoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlTWFwc0FuZEdldENvdW50SGVscGVyKFxuICAgIGZpYmVyOiBGaWJlcixcbiAgICBmaWJlcklEOiBudW1iZXIsXG4gICAgcGVuZGluZ0ZpYmVyVG9NZXNzYWdlQ291bnRNYXA6IE1hcDxGaWJlciwgTWFwPHN0cmluZywgbnVtYmVyPj4sXG4gICAgZmliZXJJRFRvTWVzc2FnZUNvdW50TWFwOiBNYXA8bnVtYmVyLCBNYXA8c3RyaW5nLCBudW1iZXI+PixcbiAgKTogbnVtYmVyIHtcbiAgICBsZXQgbmV3Q291bnQgPSAwO1xuXG4gICAgbGV0IG1lc3NhZ2VDb3VudE1hcCA9IGZpYmVySURUb01lc3NhZ2VDb3VudE1hcC5nZXQoZmliZXJJRCk7XG5cbiAgICBjb25zdCBwZW5kaW5nTWVzc2FnZUNvdW50TWFwID0gcGVuZGluZ0ZpYmVyVG9NZXNzYWdlQ291bnRNYXAuZ2V0KGZpYmVyKTtcbiAgICBpZiAocGVuZGluZ01lc3NhZ2VDb3VudE1hcCAhPSBudWxsKSB7XG4gICAgICBpZiAobWVzc2FnZUNvdW50TWFwID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZUNvdW50TWFwID0gcGVuZGluZ01lc3NhZ2VDb3VudE1hcDtcblxuICAgICAgICBmaWJlcklEVG9NZXNzYWdlQ291bnRNYXAuc2V0KGZpYmVySUQsIHBlbmRpbmdNZXNzYWdlQ291bnRNYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBGbG93IHJlZmluZW1lbnQgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYW5kIHlldC4uLlxuICAgICAgICBjb25zdCByZWZpbmVkTWVzc2FnZUNvdW50TWFwID0gKChtZXNzYWdlQ291bnRNYXA6IGFueSk6IE1hcDxcbiAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgbnVtYmVyLFxuICAgICAgICA+KTtcblxuICAgICAgICBwZW5kaW5nTWVzc2FnZUNvdW50TWFwLmZvckVhY2goKHBlbmRpbmdDb3VudCwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ291bnQgPSByZWZpbmVkTWVzc2FnZUNvdW50TWFwLmdldChtZXNzYWdlKSB8fCAwO1xuICAgICAgICAgIHJlZmluZWRNZXNzYWdlQ291bnRNYXAuc2V0KG1lc3NhZ2UsIHByZXZpb3VzQ291bnQgKyBwZW5kaW5nQ291bnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNob3VsZEZpbHRlckZpYmVyKGZpYmVyKSkge1xuICAgICAgaWYgKG1lc3NhZ2VDb3VudE1hcCAhPSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2VDb3VudE1hcC5mb3JFYWNoKGNvdW50ID0+IHtcbiAgICAgICAgICBuZXdDb3VudCArPSBjb3VudDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGVuZGluZ0ZpYmVyVG9NZXNzYWdlQ291bnRNYXAuZGVsZXRlKGZpYmVyKTtcblxuICAgIHJldHVybiBuZXdDb3VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpIHtcbiAgICBjbGVhclBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKTtcblxuICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICBjb25zdCBmaWJlcklEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG4gICAgICBpZiAoZmliZXJJRCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBEb24ndCBzZW5kIHVwZGF0ZXMgZm9yIEZpYmVycyB0aGF0IGRpZG4ndCBtb3VudCBkdWUgdG8gZS5nLiBTdXNwZW5zZSBvciBhbiBlcnJvciBib3VuZGFyeS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yQ291bnQgPSBtZXJnZU1hcHNBbmRHZXRDb3VudEhlbHBlcihcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgICBmaWJlcklELFxuICAgICAgICAgIHBlbmRpbmdGaWJlclRvRXJyb3JzTWFwLFxuICAgICAgICAgIGZpYmVySURUb0Vycm9yc01hcCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgd2FybmluZ0NvdW50ID0gbWVyZ2VNYXBzQW5kR2V0Q291bnRIZWxwZXIoXG4gICAgICAgICAgZmliZXIsXG4gICAgICAgICAgZmliZXJJRCxcbiAgICAgICAgICBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwLFxuICAgICAgICAgIGZpYmVySURUb1dhcm5pbmdzTWFwLFxuICAgICAgICApO1xuXG4gICAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUyk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oZmliZXJJRCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oZXJyb3JDb3VudCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24od2FybmluZ0NvdW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gQWx3YXlzIGNsZWFuIHVwIHNvIHRoYXQgd2UgZG9uJ3QgbGVhay5cbiAgICAgIHBlbmRpbmdGaWJlclRvRXJyb3JzTWFwLmRlbGV0ZShmaWJlcik7XG4gICAgICBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwLmRlbGV0ZShmaWJlcik7XG4gICAgfSk7XG4gICAgZmliZXJzV2l0aENoYW5nZWRFcnJvck9yV2FybmluZ0NvdW50cy5jbGVhcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3Q6IE9iamVjdCk6IHZvaWQge1xuICAgIC8vIEFkZCBhbnkgcGVuZGluZyBlcnJvcnMgYW5kIHdhcm5pbmdzIHRvIHRoZSBvcGVyYXRpb25zIGFycmF5LlxuICAgIC8vIFdlIGRvIHRoaXMganVzdCBiZWZvcmUgZmx1c2hpbmcsIHNvIHdlIGNhbiBpZ25vcmUgZXJyb3JzIGZvciBuby1sb25nZXItbW91bnRlZCBGaWJlcnMuXG4gICAgcmVjb3JkUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzKCk7XG5cbiAgICBpZiAoXG4gICAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHBlbmRpbmdSZWFsVW5tb3VudGVkSURzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPT09IG51bGxcbiAgICApIHtcbiAgICAgIC8vIElmIHdlIGFyZW4ndCBwcm9maWxpbmcsIHdlIGNhbiBqdXN0IGJhaWwgb3V0IGhlcmUuXG4gICAgICAvLyBObyB1c2Ugc2VuZGluZyBhbiBlbXB0eSB1cGRhdGUgb3ZlciB0aGUgYnJpZGdlLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBQcm9maWxlciBzdG9yZXMgbWV0YWRhdGEgZm9yIGVhY2ggY29tbWl0IGFuZCByZWNvbnN0cnVjdHMgdGhlIGFwcCB0cmVlIHBlciBjb21taXQgdXNpbmc6XG4gICAgICAvLyAoMSkgYW4gaW5pdGlhbCB0cmVlIHNuYXBzaG90IGFuZFxuICAgICAgLy8gKDIpIHRoZSBvcGVyYXRpb25zIGFycmF5IGZvciBlYWNoIGNvbW1pdFxuICAgICAgLy8gQmVjYXVzZSBvZiB0aGlzLCBpdCdzIGltcG9ydGFudCB0aGF0IHRoZSBvcGVyYXRpb25zIGFuZCBtZXRhZGF0YSBhcnJheXMgYWxpZ24sXG4gICAgICAvLyBTbyBpdCdzIGltcG9ydGFudCBub3QgdG8gb21pdCBldmVuIGVtcHR5IG9wZXJhdGlvbnMgd2hpbGUgcHJvZmlsaW5nIGlzIGFjdGl2ZS5cbiAgICAgIGlmICghaXNQcm9maWxpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG51bVVubW91bnRJRHMgPVxuICAgICAgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoICtcbiAgICAgIHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMubGVuZ3RoICtcbiAgICAgIChwZW5kaW5nVW5tb3VudGVkUm9vdElEID09PSBudWxsID8gMCA6IDEpO1xuXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IG5ldyBBcnJheShcbiAgICAgIC8vIElkZW50aWZ5IHdoaWNoIHJlbmRlcmVyIHRoaXMgdXBkYXRlIGlzIGNvbWluZyBmcm9tLlxuICAgICAgMiArIC8vIFtyZW5kZXJlcklELCByb290RmliZXJJRF1cbiAgICAgIC8vIEhvdyBiaWcgaXMgdGhlIHN0cmluZyB0YWJsZT9cbiAgICAgIDEgKyAvLyBbc3RyaW5nVGFibGVMZW5ndGhdXG4gICAgICAgIC8vIFRoZW4gZ29lcyB0aGUgYWN0dWFsIHN0cmluZyB0YWJsZS5cbiAgICAgICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoICtcbiAgICAgICAgLy8gQWxsIHVubW91bnRzIGFyZSBiYXRjaGVkIGluIGEgc2luZ2xlIG1lc3NhZ2UuXG4gICAgICAgIC8vIFtUUkVFX09QRVJBVElPTl9SRU1PVkUsIHJlbW92ZWRJRExlbmd0aCwgLi4uaWRzXVxuICAgICAgICAobnVtVW5tb3VudElEcyA+IDAgPyAyICsgbnVtVW5tb3VudElEcyA6IDApICtcbiAgICAgICAgLy8gUmVndWxhciBvcGVyYXRpb25zXG4gICAgICAgIHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCxcbiAgICApO1xuXG4gICAgLy8gSWRlbnRpZnkgd2hpY2ggcmVuZGVyZXIgdGhpcyB1cGRhdGUgaXMgY29taW5nIGZyb20uXG4gICAgLy8gVGhpcyBlbmFibGVzIHJvb3RzIHRvIGJlIG1hcHBlZCB0byByZW5kZXJlcnMsXG4gICAgLy8gV2hpY2ggaW4gdHVybiBlbmFibGVzIGZpYmVyIHByb3BzLCBzdGF0ZXMsIGFuZCBob29rcyB0byBiZSBpbnNwZWN0ZWQuXG4gICAgbGV0IGkgPSAwO1xuICAgIG9wZXJhdGlvbnNbaSsrXSA9IHJlbmRlcmVySUQ7XG4gICAgb3BlcmF0aW9uc1tpKytdID0gY3VycmVudFJvb3RJRDtcblxuICAgIC8vIE5vdyBmaWxsIGluIHRoZSBzdHJpbmcgdGFibGUuXG4gICAgLy8gW3N0cmluZ1RhYmxlTGVuZ3RoLCBzdHIxTGVuZ3RoLCAuLi5zdHIxLCBzdHIyTGVuZ3RoLCAuLi5zdHIyLCAuLi5dXG4gICAgb3BlcmF0aW9uc1tpKytdID0gcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZS5mb3JFYWNoKChlbnRyeSwgc3RyaW5nS2V5KSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVkU3RyaW5nID0gZW50cnkuZW5jb2RlZFN0cmluZztcblxuICAgICAgLy8gRG9uJ3QgdXNlIHRoZSBzdHJpbmcgbGVuZ3RoLlxuICAgICAgLy8gSXQgd29uJ3Qgd29yayBmb3IgbXVsdGlieXRlIGNoYXJhY3RlcnMgKGxpa2UgZW1vamkpLlxuICAgICAgY29uc3QgbGVuZ3RoID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG5cbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IGxlbmd0aDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpICsgal0gPSBlbmNvZGVkU3RyaW5nW2pdO1xuICAgICAgfVxuXG4gICAgICBpICs9IGxlbmd0aDtcbiAgICB9KTtcblxuICAgIGlmIChudW1Vbm1vdW50SURzID4gMCkge1xuICAgICAgLy8gQWxsIHVubW91bnRzIGV4Y2VwdCByb290cyBhcmUgYmF0Y2hlZCBpbiBhIHNpbmdsZSBtZXNzYWdlLlxuICAgICAgb3BlcmF0aW9uc1tpKytdID0gVFJFRV9PUEVSQVRJT05fUkVNT1ZFO1xuICAgICAgLy8gVGhlIGZpcnN0IG51bWJlciBpcyBob3cgbWFueSB1bm1vdW50ZWQgSURzIHdlJ3JlIGdvbm5hIHNlbmQuXG4gICAgICBvcGVyYXRpb25zW2krK10gPSBudW1Vbm1vdW50SURzO1xuICAgICAgLy8gRmlsbCBpbiB0aGUgcmVhbCB1bm1vdW50cyBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICAgIC8vIFRoZXkgd2VyZSBpbnNlcnRlZCBwYXJlbnRzLWZpcnN0IGJ5IFJlYWN0LCBidXQgd2Ugd2FudCBjaGlsZHJlbi1maXJzdC5cbiAgICAgIC8vIFNvIHdlIHRyYXZlcnNlIG91ciBhcnJheSBiYWNrd2FyZHMuXG4gICAgICBmb3IgKGxldCBqID0gcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpKytdID0gcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHNbal07XG4gICAgICB9XG4gICAgICAvLyBGaWxsIGluIHRoZSBzaW11bGF0ZWQgdW5tb3VudHMgKGhpZGRlbiBTdXNwZW5zZSBzdWJ0cmVlcykgaW4gdGhlaXIgb3JkZXIuXG4gICAgICAvLyAoV2Ugd2FudCBjaGlsZHJlbiB0byBnbyBiZWZvcmUgcGFyZW50cy4pXG4gICAgICAvLyBUaGV5IGdvICphZnRlciogdGhlIHJlYWwgdW5tb3VudHMgYmVjYXVzZSB3ZSBrbm93IGZvciBzdXJlIHRoZXkgd29uJ3QgYmVcbiAgICAgIC8vIGNoaWxkcmVuIG9mIGFscmVhZHkgcHVzaGVkIFwicmVhbFwiIElEcy4gSWYgdGhleSB3ZXJlLCB3ZSB3b3VsZG4ndCBiZSBhYmxlXG4gICAgICAvLyB0byBkaXNjb3ZlciB0aGVtIGR1cmluZyB0aGUgdHJhdmVyc2FsLCBhcyB0aGV5IHdvdWxkIGhhdmUgYmVlbiBkZWxldGVkLlxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwZW5kaW5nU2ltdWxhdGVkVW5tb3VudGVkSURzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbaSArIGpdID0gcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEc1tqXTtcbiAgICAgIH1cbiAgICAgIGkgKz0gcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5sZW5ndGg7XG4gICAgICAvLyBUaGUgcm9vdCBJRCBzaG91bGQgYWx3YXlzIGJlIHVubW91bnRlZCBsYXN0LlxuICAgICAgaWYgKHBlbmRpbmdVbm1vdW50ZWRSb290SUQgIT09IG51bGwpIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpXSA9IHBlbmRpbmdVbm1vdW50ZWRSb290SUQ7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgb3BlcmF0aW9ucy5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICBvcGVyYXRpb25zW2kgKyBqXSA9IHBlbmRpbmdPcGVyYXRpb25zW2pdO1xuICAgIH1cbiAgICBpICs9IHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aDtcblxuICAgIC8vIExldCB0aGUgZnJvbnRlbmQga25vdyBhYm91dCB0cmVlIG9wZXJhdGlvbnMuXG4gICAgZmx1c2hPclF1ZXVlT3BlcmF0aW9ucyhvcGVyYXRpb25zKTtcblxuICAgIC8vIFJlc2V0IGFsbCBvZiB0aGUgcGVuZGluZyBzdGF0ZSBub3cgdGhhdCB3ZSd2ZSB0b2xkIHRoZSBmcm9udGVuZCBhYm91dCBpdC5cbiAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPSAwO1xuICAgIHBlbmRpbmdSZWFsVW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XG4gICAgcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICAgIHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPSBudWxsO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZS5jbGVhcigpO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdHJpbmdJRChzdHJpbmc6IHN0cmluZyB8IG51bGwpOiBudW1iZXIge1xuICAgIGlmIChzdHJpbmcgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gcGVuZGluZ1N0cmluZ1RhYmxlLmdldChzdHJpbmcpO1xuICAgIGlmIChleGlzdGluZ0VudHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0VudHJ5LmlkO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gcGVuZGluZ1N0cmluZ1RhYmxlLnNpemUgKyAxO1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1dGZFbmNvZGVTdHJpbmcoc3RyaW5nKTtcblxuICAgIHBlbmRpbmdTdHJpbmdUYWJsZS5zZXQoc3RyaW5nLCB7XG4gICAgICBlbmNvZGVkU3RyaW5nLFxuICAgICAgaWQsXG4gICAgfSk7XG5cbiAgICAvLyBUaGUgc3RyaW5nIHRhYmxlIHRvdGFsIGxlbmd0aCBuZWVkcyB0byBhY2NvdW50IGJvdGggZm9yIHRoZSBzdHJpbmcgbGVuZ3RoLFxuICAgIC8vIGFuZCBmb3IgdGhlIGFycmF5IGl0ZW0gdGhhdCBjb250YWlucyB0aGUgbGVuZ3RoIGl0c2VsZi5cbiAgICAvL1xuICAgIC8vIERvbid0IHVzZSBzdHJpbmcgbGVuZ3RoIGZvciB0aGlzIHRhYmxlLlxuICAgIC8vIEl0IHdvbid0IHdvcmsgZm9yIG11bHRpYnl0ZSBjaGFyYWN0ZXJzIChsaWtlIGVtb2ppKS5cbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggKz0gZW5jb2RlZFN0cmluZy5sZW5ndGggKyAxO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTW91bnQoZmliZXI6IEZpYmVyLCBwYXJlbnRGaWJlcjogRmliZXIgfCBudWxsKSB7XG4gICAgY29uc3QgaXNSb290ID0gZmliZXIudGFnID09PSBIb3N0Um9vdDtcbiAgICBjb25zdCBpZCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKGZpYmVyKTtcblxuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCdyZWNvcmRNb3VudCgpJywgZmliZXIsIHBhcmVudEZpYmVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNPd25lck1ldGFkYXRhID0gZmliZXIuaGFzT3duUHJvcGVydHkoJ19kZWJ1Z093bmVyJyk7XG4gICAgY29uc3QgaXNQcm9maWxpbmdTdXBwb3J0ZWQgPSBmaWJlci5oYXNPd25Qcm9wZXJ0eSgndHJlZUJhc2VEdXJhdGlvbicpO1xuXG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgcHVzaE9wZXJhdGlvbihUUkVFX09QRVJBVElPTl9BREQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKEVsZW1lbnRUeXBlUm9vdCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKChmaWJlci5tb2RlICYgU3RyaWN0TW9kZUJpdHMpICE9PSAwID8gMSA6IDApO1xuICAgICAgcHVzaE9wZXJhdGlvbihpc1Byb2ZpbGluZ1N1cHBvcnRlZCA/IDEgOiAwKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oU3RyaWN0TW9kZUJpdHMgIT09IDAgPyAxIDogMCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGhhc093bmVyTWV0YWRhdGEgPyAxIDogMCk7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICBpZiAoZGlzcGxheU5hbWVzQnlSb290SUQgIT09IG51bGwpIHtcbiAgICAgICAgICBkaXNwbGF5TmFtZXNCeVJvb3RJRC5zZXQoaWQsIGdldERpc3BsYXlOYW1lRm9yUm9vdChmaWJlcikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtrZXl9ID0gZmliZXI7XG4gICAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpO1xuICAgICAgY29uc3QgZWxlbWVudFR5cGUgPSBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKTtcbiAgICAgIGNvbnN0IHtfZGVidWdPd25lcn0gPSBmaWJlcjtcblxuICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgY2FsbCBnZXRGaWJlcklEVGhyb3dzKCkgZm9yIF9kZWJ1Z093bmVyLFxuICAgICAgLy8gc2luY2Ugb3duZXJzIGFyZSBhbG1vc3QgYWx3YXlzIGhpZ2hlciBpbiB0aGUgdHJlZSAoYW5kIHNvIGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCksXG4gICAgICAvLyBidXQgaW4gc29tZSAocmFyZSkgaW5zdGFuY2VzIHJlcG9ydGVkIGluIG9wZW4gc291cmNlLCBhIGRlc2NlbmRhbnQgbW91bnRzIGJlZm9yZSBhbiBvd25lci5cbiAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBERVYgb25seSBmaWVsZCBpdCdzIHByb2JhYmx5IG9rYXkgdG8gYWxzbyBqdXN0IGxhemlseSBnZW5lcmF0ZSBhbmQgSUQgaGVyZSBpZiBuZWVkZWQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMTQ0NVxuICAgICAgY29uc3Qgb3duZXJJRCA9XG4gICAgICAgIF9kZWJ1Z093bmVyICE9IG51bGwgPyBnZXRPckdlbmVyYXRlRmliZXJJRChfZGVidWdPd25lcikgOiAwO1xuICAgICAgY29uc3QgcGFyZW50SUQgPSBwYXJlbnRGaWJlciA/IGdldEZpYmVySURUaHJvd3MocGFyZW50RmliZXIpIDogMDtcblxuICAgICAgY29uc3QgZGlzcGxheU5hbWVTdHJpbmdJRCA9IGdldFN0cmluZ0lEKGRpc3BsYXlOYW1lKTtcblxuICAgICAgLy8gVGhpcyBjaGVjayBpcyBhIGd1YXJkIHRvIGhhbmRsZSBhIFJlYWN0IGVsZW1lbnQgdGhhdCBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAgLy8gaW4gc3VjaCBhIHdheSBhcyB0byBieXBhc3MgdGhlIGRlZmF1bHQgc3RyaW5naWZpY2F0aW9uIG9mIHRoZSBcImtleVwiIHByb3BlcnR5LlxuICAgICAgY29uc3Qga2V5U3RyaW5nID0ga2V5ID09PSBudWxsID8gbnVsbCA6IFN0cmluZyhrZXkpO1xuICAgICAgY29uc3Qga2V5U3RyaW5nSUQgPSBnZXRTdHJpbmdJRChrZXlTdHJpbmcpO1xuXG4gICAgICBwdXNoT3BlcmF0aW9uKFRSRUVfT1BFUkFUSU9OX0FERCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGlkKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oZWxlbWVudFR5cGUpO1xuICAgICAgcHVzaE9wZXJhdGlvbihwYXJlbnRJRCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKG93bmVySUQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihkaXNwbGF5TmFtZVN0cmluZ0lEKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oa2V5U3RyaW5nSUQpO1xuXG4gICAgICAvLyBJZiB0aGlzIHN1YnRyZWUgaGFzIGEgbmV3IG1vZGUsIGxldCB0aGUgZnJvbnRlbmQga25vdy5cbiAgICAgIGlmIChcbiAgICAgICAgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlQml0cykgIT09IDAgJiZcbiAgICAgICAgKCgocGFyZW50RmliZXI6IGFueSk6IEZpYmVyKS5tb2RlICYgU3RyaWN0TW9kZUJpdHMpID09PSAwXG4gICAgICApIHtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihUUkVFX09QRVJBVElPTl9TRVRfU1VCVFJFRV9NT0RFKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oU3RyaWN0TW9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICBpZFRvUm9vdE1hcC5zZXQoaWQsIGN1cnJlbnRSb290SUQpO1xuXG4gICAgICByZWNvcmRQcm9maWxpbmdEdXJhdGlvbnMoZmliZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFVubW91bnQoZmliZXI6IEZpYmVyLCBpc1NpbXVsYXRlZDogYm9vbGVhbikge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICAncmVjb3JkVW5tb3VudCgpJyxcbiAgICAgICAgZmliZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGlzU2ltdWxhdGVkID8gJ3VubW91bnQgaXMgc2ltdWxhdGVkJyA6ICcnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2tlZFBhdGhNYXRjaEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBpbiB0aGUgcHJvY2VzcyBvZiB0cnlpbmcgdG8gcmVzdG9yZSBwcmV2aW91cyBzZWxlY3Rpb24uXG4gICAgICAvLyBJZiB0aGlzIGZpYmVyIG1hdGNoZWQgYnV0IGlzIGJlaW5nIHVubW91bnRlZCwgdGhlcmUncyBubyB1c2UgdHJ5aW5nLlxuICAgICAgLy8gUmVzZXQgdGhlIHN0YXRlIHNvIHdlIGRvbid0IGtlZXAgaG9sZGluZyBvbnRvIGl0LlxuICAgICAgaWYgKFxuICAgICAgICBmaWJlciA9PT0gdHJhY2tlZFBhdGhNYXRjaEZpYmVyIHx8XG4gICAgICAgIGZpYmVyID09PSB0cmFja2VkUGF0aE1hdGNoRmliZXIuYWx0ZXJuYXRlXG4gICAgICApIHtcbiAgICAgICAgc2V0VHJhY2tlZFBhdGgobnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdW5zYWZlSUQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKTtcbiAgICBpZiAodW5zYWZlSUQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlJ3ZlIG5ldmVyIHNlZW4gdGhpcyBGaWJlciwgaXQgbWlnaHQgYmUgaW5zaWRlIG9mIGEgbGVnYWN5IHJlbmRlciBTdXNwZW5zZSBmcmFnbWVudCAoc28gdGhlIHN0b3JlIGlzIG5vdCBldmVuIGF3YXJlIG9mIGl0KS5cbiAgICAgIC8vIEluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCBpZ25vcmUgaXQgb3IgaXQgd2lsbCBjYXVzZSBlcnJvcnMgbGF0ZXIgb24uXG4gICAgICAvLyBPbmUgZXhhbXBsZSBvZiB0aGlzIGlzIGEgTGF6eSBjb21wb25lbnQgdGhhdCBuZXZlciByZXNvbHZlcyBiZWZvcmUgYmVpbmcgdW5tb3VudGVkLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBtaWdodCBpbmRpY2F0ZSBhIEZhc3QgUmVmcmVzaCBmb3JjZS1yZW1vdW50IHNjZW5hcmlvLlxuICAgICAgLy9cbiAgICAgIC8vIFRPRE86IFRoaXMgaXMgZnJhZ2lsZSBhbmQgY2FuIG9ic2N1cmUgYWN0dWFsIGJ1Z3MuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmxvdyByZWZpbmVtZW50LlxuICAgIGNvbnN0IGlkID0gKCh1bnNhZmVJRDogYW55KTogbnVtYmVyKTtcbiAgICBjb25zdCBpc1Jvb3QgPSBmaWJlci50YWcgPT09IEhvc3RSb290O1xuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIC8vIFJvb3RzIG11c3QgYmUgcmVtb3ZlZCBvbmx5IGFmdGVyIGFsbCBjaGlsZHJlbiAocGVuZGluZyBhbmQgc2ltdWxhdGVkKSBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICAgIC8vIFNvIHdlIHRyYWNrIGl0IHNlcGFyYXRlbHkuXG4gICAgICBwZW5kaW5nVW5tb3VudGVkUm9vdElEID0gaWQ7XG4gICAgfSBlbHNlIGlmICghc2hvdWxkRmlsdGVyRmliZXIoZmliZXIpKSB7XG4gICAgICAvLyBUbyBtYWludGFpbiBjaGlsZC1maXJzdCBvcmRlcmluZyxcbiAgICAgIC8vIHdlJ2xsIHB1c2ggaXQgaW50byBvbmUgb2YgdGhlc2UgcXVldWVzLFxuICAgICAgLy8gYW5kIGxhdGVyIGFycmFuZ2UgdGhlbSBpbiB0aGUgY29ycmVjdCBvcmRlci5cbiAgICAgIGlmIChpc1NpbXVsYXRlZCkge1xuICAgICAgICBwZW5kaW5nU2ltdWxhdGVkVW5tb3VudGVkSURzLnB1c2goaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMucHVzaChpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmaWJlci5fZGVidWdOZWVkc1JlbW91bnQpIHtcbiAgICAgIHVudHJhY2tGaWJlcklEKGZpYmVyKTtcblxuICAgICAgY29uc3QgaXNQcm9maWxpbmdTdXBwb3J0ZWQgPSBmaWJlci5oYXNPd25Qcm9wZXJ0eSgndHJlZUJhc2VEdXJhdGlvbicpO1xuICAgICAgaWYgKGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIGlkVG9Sb290TWFwLmRlbGV0ZShpZCk7XG4gICAgICAgIGlkVG9UcmVlQmFzZUR1cmF0aW9uTWFwLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRGaWJlclJlY3Vyc2l2ZWx5KFxuICAgIGZpcnN0Q2hpbGQ6IEZpYmVyLFxuICAgIHBhcmVudEZpYmVyOiBGaWJlciB8IG51bGwsXG4gICAgdHJhdmVyc2VTaWJsaW5nczogYm9vbGVhbixcbiAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlOiBib29sZWFuLFxuICApIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgc2libGluZ3MgcmF0aGVyIHRoYW4gcmVjdXJzaW5nLlxuICAgIC8vIFRoaXMgcmVkdWNlcyB0aGUgY2hhbmNlIG9mIHN0YWNrIG92ZXJmbG93IGZvciB3aWRlIHRyZWVzIChlLmcuIGxpc3RzIHdpdGggbWFueSBpdGVtcykuXG4gICAgbGV0IGZpYmVyOiBGaWJlciB8IG51bGwgPSBmaXJzdENoaWxkO1xuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gR2VuZXJhdGUgYW4gSUQgZXZlbiBmb3IgZmlsdGVyZWQgRmliZXJzLCBpbiBjYXNlIGl0J3MgbmVlZGVkIGxhdGVyIChlLmcuIGZvciBQcm9maWxpbmcpLlxuICAgICAgZ2V0T3JHZW5lcmF0ZUZpYmVySUQoZmliZXIpO1xuXG4gICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgIGRlYnVnKCdtb3VudEZpYmVyUmVjdXJzaXZlbHkoKScsIGZpYmVyLCBwYXJlbnRGaWJlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgdGhlIHRyZWUgc2VsZWN0aW9uIGZyb20gcHJldmlvdXMgcmVsb2FkLCB0cnkgdG8gbWF0Y2ggdGhpcyBGaWJlci5cbiAgICAgIC8vIEFsc28gcmVtZW1iZXIgd2hldGhlciB0byBkbyB0aGUgc2FtZSBmb3Igc2libGluZ3MuXG4gICAgICBjb25zdCBtaWdodFNpYmxpbmdzQmVPblRyYWNrZWRQYXRoID0gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUJlZm9yZU1vdW50KFxuICAgICAgICBmaWJlcixcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNob3VsZEluY2x1ZGVJblRyZWUgPSAhc2hvdWxkRmlsdGVyRmliZXIoZmliZXIpO1xuICAgICAgaWYgKHNob3VsZEluY2x1ZGVJblRyZWUpIHtcbiAgICAgICAgcmVjb3JkTW91bnQoZmliZXIsIHBhcmVudEZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpO1xuICAgICAgICAgIC8vIElmIGFuIGFuY2VzdG9yIHVwZGF0ZWQsIHdlIHNob3VsZCBtYXJrIHRoZSBuZWFyZXN0IGhvc3Qgbm9kZXMgZm9yIGhpZ2hsaWdodGluZy5cbiAgICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCkge1xuICAgICAgICAgICAgdHJhY2VVcGRhdGVzRm9yTm9kZXMuYWRkKGZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBkbyBub3QgcmUtZW5hYmxlIHRoZSB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlIGZsYWcgaW4gdGhpcyBicmFuY2gsXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBoaWdobGlnaHQgZXZlcnkgaG9zdCBub2RlIGluc2lkZSBvZiBhIG5ld2x5IG1vdW50ZWQgc3VidHJlZS5cbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNTdXNwZW5zZSA9IGZpYmVyLnRhZyA9PT0gUmVhY3RUeXBlT2ZXb3JrLlN1c3BlbnNlQ29tcG9uZW50O1xuICAgICAgaWYgKGlzU3VzcGVuc2UpIHtcbiAgICAgICAgY29uc3QgaXNUaW1lZE91dCA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICAgIGlmIChpc1RpbWVkT3V0KSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiBTdXNwZW5zZSBtb3VudHMgaW4gYSB0aW1lZC1vdXQgc3RhdGUsXG4gICAgICAgICAgLy8gZ2V0IHRoZSBmYWxsYmFjayBjaGlsZCBmcm9tIHRoZSBpbm5lciBmcmFnbWVudCBhbmQgbW91bnRcbiAgICAgICAgICAvLyBpdCBhcyBpZiBpdCB3YXMgb3VyIG93biBjaGlsZC4gVXBkYXRlcyBoYW5kbGUgdGhpcyB0b28uXG4gICAgICAgICAgY29uc3QgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgICBjb25zdCBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudFxuICAgICAgICAgICAgPyBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZmFsbGJhY2tDaGlsZCA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudFxuICAgICAgICAgICAgPyBmYWxsYmFja0NoaWxkRnJhZ21lbnQuY2hpbGRcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAoZmFsbGJhY2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgICBmYWxsYmFja0NoaWxkLFxuICAgICAgICAgICAgICBzaG91bGRJbmNsdWRlSW5UcmVlID8gZmliZXIgOiBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBwcmltYXJ5Q2hpbGQ6IEZpYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgY29uc3QgYXJlU3VzcGVuc2VDaGlsZHJlbkNvbmRpdGlvbmFsbHlXcmFwcGVkID1cbiAgICAgICAgICAgIE9mZnNjcmVlbkNvbXBvbmVudCA9PT0gLTE7XG4gICAgICAgICAgaWYgKGFyZVN1c3BlbnNlQ2hpbGRyZW5Db25kaXRpb25hbGx5V3JhcHBlZCkge1xuICAgICAgICAgICAgcHJpbWFyeUNoaWxkID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaWJlci5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJpbWFyeUNoaWxkID0gZmliZXIuY2hpbGQuY2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmltYXJ5Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgcHJpbWFyeUNoaWxkLFxuICAgICAgICAgICAgICBzaG91bGRJbmNsdWRlSW5UcmVlID8gZmliZXIgOiBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmliZXIuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICBmaWJlci5jaGlsZCxcbiAgICAgICAgICAgIHNob3VsZEluY2x1ZGVJblRyZWUgPyBmaWJlciA6IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXZSdyZSBleGl0aW5nIHRoaXMgRmliZXIgbm93LCBhbmQgZW50ZXJpbmcgaXRzIHNpYmxpbmdzLlxuICAgICAgLy8gSWYgd2UgaGF2ZSBzZWxlY3Rpb24gdG8gcmVzdG9yZSwgd2UgbWlnaHQgbmVlZCB0byByZS1hY3RpdmF0ZSB0cmFja2luZy5cbiAgICAgIHVwZGF0ZVRyYWNrZWRQYXRoU3RhdGVBZnRlck1vdW50KG1pZ2h0U2libGluZ3NCZU9uVHJhY2tlZFBhdGgpO1xuXG4gICAgICBmaWJlciA9IHRyYXZlcnNlU2libGluZ3MgPyBmaWJlci5zaWJsaW5nIDogbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBXZSB1c2UgdGhpcyB0byBzaW11bGF0ZSB1bm1vdW50aW5nIGZvciBTdXNwZW5zZSB0cmVlc1xuICAvLyB3aGVuIHdlIHN3aXRjaCBmcm9tIHByaW1hcnkgdG8gZmFsbGJhY2suXG4gIGZ1bmN0aW9uIHVubW91bnRGaWJlckNoaWxkcmVuUmVjdXJzaXZlbHkoZmliZXI6IEZpYmVyKSB7XG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgZGVidWcoJ3VubW91bnRGaWJlckNoaWxkcmVuUmVjdXJzaXZlbHkoKScsIGZpYmVyKTtcbiAgICB9XG5cbiAgICAvLyBXZSBtaWdodCBtZWV0IGEgbmVzdGVkIFN1c3BlbnNlIG9uIG91ciB3YXkuXG4gICAgY29uc3QgaXNUaW1lZE91dFN1c3BlbnNlID1cbiAgICAgIGZpYmVyLnRhZyA9PT0gUmVhY3RUeXBlT2ZXb3JrLlN1c3BlbnNlQ29tcG9uZW50ICYmXG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgbGV0IGNoaWxkID0gZmliZXIuY2hpbGQ7XG4gICAgaWYgKGlzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgLy8gSWYgaXQncyBzaG93aW5nIGZhbGxiYWNrIHRyZWUsIGxldCdzIHRyYXZlcnNlIGl0IGluc3RlYWQuXG4gICAgICBjb25zdCBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGZpYmVyLmNoaWxkO1xuICAgICAgY29uc3QgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gcHJpbWFyeUNoaWxkRnJhZ21lbnRcbiAgICAgICAgPyBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nXG4gICAgICAgIDogbnVsbDtcbiAgICAgIC8vIFNraXAgb3ZlciB0byB0aGUgcmVhbCBGaWJlciBjaGlsZC5cbiAgICAgIGNoaWxkID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50ID8gZmFsbGJhY2tDaGlsZEZyYWdtZW50LmNoaWxkIDogbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlY29yZCBzaW11bGF0ZWQgdW5tb3VudHMgY2hpbGRyZW4tZmlyc3QuXG4gICAgICAvLyBXZSBza2lwIG5vZGVzIHdpdGhvdXQgcmV0dXJuIGJlY2F1c2UgdGhvc2UgYXJlIHJlYWwgdW5tb3VudHMuXG4gICAgICBpZiAoY2hpbGQucmV0dXJuICE9PSBudWxsKSB7XG4gICAgICAgIHVubW91bnRGaWJlckNoaWxkcmVuUmVjdXJzaXZlbHkoY2hpbGQpO1xuICAgICAgICByZWNvcmRVbm1vdW50KGNoaWxkLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRQcm9maWxpbmdEdXJhdGlvbnMoZmliZXI6IEZpYmVyKSB7XG4gICAgY29uc3QgaWQgPSBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKTtcbiAgICBjb25zdCB7YWN0dWFsRHVyYXRpb24sIHRyZWVCYXNlRHVyYXRpb259ID0gZmliZXI7XG5cbiAgICBpZFRvVHJlZUJhc2VEdXJhdGlvbk1hcC5zZXQoaWQsIHRyZWVCYXNlRHVyYXRpb24gfHwgMCk7XG5cbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIGNvbnN0IHthbHRlcm5hdGV9ID0gZmliZXI7XG5cbiAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHVwZGF0ZSB0cmVlQmFzZUR1cmF0aW9uIGV2ZW4gaWYgdGhlIGN1cnJlbnQgRmliZXIgZGlkIG5vdCByZW5kZXIsXG4gICAgICAvLyBiZWNhdXNlIGl0J3MgcG9zc2libGUgdGhhdCBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzIGRpZC5cbiAgICAgIGlmIChcbiAgICAgICAgYWx0ZXJuYXRlID09IG51bGwgfHxcbiAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiAhPT0gYWx0ZXJuYXRlLnRyZWVCYXNlRHVyYXRpb25cbiAgICAgICkge1xuICAgICAgICAvLyBUcmVlIGJhc2UgZHVyYXRpb24gdXBkYXRlcyBhcmUgaW5jbHVkZWQgaW4gdGhlIG9wZXJhdGlvbnMgdHlwZWQgYXJyYXkuXG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gY29udmVydCB0aGVtIGZyb20gbWlsbGlzZWNvbmRzIHRvIG1pY3Jvc2Vjb25kcyBzbyB3ZSBjYW4gc2VuZCB0aGVtIGFzIGludHMuXG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZFRyZWVCYXNlRHVyYXRpb24gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICh0cmVlQmFzZUR1cmF0aW9uIHx8IDApICogMTAwMCxcbiAgICAgICAgKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oY29udmVydGVkVHJlZUJhc2VEdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgPT0gbnVsbCB8fCBkaWRGaWJlclJlbmRlcihhbHRlcm5hdGUsIGZpYmVyKSkge1xuICAgICAgICBpZiAoYWN0dWFsRHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoZSBhY3R1YWwgZHVyYXRpb24gcmVwb3J0ZWQgYnkgUmVhY3QgaW5jbHVkZXMgdGltZSBzcGVudCB3b3JraW5nIG9uIGNoaWxkcmVuLlxuICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIGluZm9ybWF0aW9uLCBidXQgaXQncyBhbHNvIHVzZWZ1bCB0byBiZSBhYmxlIHRvIGV4Y2x1ZGUgY2hpbGQgZHVyYXRpb25zLlxuICAgICAgICAgIC8vIFRoZSBmcm9udGVuZCBjYW4ndCBjb21wdXRlIHRoaXMsIHNpbmNlIHRoZSBpbW1lZGlhdGUgY2hpbGRyZW4gbWF5IGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQuXG4gICAgICAgICAgLy8gU28gd2UgbmVlZCB0byBkbyB0aGlzIG9uIHRoZSBiYWNrZW5kLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGNhbGN1bGF0ZWQgc2VsZiBkdXJhdGlvbiBpcyBub3QgdGhlIHNhbWUgdGhpbmcgYXMgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgLy8gVGhlIHR3byBhcmUgY2FsY3VsYXRlZCBkaWZmZXJlbnRseSAodHJlZSBkdXJhdGlvbiBkb2VzIG5vdCBhY2N1bXVsYXRlKS5cbiAgICAgICAgICBsZXQgc2VsZkR1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgbGV0IGNoaWxkID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZWxmRHVyYXRpb24gLT0gY2hpbGQuYWN0dWFsRHVyYXRpb24gfHwgMDtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBwcm9maWxpbmcgaXMgYWN0aXZlLCBzdG9yZSBkdXJhdGlvbnMgZm9yIGVsZW1lbnRzIHRoYXQgd2VyZSByZW5kZXJlZCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugc2hvdWxkIGRvIHRoaXMgZm9yIGFueSBmaWJlciB3ZSBwZXJmb3JtZWQgd29yayBvbiwgcmVnYXJkbGVzcyBvZiBpdHMgYWN0dWFsRHVyYXRpb24gdmFsdWUuXG4gICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyBhY3R1YWxEdXJhdGlvbiBtaWdodCBiZSAwIGZvciBmaWJlcnMgd2Ugd29ya2VkIG9uIChwYXJ0aWN1bGFybHkgaWYgd2UncmUgdXNpbmcgRGF0ZS5ub3cpXG4gICAgICAgICAgLy8gSW4gb3RoZXIgY2FzZXMgKGUuZy4gTWVtbykgYWN0dWFsRHVyYXRpb24gbWlnaHQgYmUgZ3JlYXRlciB0aGFuIDAgZXZlbiBpZiB3ZSBcImJhaWxlZCBvdXRcIi5cbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9ICgoY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhOiBhbnkpOiBDb21taXRQcm9maWxpbmdEYXRhKTtcbiAgICAgICAgICBtZXRhZGF0YS5kdXJhdGlvbnMucHVzaChpZCwgYWN0dWFsRHVyYXRpb24sIHNlbGZEdXJhdGlvbik7XG4gICAgICAgICAgbWV0YWRhdGEubWF4QWN0dWFsRHVyYXRpb24gPSBNYXRoLm1heChcbiAgICAgICAgICAgIG1ldGFkYXRhLm1heEFjdHVhbER1cmF0aW9uLFxuICAgICAgICAgICAgYWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZURlc2NyaXB0aW9uID0gZ2V0Q2hhbmdlRGVzY3JpcHRpb24oYWx0ZXJuYXRlLCBmaWJlcik7XG4gICAgICAgICAgICBpZiAoY2hhbmdlRGVzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmNoYW5nZURlc2NyaXB0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmNoYW5nZURlc2NyaXB0aW9ucy5zZXQoaWQsIGNoYW5nZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVDb250ZXh0c0ZvckZpYmVyKGZpYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRSZXNldENoaWxkcmVuKGZpYmVyOiBGaWJlciwgY2hpbGRTZXQ6IEZpYmVyKSB7XG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgZGVidWcoJ3JlY29yZFJlc2V0Q2hpbGRyZW4oKScsIGNoaWxkU2V0LCBmaWJlcik7XG4gICAgfVxuICAgIC8vIFRoZSBmcm9udGVuZCBvbmx5IHJlYWxseSBjYXJlcyBhYm91dCB0aGUgZGlzcGxheU5hbWUsIGtleSwgYW5kIGNoaWxkcmVuLlxuICAgIC8vIFRoZSBmaXJzdCB0d28gZG9uJ3QgcmVhbGx5IGNoYW5nZSwgc28gd2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggdGhlIG9yZGVyIG9mIGNoaWxkcmVuIGhlcmUuXG4gICAgLy8gVGhpcyBpcyB0cmlja2llciB0aGFuIGEgc2ltcGxlIGNvbXBhcmlzb24gdGhvdWdoLCBzaW5jZSBjZXJ0YWluIHR5cGVzIG9mIGZpYmVycyBhcmUgZmlsdGVyZWQuXG4gICAgY29uc3QgbmV4dENoaWxkcmVuOiBBcnJheTxudW1iZXI+ID0gW107XG5cbiAgICAvLyBUaGlzIGlzIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gdGhhdCBzaGFsbG93bHkgcmVjb3Vyc2VzIGNoaWxkcmVuLlxuICAgIC8vIFdlIG1pZ2h0IHdhbnQgdG8gcmV2aXNpdCB0aGlzIGlmIGl0IHByb3ZlcyB0byBiZSB0b28gaW5lZmZpY2llbnQuXG4gICAgbGV0IGNoaWxkID0gY2hpbGRTZXQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBmaW5kUmVvcmRlcmVkQ2hpbGRyZW5SZWN1cnNpdmVseShjaGlsZCwgbmV4dENoaWxkcmVuKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICBjb25zdCBudW1DaGlsZHJlbiA9IG5leHRDaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKG51bUNoaWxkcmVuIDwgMikge1xuICAgICAgLy8gTm8gbmVlZCB0byByZW9yZGVyLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwdXNoT3BlcmF0aW9uKFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4pO1xuICAgIHB1c2hPcGVyYXRpb24oZ2V0RmliZXJJRFRocm93cyhmaWJlcikpO1xuICAgIHB1c2hPcGVyYXRpb24obnVtQ2hpbGRyZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwdXNoT3BlcmF0aW9uKG5leHRDaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFJlb3JkZXJlZENoaWxkcmVuUmVjdXJzaXZlbHkoXG4gICAgZmliZXI6IEZpYmVyLFxuICAgIG5leHRDaGlsZHJlbjogQXJyYXk8bnVtYmVyPixcbiAgKSB7XG4gICAgaWYgKCFzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikpIHtcbiAgICAgIG5leHRDaGlsZHJlbi5wdXNoKGdldEZpYmVySURUaHJvd3MoZmliZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNoaWxkID0gZmliZXIuY2hpbGQ7XG4gICAgICBjb25zdCBpc1RpbWVkT3V0U3VzcGVuc2UgPVxuICAgICAgICBmaWJlci50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogaWYgU3VzcGVuc2UgbW91bnRzIGluIGEgdGltZWQtb3V0IHN0YXRlLFxuICAgICAgICAvLyBnZXQgdGhlIGZhbGxiYWNrIGNoaWxkIGZyb20gdGhlIGlubmVyIGZyYWdtZW50LFxuICAgICAgICAvLyBhbmQgc2tpcCBvdmVyIHRoZSBwcmltYXJ5IGNoaWxkLlxuICAgICAgICBjb25zdCBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGZpYmVyLmNoaWxkO1xuICAgICAgICBjb25zdCBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudFxuICAgICAgICAgID8gcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZ1xuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tDaGlsZCA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudFxuICAgICAgICAgID8gZmFsbGJhY2tDaGlsZEZyYWdtZW50LmNoaWxkXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoZmFsbGJhY2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkID0gZmFsbGJhY2tDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmRSZW9yZGVyZWRDaGlsZHJlblJlY3Vyc2l2ZWx5KGNoaWxkLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIGNsb3Nlc3QgdW5maWx0ZXJlZCBmaWJlciBwYXJlbnQgbmVlZHMgdG8gcmVzZXQgaXRzIGNoaWxkIGxpc3QuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZpYmVyUmVjdXJzaXZlbHkoXG4gICAgbmV4dEZpYmVyOiBGaWJlcixcbiAgICBwcmV2RmliZXI6IEZpYmVyLFxuICAgIHBhcmVudEZpYmVyOiBGaWJlciB8IG51bGwsXG4gICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZTogYm9vbGVhbixcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaWQgPSBnZXRPckdlbmVyYXRlRmliZXJJRChuZXh0RmliZXIpO1xuXG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgZGVidWcoJ3VwZGF0ZUZpYmVyUmVjdXJzaXZlbHkoKScsIG5leHRGaWJlciwgcGFyZW50RmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0cmFjZVVwZGF0ZXNFbmFibGVkKSB7XG4gICAgICBjb25zdCBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIobmV4dEZpYmVyKTtcbiAgICAgIGlmICh0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgIC8vIElmIGFuIGFuY2VzdG9yIHVwZGF0ZWQsIHdlIHNob3VsZCBtYXJrIHRoZSBuZWFyZXN0IGhvc3Qgbm9kZXMgZm9yIGhpZ2hsaWdodGluZy5cbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgICB0cmFjZVVwZGF0ZXNGb3JOb2Rlcy5hZGQobmV4dEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZWxlbWVudFR5cGUgPT09IEVsZW1lbnRUeXBlRnVuY3Rpb24gfHxcbiAgICAgICAgICBlbGVtZW50VHlwZSA9PT0gRWxlbWVudFR5cGVDbGFzcyB8fFxuICAgICAgICAgIGVsZW1lbnRUeXBlID09PSBFbGVtZW50VHlwZUNvbnRleHQgfHxcbiAgICAgICAgICBlbGVtZW50VHlwZSA9PT0gRWxlbWVudFR5cGVNZW1vIHx8XG4gICAgICAgICAgZWxlbWVudFR5cGUgPT09IEVsZW1lbnRUeXBlRm9yd2FyZFJlZlxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgaWYgdGhpcyBpcyBhIHRyYWNlZCBhbmNlc3RvciwgZmxhZyBmb3IgdGhlIG5lYXJlc3QgaG9zdCBkZXNjZW5kYW50KHMpLlxuICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUgPSBkaWRGaWJlclJlbmRlcihcbiAgICAgICAgICAgIHByZXZGaWJlcixcbiAgICAgICAgICAgIG5leHRGaWJlcixcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCAhPT0gbnVsbCAmJlxuICAgICAgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudC5pZCA9PT0gaWQgJiZcbiAgICAgIGRpZEZpYmVyUmVuZGVyKHByZXZGaWJlciwgbmV4dEZpYmVyKVxuICAgICkge1xuICAgICAgLy8gSWYgdGhpcyBGaWJlciBoYXMgdXBkYXRlZCwgY2xlYXIgY2FjaGVkIGluc3BlY3RlZCBkYXRhLlxuICAgICAgLy8gSWYgaXQgaXMgaW5zcGVjdGVkIGFnYWluLCBpdCBtYXkgbmVlZCB0byBiZSByZS1ydW4gdG8gb2J0YWluIHVwZGF0ZWQgaG9va3MgdmFsdWVzLlxuICAgICAgaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVJblRyZWUgPSAhc2hvdWxkRmlsdGVyRmliZXIobmV4dEZpYmVyKTtcbiAgICBjb25zdCBpc1N1c3BlbnNlID0gbmV4dEZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQ7XG4gICAgbGV0IHNob3VsZFJlc2V0Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICAvLyBUaGUgYmVoYXZpb3Igb2YgdGltZWQtb3V0IFN1c3BlbnNlIHRyZWVzIGlzIHVuaXF1ZS5cbiAgICAvLyBSYXRoZXIgdGhhbiB1bm1vdW50IHRoZSB0aW1lZCBvdXQgY29udGVudCAoYW5kIHBvc3NpYmx5IGxvc2UgaW1wb3J0YW50IHN0YXRlKSxcbiAgICAvLyBSZWFjdCByZS1wYXJlbnRzIHRoaXMgY29udGVudCB3aXRoaW4gYSBoaWRkZW4gRnJhZ21lbnQgd2hpbGUgdGhlIGZhbGxiYWNrIGlzIHNob3dpbmcuXG4gICAgLy8gVGhpcyBiZWhhdmlvciBkb2Vzbid0IG5lZWQgdG8gYmUgb2JzZXJ2YWJsZSBpbiB0aGUgRGV2VG9vbHMgdGhvdWdoLlxuICAgIC8vIEl0IG1pZ2h0IGV2ZW4gcmVzdWx0IGluIGEgYmFkIHVzZXIgZXhwZXJpZW5jZSBmb3IgZS5nLiBub2RlIHNlbGVjdGlvbiBpbiB0aGUgRWxlbWVudHMgcGFuZWwuXG4gICAgLy8gVGhlIGVhc2llc3QgZml4IGlzIHRvIHN0cmlwIG91dCB0aGUgaW50ZXJtZWRpYXRlIEZyYWdtZW50IGZpYmVycyxcbiAgICAvLyBzbyB0aGUgRWxlbWVudHMgcGFuZWwgYW5kIFByb2ZpbGVyIGRvbid0IG5lZWQgdG8gc3BlY2lhbCBjYXNlIHRoZW0uXG4gICAgLy8gU3VzcGVuc2UgY29tcG9uZW50cyBvbmx5IGhhdmUgYSBub24tbnVsbCBtZW1vaXplZFN0YXRlIGlmIHRoZXkncmUgdGltZWQtb3V0LlxuICAgIGNvbnN0IHByZXZEaWRUaW1lb3V0ID0gaXNTdXNwZW5zZSAmJiBwcmV2RmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICBjb25zdCBuZXh0RGlkVGltZU91dCA9IGlzU3VzcGVuc2UgJiYgbmV4dEZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgLy8gVGhlIGxvZ2ljIGJlbG93IGlzIGluc3BpcmVkIGJ5IHRoZSBjb2RlIHBhdGhzIGluIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KClcbiAgICAvLyBpbnNpZGUgUmVhY3RGaWJlckJlZ2luV29yayBpbiB0aGUgUmVhY3Qgc291cmNlIGNvZGUuXG4gICAgaWYgKHByZXZEaWRUaW1lb3V0ICYmIG5leHREaWRUaW1lT3V0KSB7XG4gICAgICAvLyBGYWxsYmFjayAtPiBGYWxsYmFjazpcbiAgICAgIC8vIDEuIFJlY29uY2lsZSBmYWxsYmFjayBzZXQuXG4gICAgICBjb25zdCBuZXh0RmliZXJDaGlsZCA9IG5leHRGaWJlci5jaGlsZDtcbiAgICAgIGNvbnN0IG5leHRGYWxsYmFja0NoaWxkU2V0ID0gbmV4dEZpYmVyQ2hpbGRcbiAgICAgICAgPyBuZXh0RmliZXJDaGlsZC5zaWJsaW5nXG4gICAgICAgIDogbnVsbDtcbiAgICAgIC8vIE5vdGU6IFdlIGNhbid0IHVzZSBuZXh0RmliZXIuY2hpbGQuc2libGluZy5hbHRlcm5hdGVcbiAgICAgIC8vIGJlY2F1c2UgdGhlIHNldCBpcyBzcGVjaWFsIGFuZCBhbHRlcm5hdGUgbWF5IG5vdCBleGlzdC5cbiAgICAgIGNvbnN0IHByZXZGaWJlckNoaWxkID0gcHJldkZpYmVyLmNoaWxkO1xuICAgICAgY29uc3QgcHJldkZhbGxiYWNrQ2hpbGRTZXQgPSBwcmV2RmliZXJDaGlsZFxuICAgICAgICA/IHByZXZGaWJlckNoaWxkLnNpYmxpbmdcbiAgICAgICAgOiBudWxsO1xuICAgICAgaWYgKFxuICAgICAgICBuZXh0RmFsbGJhY2tDaGlsZFNldCAhPSBudWxsICYmXG4gICAgICAgIHByZXZGYWxsYmFja0NoaWxkU2V0ICE9IG51bGwgJiZcbiAgICAgICAgdXBkYXRlRmliZXJSZWN1cnNpdmVseShcbiAgICAgICAgICBuZXh0RmFsbGJhY2tDaGlsZFNldCxcbiAgICAgICAgICBwcmV2RmFsbGJhY2tDaGlsZFNldCxcbiAgICAgICAgICBuZXh0RmliZXIsXG4gICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldkRpZFRpbWVvdXQgJiYgIW5leHREaWRUaW1lT3V0KSB7XG4gICAgICAvLyBGYWxsYmFjayAtPiBQcmltYXJ5OlxuICAgICAgLy8gMS4gVW5tb3VudCBmYWxsYmFjayBzZXRcbiAgICAgIC8vIE5vdGU6IGRvbid0IGVtdWxhdGUgZmFsbGJhY2sgdW5tb3VudCBiZWNhdXNlIFJlYWN0IGFjdHVhbGx5IGRpZCBpdC5cbiAgICAgIC8vIDIuIE1vdW50IHByaW1hcnkgc2V0XG4gICAgICBjb25zdCBuZXh0UHJpbWFyeUNoaWxkU2V0ID0gbmV4dEZpYmVyLmNoaWxkO1xuICAgICAgaWYgKG5leHRQcmltYXJ5Q2hpbGRTZXQgIT09IG51bGwpIHtcbiAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KFxuICAgICAgICAgIG5leHRQcmltYXJ5Q2hpbGRTZXQsXG4gICAgICAgICAgc2hvdWxkSW5jbHVkZUluVHJlZSA/IG5leHRGaWJlciA6IHBhcmVudEZpYmVyLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXByZXZEaWRUaW1lb3V0ICYmIG5leHREaWRUaW1lT3V0KSB7XG4gICAgICAvLyBQcmltYXJ5IC0+IEZhbGxiYWNrOlxuICAgICAgLy8gMS4gSGlkZSBwcmltYXJ5IHNldFxuICAgICAgLy8gVGhpcyBpcyBub3QgYSByZWFsIHVubW91bnQsIHNvIGl0IHdvbid0IGdldCByZXBvcnRlZCBieSBSZWFjdC5cbiAgICAgIC8vIFdlIG5lZWQgdG8gbWFudWFsbHkgd2FsayB0aGUgcHJldmlvdXMgdHJlZSBhbmQgcmVjb3JkIHVubW91bnRzLlxuICAgICAgdW5tb3VudEZpYmVyQ2hpbGRyZW5SZWN1cnNpdmVseShwcmV2RmliZXIpO1xuICAgICAgLy8gMi4gTW91bnQgZmFsbGJhY2sgc2V0XG4gICAgICBjb25zdCBuZXh0RmliZXJDaGlsZCA9IG5leHRGaWJlci5jaGlsZDtcbiAgICAgIGNvbnN0IG5leHRGYWxsYmFja0NoaWxkU2V0ID0gbmV4dEZpYmVyQ2hpbGRcbiAgICAgICAgPyBuZXh0RmliZXJDaGlsZC5zaWJsaW5nXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGlmIChuZXh0RmFsbGJhY2tDaGlsZFNldCAhPSBudWxsKSB7XG4gICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShcbiAgICAgICAgICBuZXh0RmFsbGJhY2tDaGlsZFNldCxcbiAgICAgICAgICBzaG91bGRJbmNsdWRlSW5UcmVlID8gbmV4dEZpYmVyIDogcGFyZW50RmliZXIsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICApO1xuICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29tbW9uIGNhc2U6IFByaW1hcnkgLT4gUHJpbWFyeS5cbiAgICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgY29kZSBwYXRoIGFzIGZvciBub24tU3VzcGVuc2UgZmliZXJzLlxuICAgICAgaWYgKG5leHRGaWJlci5jaGlsZCAhPT0gcHJldkZpYmVyLmNoaWxkKSB7XG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBpcyBkaWZmZXJlbnQsIHdlIG5lZWQgdG8gdHJhdmVyc2UgdGhlbS5cbiAgICAgICAgLy8gRWFjaCBuZXh0IGNoaWxkIHdpbGwgYmUgZWl0aGVyIGEgbmV3IGNoaWxkIChtb3VudCkgb3IgYW4gYWx0ZXJuYXRlICh1cGRhdGUpLlxuICAgICAgICBsZXQgbmV4dENoaWxkID0gbmV4dEZpYmVyLmNoaWxkO1xuICAgICAgICBsZXQgcHJldkNoaWxkQXRTYW1lSW5kZXggPSBwcmV2RmliZXIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChuZXh0Q2hpbGQpIHtcbiAgICAgICAgICAvLyBXZSBhbHJlYWR5IGtub3cgY2hpbGRyZW4gd2lsbCBiZSByZWZlcmVudGlhbGx5IGRpZmZlcmVudCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhleSBhcmUgZWl0aGVyIG5ldyBtb3VudHMgb3IgYWx0ZXJuYXRlcyBvZiBwcmV2aW91cyBjaGlsZHJlbi5cbiAgICAgICAgICAvLyBTY2hlZHVsZSB1cGRhdGVzIGFuZCBtb3VudHMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYWx0ZXJuYXRlcyBleGlzdC5cbiAgICAgICAgICAvLyBXZSBkb24ndCB0cmFjayBkZWxldGlvbnMgaGVyZSBiZWNhdXNlIHRoZXkgYXJlIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICAgICAgICAgaWYgKG5leHRDaGlsZC5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IG5leHRDaGlsZC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHVwZGF0ZUZpYmVyUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgICAgIHByZXZDaGlsZCxcbiAgICAgICAgICAgICAgICBzaG91bGRJbmNsdWRlSW5UcmVlID8gbmV4dEZpYmVyIDogcGFyZW50RmliZXIsXG4gICAgICAgICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIElmIGEgbmVzdGVkIHRyZWUgY2hpbGQgb3JkZXIgY2hhbmdlZCBidXQgaXQgY2FuJ3QgaGFuZGxlIGl0cyBvd25cbiAgICAgICAgICAgICAgLy8gY2hpbGQgb3JkZXIgaW52YWxpZGF0aW9uIChlLmcuIGJlY2F1c2UgaXQncyBmaWx0ZXJlZCBvdXQgbGlrZSBob3N0IG5vZGVzKSxcbiAgICAgICAgICAgICAgLy8gcHJvcGFnYXRlIHRoZSBuZWVkIHRvIHJlc2V0IGNoaWxkIG9yZGVyIHVwd2FyZHMgdG8gdGhpcyBGaWJlci5cbiAgICAgICAgICAgICAgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIb3dldmVyIHdlIGFsc28ga2VlcCB0cmFjayBpZiB0aGUgb3JkZXIgb2YgdGhlIGNoaWxkcmVuIG1hdGNoZXNcbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBvcmRlci4gVGhleSBhcmUgYWx3YXlzIGRpZmZlcmVudCByZWZlcmVudGlhbGx5LCBidXRcbiAgICAgICAgICAgIC8vIGlmIHRoZSBpbnN0YW5jZXMgbGluZSB1cCBjb25jZXB0dWFsbHkgd2UnbGwgd2FudCB0byBrbm93IHRoYXQuXG4gICAgICAgICAgICBpZiAocHJldkNoaWxkICE9PSBwcmV2Q2hpbGRBdFNhbWVJbmRleCkge1xuICAgICAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgICBuZXh0Q2hpbGQsXG4gICAgICAgICAgICAgIHNob3VsZEluY2x1ZGVJblRyZWUgPyBuZXh0RmliZXIgOiBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRyeSB0aGUgbmV4dCBjaGlsZC5cbiAgICAgICAgICBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGQuc2libGluZztcbiAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBwb2ludGVyIGluIHRoZSBwcmV2aW91cyBsaXN0IHNvIHRoYXQgd2UgY2FuXG4gICAgICAgICAgLy8ga2VlcCBjb21wYXJpbmcgaWYgdGhleSBsaW5lIHVwLlxuICAgICAgICAgIGlmICghc2hvdWxkUmVzZXRDaGlsZHJlbiAmJiBwcmV2Q2hpbGRBdFNhbWVJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldkNoaWxkQXRTYW1lSW5kZXggPSBwcmV2Q2hpbGRBdFNhbWVJbmRleC5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIG1vcmUgY2hpbGRyZW4sIGJ1dCB1c2VkIHRvLCB0aGV5IGRvbid0IGxpbmUgdXAuXG4gICAgICAgIGlmIChwcmV2Q2hpbGRBdFNhbWVJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgICAgIC8vIElmIHdlJ3JlIHRyYWNpbmcgdXBkYXRlcyBhbmQgd2UndmUgYmFpbGVkIG91dCBiZWZvcmUgcmVhY2hpbmcgYSBob3N0IG5vZGUsXG4gICAgICAgICAgLy8gd2Ugc2hvdWxkIGZhbGwgYmFjayB0byByZWN1cnNpdmVseSBtYXJraW5nIHRoZSBuZWFyZXN0IGhvc3QgZGVzY2VuZGFudHMgZm9yIGhpZ2hsaWdodC5cbiAgICAgICAgICBpZiAodHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgaG9zdEZpYmVycyA9IGZpbmRBbGxDdXJyZW50SG9zdEZpYmVycyhcbiAgICAgICAgICAgICAgZ2V0RmliZXJJRFRocm93cyhuZXh0RmliZXIpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGhvc3RGaWJlcnMuZm9yRWFjaChob3N0RmliZXIgPT4ge1xuICAgICAgICAgICAgICB0cmFjZVVwZGF0ZXNGb3JOb2Rlcy5hZGQoaG9zdEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkSW5jbHVkZUluVHJlZSkge1xuICAgICAgY29uc3QgaXNQcm9maWxpbmdTdXBwb3J0ZWQgPSBuZXh0RmliZXIuaGFzT3duUHJvcGVydHkoJ3RyZWVCYXNlRHVyYXRpb24nKTtcbiAgICAgIGlmIChpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZWNvcmRQcm9maWxpbmdEdXJhdGlvbnMobmV4dEZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZFJlc2V0Q2hpbGRyZW4pIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY3Jhd2wgdGhlIHN1YnRyZWUgZm9yIGNsb3Nlc3Qgbm9uLWZpbHRlcmVkIEZpYmVyc1xuICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gZGlzcGxheSB0aGVtIGluIGEgZmxhdCBjaGlsZHJlbiBzZXQuXG4gICAgICBpZiAoc2hvdWxkSW5jbHVkZUluVHJlZSkge1xuICAgICAgICAvLyBOb3JtYWxseSwgc2VhcmNoIGZvciBjaGlsZHJlbiBmcm9tIHRoZSByZW5kZXJlZCBjaGlsZC5cbiAgICAgICAgbGV0IG5leHRDaGlsZFNldCA9IG5leHRGaWJlci5jaGlsZDtcbiAgICAgICAgaWYgKG5leHREaWRUaW1lT3V0KSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB0aW1lZC1vdXQgU3VzcGVuc2UgcmVuZGVycyB0aGUgZmFsbGJhY2sgc2V0LlxuICAgICAgICAgIGNvbnN0IG5leHRGaWJlckNoaWxkID0gbmV4dEZpYmVyLmNoaWxkO1xuICAgICAgICAgIG5leHRDaGlsZFNldCA9IG5leHRGaWJlckNoaWxkID8gbmV4dEZpYmVyQ2hpbGQuc2libGluZyA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRDaGlsZFNldCAhPSBudWxsKSB7XG4gICAgICAgICAgcmVjb3JkUmVzZXRDaGlsZHJlbihuZXh0RmliZXIsIG5leHRDaGlsZFNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UndmUgaGFuZGxlZCB0aGUgY2hpbGQgb3JkZXIgY2hhbmdlIGZvciB0aGlzIEZpYmVyLlxuICAgICAgICAvLyBTaW5jZSBpdCdzIGluY2x1ZGVkLCB0aGVyZSdzIG5vIG5lZWQgdG8gaW52YWxpZGF0ZSBwYXJlbnQgY2hpbGQgb3JkZXIuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExldCB0aGUgY2xvc2VzdCB1bmZpbHRlcmVkIHBhcmVudCBGaWJlciByZXNldCBpdHMgY2hpbGQgb3JkZXIgaW5zdGVhZC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIC8vIFdlIGRvbid0IHBhdGNoIGFueSBtZXRob2RzIHNvIHRoZXJlIGlzIG5vIGNsZWFudXAuXG4gIH1cblxuICBmdW5jdGlvbiByb290U3VwcG9ydHNQcm9maWxpbmcocm9vdCkge1xuICAgIGlmIChyb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zICE9IG51bGwpIHtcbiAgICAgIC8vIHYxNiBidWlsZHMgaW5jbHVkZSB0aGlzIGZpZWxkIGZvciB0aGUgc2NoZWR1bGVyL3RyYWNpbmcgQVBJLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHJvb3QuY3VycmVudCAhPSBudWxsICYmXG4gICAgICByb290LmN1cnJlbnQuaGFzT3duUHJvcGVydHkoJ3RyZWVCYXNlRHVyYXRpb24nKVxuICAgICkge1xuICAgICAgLy8gVGhlIHNjaGVkdWxlci90cmFjaW5nIEFQSSB3YXMgcmVtb3ZlZCBpbiB2MTcgdGhvdWdoXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIGEgbm9uLXJvb3QgRmliZXIuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoSW5pdGlhbE9wZXJhdGlvbnMoKSB7XG4gICAgY29uc3QgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlID0gcGVuZGluZ09wZXJhdGlvbnNRdWV1ZTtcblxuICAgIHBlbmRpbmdPcGVyYXRpb25zUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKFxuICAgICAgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlICE9PSBudWxsICYmXG4gICAgICBsb2NhbFBlbmRpbmdPcGVyYXRpb25zUXVldWUubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgLy8gV2UgbWF5IGhhdmUgYWxyZWFkeSBxdWV1ZWQgdXAgc29tZSBvcGVyYXRpb25zIGJlZm9yZSB0aGUgZnJvbnRlbmQgY29ubmVjdGVkXG4gICAgICAvLyBJZiBzbywgbGV0IHRoZSBmcm9udGVuZCBrbm93IGFib3V0IHRoZW0uXG4gICAgICBsb2NhbFBlbmRpbmdPcGVyYXRpb25zUXVldWUuZm9yRWFjaChvcGVyYXRpb25zID0+IHtcbiAgICAgICAgaG9vay5lbWl0KCdvcGVyYXRpb25zJywgb3BlcmF0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQmVmb3JlIHRoZSB0cmF2ZXJzYWxzLCByZW1lbWJlciB0byBzdGFydCB0cmFja2luZ1xuICAgICAgLy8gb3VyIHBhdGggaW4gY2FzZSB3ZSBoYXZlIHNlbGVjdGlvbiB0byByZXN0b3JlLlxuICAgICAgaWYgKHRyYWNrZWRQYXRoICE9PSBudWxsKSB7XG4gICAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGhhdmUgbm90IGJlZW4gcHJvZmlsaW5nLCB0aGVuIHdlIGNhbiBqdXN0IHdhbGsgdGhlIHRyZWUgYW5kIGJ1aWxkIHVwIGl0cyBjdXJyZW50IHN0YXRlIGFzLWlzLlxuICAgICAgaG9vay5nZXRGaWJlclJvb3RzKHJlbmRlcmVySUQpLmZvckVhY2gocm9vdCA9PiB7XG4gICAgICAgIGN1cnJlbnRSb290SUQgPSBnZXRPckdlbmVyYXRlRmliZXJJRChyb290LmN1cnJlbnQpO1xuICAgICAgICBzZXRSb290UHNldWRvS2V5KGN1cnJlbnRSb290SUQsIHJvb3QuY3VycmVudCk7XG5cbiAgICAgICAgLy8gSGFuZGxlIG11bHRpLXJlbmRlcmVyIGVkZ2UtY2FzZSB3aGVyZSBvbmx5IHNvbWUgdjE2IHJlbmRlcmVycyBzdXBwb3J0IHByb2ZpbGluZy5cbiAgICAgICAgaWYgKGlzUHJvZmlsaW5nICYmIHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290KSkge1xuICAgICAgICAgIC8vIElmIHByb2ZpbGluZyBpcyBhY3RpdmUsIHN0b3JlIGNvbW1pdCB0aW1lIGFuZCBkdXJhdGlvbi5cbiAgICAgICAgICAvLyBUaGUgZnJvbnRlbmQgbWF5IHJlcXVlc3QgdGhpcyBpbmZvcm1hdGlvbiBhZnRlciBwcm9maWxpbmcgaGFzIHN0b3BwZWQuXG4gICAgICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhID0ge1xuICAgICAgICAgICAgY2hhbmdlRGVzY3JpcHRpb25zOiByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMgPyBuZXcgTWFwKCkgOiBudWxsLFxuICAgICAgICAgICAgZHVyYXRpb25zOiBbXSxcbiAgICAgICAgICAgIGNvbW1pdFRpbWU6IGdldEN1cnJlbnRUaW1lKCkgLSBwcm9maWxpbmdTdGFydFRpbWUsXG4gICAgICAgICAgICBtYXhBY3R1YWxEdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHByaW9yaXR5TGV2ZWw6IG51bGwsXG4gICAgICAgICAgICB1cGRhdGVyczogZ2V0VXBkYXRlcnNMaXN0KHJvb3QpLFxuICAgICAgICAgICAgZWZmZWN0RHVyYXRpb246IG51bGwsXG4gICAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IG51bGwsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KTtcbiAgICAgICAgY3VycmVudFJvb3RJRCA9IC0xO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VXBkYXRlcnNMaXN0KHJvb3QpOiBBcnJheTxTZXJpYWxpemVkRWxlbWVudD4gfCBudWxsIHtcbiAgICByZXR1cm4gcm9vdC5tZW1vaXplZFVwZGF0ZXJzICE9IG51bGxcbiAgICAgID8gQXJyYXkuZnJvbShyb290Lm1lbW9pemVkVXBkYXRlcnMpLm1hcChmaWJlclRvU2VyaWFsaXplZEVsZW1lbnQpXG4gICAgICA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb21taXRGaWJlclVubW91bnQoZmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIG5vdCByZWN1cnNpdmUuXG4gICAgLy8gV2UgY2FuJ3QgdHJhdmVyc2UgZmliZXJzIGFmdGVyIHVubW91bnRpbmcgc28gaW5zdGVhZFxuICAgIC8vIHdlIHJlbHkgb24gUmVhY3QgdGVsbGluZyB1cyBhYm91dCBlYWNoIHVubW91bnQuXG4gICAgcmVjb3JkVW5tb3VudChmaWJlciwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdChyb290KSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nICYmIHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290KSkge1xuICAgICAgaWYgKGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7ZWZmZWN0RHVyYXRpb24sIHBhc3NpdmVFZmZlY3REdXJhdGlvbn0gPSBnZXRFZmZlY3REdXJhdGlvbnMoXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhLmVmZmVjdER1cmF0aW9uID0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29tbWl0RmliZXJSb290KHJvb3QsIHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICAgIGNvbnN0IGFsdGVybmF0ZSA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgLy8gRmx1c2ggYW55IHBlbmRpbmcgRmliZXJzIHRoYXQgd2UgYXJlIHVudHJhY2tpbmcgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIG5ldyBjb21taXQuXG4gICAgLy8gSWYgd2UgZG9uJ3QgZG8gdGhpcywgd2UgbWlnaHQgZW5kIHVwIGRvdWJsZS1kZWxldGluZyBGaWJlcnMgaW4gc29tZSBjYXNlcyAobGlrZSBMZWdhY3kgU3VzcGVuc2UpLlxuICAgIHVudHJhY2tGaWJlcnMoKTtcblxuICAgIGN1cnJlbnRSb290SUQgPSBnZXRPckdlbmVyYXRlRmliZXJJRChjdXJyZW50KTtcblxuICAgIC8vIEJlZm9yZSB0aGUgdHJhdmVyc2FscywgcmVtZW1iZXIgdG8gc3RhcnQgdHJhY2tpbmdcbiAgICAvLyBvdXIgcGF0aCBpbiBjYXNlIHdlIGhhdmUgc2VsZWN0aW9uIHRvIHJlc3RvcmUuXG4gICAgaWYgKHRyYWNrZWRQYXRoICE9PSBudWxsKSB7XG4gICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgIHRyYWNlVXBkYXRlc0Zvck5vZGVzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG11bHRpLXJlbmRlcmVyIGVkZ2UtY2FzZSB3aGVyZSBvbmx5IHNvbWUgdjE2IHJlbmRlcmVycyBzdXBwb3J0IHByb2ZpbGluZy5cbiAgICBjb25zdCBpc1Byb2ZpbGluZ1N1cHBvcnRlZCA9IHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290KTtcblxuICAgIGlmIChpc1Byb2ZpbGluZyAmJiBpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgLy8gSWYgcHJvZmlsaW5nIGlzIGFjdGl2ZSwgc3RvcmUgY29tbWl0IHRpbWUgYW5kIGR1cmF0aW9uLlxuICAgICAgLy8gVGhlIGZyb250ZW5kIG1heSByZXF1ZXN0IHRoaXMgaW5mb3JtYXRpb24gYWZ0ZXIgcHJvZmlsaW5nIGhhcyBzdG9wcGVkLlxuICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhID0ge1xuICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnM6IHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA/IG5ldyBNYXAoKSA6IG51bGwsXG4gICAgICAgIGR1cmF0aW9uczogW10sXG4gICAgICAgIGNvbW1pdFRpbWU6IGdldEN1cnJlbnRUaW1lKCkgLSBwcm9maWxpbmdTdGFydFRpbWUsXG4gICAgICAgIG1heEFjdHVhbER1cmF0aW9uOiAwLFxuICAgICAgICBwcmlvcml0eUxldmVsOlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPT0gbnVsbCA/IG51bGwgOiBmb3JtYXRQcmlvcml0eUxldmVsKHByaW9yaXR5TGV2ZWwpLFxuXG4gICAgICAgIHVwZGF0ZXJzOiBnZXRVcGRhdGVyc0xpc3Qocm9vdCksXG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byBudWxsOyBpZiBuZXcgZW5vdWdoIFJlYWN0IHZlcnNpb24gaXMgcnVubmluZyxcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIHdpbGwgYmUgcmVhZCBkdXJpbmcgc2VwYXJhdGUgaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCgpIGNhbGwuXG4gICAgICAgIGVmZmVjdER1cmF0aW9uOiBudWxsLFxuICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChhbHRlcm5hdGUpIHtcbiAgICAgIC8vIFRPRE86IHJlbHlpbmcgb24gdGhpcyBzZWVtcyBhIGJpdCBmaXNoeS5cbiAgICAgIGNvbnN0IHdhc01vdW50ZWQgPVxuICAgICAgICBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmXG4gICAgICAgIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbDtcbiAgICAgIGNvbnN0IGlzTW91bnRlZCA9XG4gICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ICE9IG51bGw7XG4gICAgICBpZiAoIXdhc01vdW50ZWQgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICAgIHNldFJvb3RQc2V1ZG9LZXkoY3VycmVudFJvb3RJRCwgY3VycmVudCk7XG4gICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShjdXJyZW50LCBudWxsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh3YXNNb3VudGVkICYmIGlzTW91bnRlZCkge1xuICAgICAgICAvLyBVcGRhdGUgYW4gZXhpc3Rpbmcgcm9vdC5cbiAgICAgICAgdXBkYXRlRmliZXJSZWN1cnNpdmVseShjdXJyZW50LCBhbHRlcm5hdGUsIG51bGwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAod2FzTW91bnRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICAgIC8vIFVubW91bnQgYW4gZXhpc3Rpbmcgcm9vdC5cbiAgICAgICAgcmVtb3ZlUm9vdFBzZXVkb0tleShjdXJyZW50Um9vdElEKTtcbiAgICAgICAgcmVjb3JkVW5tb3VudChjdXJyZW50LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICBzZXRSb290UHNldWRvS2V5KGN1cnJlbnRSb290SUQsIGN1cnJlbnQpO1xuICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KGN1cnJlbnQsIG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvZmlsaW5nICYmIGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgYXQgbGVhc3Qgb25lIEZpYmVyIHBlcmZvcm1lZCB3b3JrIGR1cmluZyB0aGlzIGNvbW1pdC5cbiAgICAgIC8vIElmIG5vdCwgZG9uJ3Qgc2VuZCBpdCB0byB0aGUgZnJvbnRlbmQ7IHNob3dpbmcgYW4gZW1wdHkgY29tbWl0IGluIHRoZSBQcm9maWxlciBpcyBjb25mdXNpbmcuXG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YSAhPSBudWxsICYmXG4gICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YS5kdXJhdGlvbnMubGVuZ3RoID4gMFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGNvbW1pdFByb2ZpbGluZ01ldGFkYXRhID0gKChyb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcDogYW55KTogQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXApLmdldChcbiAgICAgICAgICBjdXJyZW50Um9vdElELFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChjb21taXRQcm9maWxpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0UHJvZmlsaW5nTWV0YWRhdGEucHVzaChcbiAgICAgICAgICAgICgoY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhOiBhbnkpOiBDb21taXRQcm9maWxpbmdEYXRhKSxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgocm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXA6IGFueSk6IENvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwKS5zZXQoXG4gICAgICAgICAgICBjdXJyZW50Um9vdElELFxuICAgICAgICAgICAgWygoY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhOiBhbnkpOiBDb21taXRQcm9maWxpbmdEYXRhKV0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlJ3JlIGRvbmUgaGVyZS5cbiAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdCk7XG5cbiAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgaG9vay5lbWl0KCd0cmFjZVVwZGF0ZXMnLCB0cmFjZVVwZGF0ZXNGb3JOb2Rlcyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJvb3RJRCA9IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEFsbEN1cnJlbnRIb3N0RmliZXJzKGlkOiBudW1iZXIpOiAkUmVhZE9ubHlBcnJheTxGaWJlcj4ge1xuICAgIGNvbnN0IGZpYmVycyA9IFtdO1xuICAgIGNvbnN0IGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcbiAgICBpZiAoIWZpYmVyKSB7XG4gICAgICByZXR1cm4gZmliZXJzO1xuICAgIH1cblxuICAgIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIGFsbCBIb3N0Q29tcG9uZW50L1RleHQuXG4gICAgbGV0IG5vZGU6IEZpYmVyID0gZmliZXI7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgZmliZXJzLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpYmVycztcbiAgICAgIH1cbiAgICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpYmVycztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gICAgcmV0dXJuIGZpYmVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmROYXRpdmVOb2Rlc0ZvckZpYmVySUQoaWQ6IG51bWJlcikge1xuICAgIHRyeSB7XG4gICAgICBsZXQgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuICAgICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHRpbWVkLW91dCBTdXNwZW5zZS5cbiAgICAgIGNvbnN0IGlzVGltZWRPdXRTdXNwZW5zZSA9XG4gICAgICAgIGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgICAgLy8gQSB0aW1lZC1vdXQgU3VzcGVuc2UncyBmaW5kRE9NTm9kZSBpcyB1c2VsZXNzLlxuICAgICAgICAvLyBUcnkgb3VyIGJlc3QgdG8gZmluZCB0aGUgZmFsbGJhY2sgZGlyZWN0bHkuXG4gICAgICAgIGNvbnN0IG1heWJlRmFsbGJhY2tGaWJlciA9IGZpYmVyLmNoaWxkICYmIGZpYmVyLmNoaWxkLnNpYmxpbmc7XG4gICAgICAgIGlmIChtYXliZUZhbGxiYWNrRmliZXIgIT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyID0gbWF5YmVGYWxsYmFja0ZpYmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBob3N0RmliZXJzID0gZmluZEFsbEN1cnJlbnRIb3N0RmliZXJzKGlkKTtcbiAgICAgIHJldHVybiBob3N0RmliZXJzLm1hcChob3N0RmliZXIgPT4gaG9zdEZpYmVyLnN0YXRlTm9kZSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gVGhlIGZpYmVyIG1pZ2h0IGhhdmUgdW5tb3VudGVkIGJ5IG5vdy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yRmliZXJJRChpZCkge1xuICAgIGNvbnN0IGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG4gICAgcmV0dXJuIGZpYmVyICE9IG51bGwgPyBnZXREaXNwbGF5TmFtZUZvckZpYmVyKCgoZmliZXI6IGFueSk6IEZpYmVyKSkgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmliZXJJREZvck5hdGl2ZShcbiAgICBob3N0SW5zdGFuY2UsXG4gICAgZmluZE5lYXJlc3RVbmZpbHRlcmVkQW5jZXN0b3IgPSBmYWxzZSxcbiAgKSB7XG4gICAgbGV0IGZpYmVyID0gcmVuZGVyZXIuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaG9zdEluc3RhbmNlKTtcbiAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKGZpbmROZWFyZXN0VW5maWx0ZXJlZEFuY2VzdG9yKSB7XG4gICAgICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCAmJiBzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikpIHtcbiAgICAgICAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZpYmVySURUaHJvd3MoKChmaWJlcjogYW55KTogRmliZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBmcm9tIFJlYWN0IGFuZCBzaG91bGQgYmUga2VwdCBpbiBzeW5jOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJUcmVlUmVmbGVjdGlvbi5qc1xuICBmdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgICBpZiAoZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgIT09IGZpYmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBmcm9tIFJlYWN0IGFuZCBzaG91bGQgYmUga2VwdCBpbiBzeW5jOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJUcmVlUmVmbGVjdGlvbi5qc1xuICBmdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyOiBGaWJlcik6IG51bGwgfCBGaWJlciB7XG4gICAgbGV0IG5vZGUgPSBmaWJlcjtcbiAgICBsZXQgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcbiAgICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgICBsZXQgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgZG8ge1xuICAgICAgICBub2RlID0gbmV4dE5vZGU7XG4gICAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgICAvLyBtb3VudGVkIGZpYmVyIGlzIHRoZSBwYXJlbnQgYnV0IHdlIG5lZWQgdG8gY29udGludWUgdG8gZmlndXJlIG91dFxuICAgICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Tm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfSB3aGlsZSAobmV4dE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAobm9kZS5yZXR1cm4pIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgICByZXR1cm4gbmVhcmVzdE1vdW50ZWQ7XG4gICAgfVxuICAgIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAgIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjb3BpZWQgZnJvbSBSZWFjdCBhbmQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYzpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFpbi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyVHJlZVJlZmxlY3Rpb24uanNcbiAgLy8gSXQgd291bGQgYmUgbmljZSBpZiB3ZSB1cGRhdGVkIFJlYWN0IHRvIGluamVjdCB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5ICh2cyBqdXN0IGluZGlyZWN0bHkgdmlhIGZpbmRET01Ob2RlKS5cbiAgLy8gQkVHSU4gY29waWVkIGNvZGVcbiAgZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkOiBudW1iZXIpOiBGaWJlciB8IG51bGwge1xuICAgIGNvbnN0IGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG4gICAgaWYgKGZpYmVyID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgRmliZXIgd2l0aCBpZCBcIiR7aWR9XCJgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICBpZiAoIWFsdGVybmF0ZSkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgICAgY29uc3QgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcblxuICAgICAgaWYgKG5lYXJlc3RNb3VudGVkID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVhcmVzdE1vdW50ZWQgIT09IGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpYmVyO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cbiAgICBsZXQgYTogRmliZXIgPSBmaWJlcjtcbiAgICBsZXQgYjogRmliZXIgPSBhbHRlcm5hdGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHBhcmVudEEgPSBhLnJldHVybjtcbiAgICAgIGlmIChwYXJlbnRBID09PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcbiAgICAgIGlmIChwYXJlbnRCID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuICAgICAgICAvLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG4gICAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG5leHRQYXJlbnQgPSBwYXJlbnRBLnJldHVybjtcbiAgICAgICAgaWYgKG5leHRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cbiAgICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIHtcbiAgICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgICBsZXQgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgICBjaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyAnICtcbiAgICAgICAgICAgICAgICAnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBcIiArXG4gICAgICAgICAgICAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gICAgLy8gdW5tb3VudGVkLlxuICAgIGlmIChhLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICB9XG5cbiAgLy8gRU5EIGNvcGllZCBjb2RlXG5cbiAgZnVuY3Rpb24gcHJlcGFyZVZpZXdBdHRyaWJ1dGVTb3VyY2UoXG4gICAgaWQ6IG51bWJlcixcbiAgICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICApOiB2b2lkIHtcbiAgICBpZiAoaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSkge1xuICAgICAgd2luZG93LiRhdHRyaWJ1dGUgPSBnZXRJbk9iamVjdChcbiAgICAgICAgKChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50OiBhbnkpOiBJbnNwZWN0ZWRFbGVtZW50KSxcbiAgICAgICAgcGF0aCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVZpZXdFbGVtZW50U291cmNlKGlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuICAgIGlmIChmaWJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIEZpYmVyIHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge2VsZW1lbnRUeXBlLCB0YWcsIHR5cGV9ID0gZmliZXI7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgZ2xvYmFsLiR0eXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGdsb2JhbC4kdHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgZ2xvYmFsLiR0eXBlID1cbiAgICAgICAgICBlbGVtZW50VHlwZSAhPSBudWxsICYmIGVsZW1lbnRUeXBlLnR5cGUgIT0gbnVsbFxuICAgICAgICAgICAgPyBlbGVtZW50VHlwZS50eXBlXG4gICAgICAgICAgICA6IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZ2xvYmFsLiR0eXBlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmliZXJUb1NlcmlhbGl6ZWRFbGVtZW50KGZpYmVyOiBGaWJlcik6IFNlcmlhbGl6ZWRFbGVtZW50IHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheU5hbWU6IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdBbm9ueW1vdXMnLFxuICAgICAgaWQ6IGdldEZpYmVySURUaHJvd3MoZmliZXIpLFxuICAgICAga2V5OiBmaWJlci5rZXksXG4gICAgICB0eXBlOiBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKSxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3duZXJzTGlzdChpZDogbnVtYmVyKTogQXJyYXk8U2VyaWFsaXplZEVsZW1lbnQ+IHwgbnVsbCB7XG4gICAgY29uc3QgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuICAgIGlmIChmaWJlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7X2RlYnVnT3duZXJ9ID0gZmliZXI7XG5cbiAgICBjb25zdCBvd25lcnM6IEFycmF5PFNlcmlhbGl6ZWRFbGVtZW50PiA9IFtmaWJlclRvU2VyaWFsaXplZEVsZW1lbnQoZmliZXIpXTtcblxuICAgIGlmIChfZGVidWdPd25lcikge1xuICAgICAgbGV0IG93bmVyID0gX2RlYnVnT3duZXI7XG4gICAgICB3aGlsZSAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgb3duZXJzLnVuc2hpZnQoZmliZXJUb1NlcmlhbGl6ZWRFbGVtZW50KG93bmVyKSk7XG4gICAgICAgIG93bmVyID0gb3duZXIuX2RlYnVnT3duZXIgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3duZXJzO1xuICB9XG5cbiAgLy8gRmFzdCBwYXRoIHByb3BzIGxvb2t1cCBmb3IgUmVhY3QgTmF0aXZlIHN0eWxlIGVkaXRvci5cbiAgLy8gQ291bGQgdXNlIGluc3BlY3RFbGVtZW50UmF3KCkgYnV0IHRoYXQgd291bGQgcmVxdWlyZSBzaGFsbG93IHJlbmRlcmluZyBob29rcyBjb21wb25lbnRzLFxuICAvLyBhbmQgY291bGQgYWxzbyBtZXNzIHdpdGggbWVtb2l6YXRpb24uXG4gIGZ1bmN0aW9uIGdldEluc3RhbmNlQW5kU3R5bGUoaWQ6IG51bWJlcik6IEluc3RhbmNlQW5kU3R5bGUge1xuICAgIGxldCBpbnN0YW5jZSA9IG51bGw7XG4gICAgbGV0IHN0eWxlID0gbnVsbDtcblxuICAgIGNvbnN0IGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcbiAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoZmliZXIubWVtb2l6ZWRQcm9wcyAhPT0gbnVsbCkge1xuICAgICAgICBzdHlsZSA9IGZpYmVyLm1lbW9pemVkUHJvcHMuc3R5bGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtpbnN0YW5jZSwgc3R5bGV9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFcnJvckJvdW5kYXJ5KGZpYmVyOiBGaWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHt0YWcsIHR5cGV9ID0gZmliZXI7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAoaW5zdGFuY2UgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZWFyZXN0RXJyb3JCb3VuZGFyeUlEKGZpYmVyOiBGaWJlcik6IG51bWJlciB8IG51bGwge1xuICAgIGxldCBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzRXJyb3JCb3VuZGFyeShwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBnZXRGaWJlcklEVW5zYWZlKHBhcmVudCk7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50UmF3KGlkOiBudW1iZXIpOiBJbnNwZWN0ZWRFbGVtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuICAgIGlmIChmaWJlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBfZGVidWdPd25lcixcbiAgICAgIF9kZWJ1Z1NvdXJjZSxcbiAgICAgIHN0YXRlTm9kZSxcbiAgICAgIGtleSxcbiAgICAgIG1lbW9pemVkUHJvcHMsXG4gICAgICBtZW1vaXplZFN0YXRlLFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgdGFnLFxuICAgICAgdHlwZSxcbiAgICB9ID0gZmliZXI7XG5cbiAgICBjb25zdCBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpO1xuXG4gICAgY29uc3QgdXNlc0hvb2tzID1cbiAgICAgICh0YWcgPT09IEZ1bmN0aW9uQ29tcG9uZW50IHx8XG4gICAgICAgIHRhZyA9PT0gU2ltcGxlTWVtb0NvbXBvbmVudCB8fFxuICAgICAgICB0YWcgPT09IEZvcndhcmRSZWYpICYmXG4gICAgICAoISFtZW1vaXplZFN0YXRlIHx8ICEhZGVwZW5kZW5jaWVzKTtcblxuICAgIC8vIFRPRE8gU2hvdyBjdXN0b20gVUkgZm9yIENhY2hlIGxpa2Ugd2UgZG8gZm9yIFN1c3BlbnNlXG4gICAgLy8gRm9yIG5vdywganVzdCBoaWRlIHN0YXRlIGRhdGEgZW50aXJlbHkgc2luY2UgaXQncyBub3QgbWVhbnQgdG8gYmUgaW5zcGVjdGVkLlxuICAgIGNvbnN0IHNob3dTdGF0ZSA9ICF1c2VzSG9va3MgJiYgdGFnICE9PSBDYWNoZUNvbXBvbmVudDtcblxuICAgIGNvbnN0IHR5cGVTeW1ib2wgPSBnZXRUeXBlU3ltYm9sKHR5cGUpO1xuXG4gICAgbGV0IGNhblZpZXdTb3VyY2UgPSBmYWxzZTtcbiAgICBsZXQgY29udGV4dCA9IG51bGw7XG4gICAgaWYgKFxuICAgICAgdGFnID09PSBDbGFzc0NvbXBvbmVudCB8fFxuICAgICAgdGFnID09PSBGdW5jdGlvbkNvbXBvbmVudCB8fFxuICAgICAgdGFnID09PSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgfHxcbiAgICAgIHRhZyA9PT0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCB8fFxuICAgICAgdGFnID09PSBNZW1vQ29tcG9uZW50IHx8XG4gICAgICB0YWcgPT09IEZvcndhcmRSZWYgfHxcbiAgICAgIHRhZyA9PT0gU2ltcGxlTWVtb0NvbXBvbmVudFxuICAgICkge1xuICAgICAgY2FuVmlld1NvdXJjZSA9IHRydWU7XG4gICAgICBpZiAoc3RhdGVOb2RlICYmIHN0YXRlTm9kZS5jb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc2hvdyBhbiBlbXB0eSBjb250ZXh0IG9iamVjdCBmb3IgY2xhc3MgY29tcG9uZW50cyB0aGF0IGRvbid0IHVzZSB0aGUgY29udGV4dCBBUEkuXG4gICAgICAgIGNvbnN0IHNob3VsZEhpZGVDb250ZXh0ID1cbiAgICAgICAgICBlbGVtZW50VHlwZSA9PT0gRWxlbWVudFR5cGVDbGFzcyAmJlxuICAgICAgICAgICEodHlwZS5jb250ZXh0VHlwZXMgfHwgdHlwZS5jb250ZXh0VHlwZSk7XG5cbiAgICAgICAgaWYgKCFzaG91bGRIaWRlQ29udGV4dCkge1xuICAgICAgICAgIGNvbnRleHQgPSBzdGF0ZU5vZGUuY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlU3ltYm9sID09PSBDT05URVhUX05VTUJFUiB8fFxuICAgICAgdHlwZVN5bWJvbCA9PT0gQ09OVEVYVF9TWU1CT0xfU1RSSU5HXG4gICAgKSB7XG4gICAgICAvLyAxNi4zLTE2LjUgcmVhZCBmcm9tIFwidHlwZVwiIGJlY2F1c2UgdGhlIENvbnN1bWVyIGlzIHRoZSBhY3R1YWwgY29udGV4dCBvYmplY3QuXG4gICAgICAvLyAxNi42KyBzaG91bGQgcmVhZCBmcm9tIFwidHlwZS5fY29udGV4dFwiIGJlY2F1c2UgQ29uc3VtZXIgY2FuIGJlIGRpZmZlcmVudCAoaW4gREVWKS5cbiAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggZ2V0RGlzcGxheU5hbWVGb3JGaWJlcigpXG4gICAgICBjb25zdCBjb25zdW1lclJlc29sdmVkQ29udGV4dCA9IHR5cGUuX2NvbnRleHQgfHwgdHlwZTtcblxuICAgICAgLy8gR2xvYmFsIGNvbnRleHQgdmFsdWUuXG4gICAgICBjb250ZXh0ID0gY29uc3VtZXJSZXNvbHZlZENvbnRleHQuX2N1cnJlbnRWYWx1ZSB8fCBudWxsO1xuXG4gICAgICAvLyBMb29rIGZvciBvdmVycmlkZGVuIHZhbHVlLlxuICAgICAgbGV0IGN1cnJlbnQgPSAoKGZpYmVyOiBhbnkpOiBGaWJlcikucmV0dXJuO1xuICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUeXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbChjdXJyZW50VHlwZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJyZW50VHlwZVN5bWJvbCA9PT0gUFJPVklERVJfTlVNQkVSIHx8XG4gICAgICAgICAgY3VycmVudFR5cGVTeW1ib2wgPT09IFBST1ZJREVSX1NZTUJPTF9TVFJJTkdcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gMTYuMy4wIGV4cG9zZWQgdGhlIGNvbnRleHQgb2JqZWN0IGFzIFwiY29udGV4dFwiXG4gICAgICAgICAgLy8gUFIgIzEyNTAxIGNoYW5nZWQgaXQgdG8gXCJfY29udGV4dFwiIGZvciAxNi4zLjErXG4gICAgICAgICAgLy8gTk9URSBLZWVwIGluIHN5bmMgd2l0aCBnZXREaXNwbGF5TmFtZUZvckZpYmVyKClcbiAgICAgICAgICBjb25zdCBwcm92aWRlclJlc29sdmVkQ29udGV4dCA9XG4gICAgICAgICAgICBjdXJyZW50VHlwZS5fY29udGV4dCB8fCBjdXJyZW50VHlwZS5jb250ZXh0O1xuICAgICAgICAgIGlmIChwcm92aWRlclJlc29sdmVkQ29udGV4dCA9PT0gY29uc3VtZXJSZXNvbHZlZENvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMudmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGhhc0xlZ2FjeUNvbnRleHQgPSBmYWxzZTtcbiAgICBpZiAoY29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgaGFzTGVnYWN5Q29udGV4dCA9ICEhdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICAgIC8vIFRvIHNpbXBsaWZ5IGh5ZHJhdGlvbiBhbmQgZGlzcGxheSBsb2dpYyBmb3IgY29udGV4dCwgd3JhcCBpbiBhIHZhbHVlIG9iamVjdC5cbiAgICAgIC8vIE90aGVyd2lzZSBzaW1wbGUgdmFsdWVzIChlLmcuIHN0cmluZ3MsIGJvb2xlYW5zKSBiZWNvbWUgaGFyZGVyIHRvIGhhbmRsZS5cbiAgICAgIGNvbnRleHQgPSB7dmFsdWU6IGNvbnRleHR9O1xuICAgIH1cblxuICAgIGxldCBvd25lcnMgPSBudWxsO1xuICAgIGlmIChfZGVidWdPd25lcikge1xuICAgICAgb3duZXJzID0gW107XG4gICAgICBsZXQgb3duZXIgPSBfZGVidWdPd25lcjtcbiAgICAgIHdoaWxlIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICBvd25lcnMucHVzaChmaWJlclRvU2VyaWFsaXplZEVsZW1lbnQob3duZXIpKTtcbiAgICAgICAgb3duZXIgPSBvd25lci5fZGVidWdPd25lciB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzVGltZWRPdXRTdXNwZW5zZSA9XG4gICAgICB0YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIG1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICBsZXQgaG9va3MgPSBudWxsO1xuICAgIGlmICh1c2VzSG9va3MpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ29uc29sZU1ldGhvZHMgPSB7fTtcblxuICAgICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZSBhbGwgY29uc29sZSBsb2dnaW5nIGJlZm9yZSByZS1ydW5uaW5nIHRoZSBob29rLlxuICAgICAgZm9yIChjb25zdCBtZXRob2QgaW4gY29uc29sZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXSA9IGNvbnNvbGVbbWV0aG9kXTtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIHByb3BlcnR5IGVycm9yfHdhcm4gaXMgbm90IHdyaXRhYmxlLlxuICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9ICgpID0+IHt9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaG9va3MgPSBpbnNwZWN0SG9va3NPZkZpYmVyKFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIChyZW5kZXJlci5jdXJyZW50RGlzcGF0Y2hlclJlZjogYW55KSxcbiAgICAgICAgICB0cnVlLCAvLyBJbmNsdWRlIHNvdXJjZSBsb2NhdGlvbiBpbmZvIGZvciBob29rc1xuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb25zb2xlIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgIGZvciAoY29uc3QgbWV0aG9kIGluIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBwcm9wZXJ0eSBlcnJvcnx3YXJuIGlzIG5vdCB3cml0YWJsZS5cbiAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCByb290VHlwZSA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnQgPSBmaWJlcjtcbiAgICB3aGlsZSAoY3VycmVudC5yZXR1cm4gIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmliZXJSb290ID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgaWYgKGZpYmVyUm9vdCAhPSBudWxsICYmIGZpYmVyUm9vdC5fZGVidWdSb290VHlwZSAhPT0gbnVsbCkge1xuICAgICAgcm9vdFR5cGUgPSBmaWJlclJvb3QuX2RlYnVnUm9vdFR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JzID0gZmliZXJJRFRvRXJyb3JzTWFwLmdldChpZCkgfHwgbmV3IE1hcCgpO1xuICAgIGNvbnN0IHdhcm5pbmdzID0gZmliZXJJRFRvV2FybmluZ3NNYXAuZ2V0KGlkKSB8fCBuZXcgTWFwKCk7XG5cbiAgICBjb25zdCBpc0Vycm9yZWQgPVxuICAgICAgKGZpYmVyLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MgfHxcbiAgICAgIGZvcmNlRXJyb3JGb3JGaWJlcklEcy5nZXQoaWQpID09PSB0cnVlO1xuXG4gICAgbGV0IHRhcmdldEVycm9yQm91bmRhcnlJRDtcbiAgICBpZiAoaXNFcnJvckJvdW5kYXJ5KGZpYmVyKSkge1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgaW5zcGVjdGVkIGVsZW1lbnQgaXMgYW4gZXJyb3IgYm91bmRhcnksXG4gICAgICAvLyBlaXRoZXIgdGhhdCB3ZSB3YW50IHRvIHVzZSBpdCB0byB0b2dnbGUgb2ZmIGVycm9yIHN0YXRlXG4gICAgICAvLyBvciB0aGF0IHdlIGFsbG93IHRvIGZvcmNlIGVycm9yIHN0YXRlIG9uIGl0IGlmIGl0J3Mgd2l0aGluIGFub3RoZXJcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5XG4gICAgICB0YXJnZXRFcnJvckJvdW5kYXJ5SUQgPSBpc0Vycm9yZWQgPyBpZCA6IGdldE5lYXJlc3RFcnJvckJvdW5kYXJ5SUQoZmliZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRFcnJvckJvdW5kYXJ5SUQgPSBnZXROZWFyZXN0RXJyb3JCb3VuZGFyeUlEKGZpYmVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBwbHVnaW5zOiBQbHVnaW5zID0ge1xuICAgICAgc3R5bGV4OiBudWxsLFxuICAgIH07XG5cbiAgICBpZiAoZW5hYmxlU3R5bGVYRmVhdHVyZXMpIHtcbiAgICAgIGlmIChtZW1vaXplZFByb3BzLmhhc093blByb3BlcnR5KCd4c3R5bGUnKSkge1xuICAgICAgICBwbHVnaW5zLnN0eWxleCA9IGdldFN0eWxlWERhdGEobWVtb2l6ZWRQcm9wcy54c3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpZCxcblxuICAgICAgLy8gRG9lcyB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0IGVkaXRhYmxlIGhvb2tzIGFuZCBmdW5jdGlvbiBwcm9wcz9cbiAgICAgIGNhbkVkaXRIb29rczogdHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHM6IHR5cGVvZiBvdmVycmlkZVByb3BzID09PSAnZnVuY3Rpb24nLFxuXG4gICAgICAvLyBEb2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnQgYWR2YW5jZWQgZWRpdGluZyBpbnRlcmZhY2U/XG4gICAgICBjYW5FZGl0SG9va3NBbmREZWxldGVQYXRoczpcbiAgICAgICAgdHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGNhbkVkaXRIb29rc0FuZFJlbmFtZVBhdGhzOlxuICAgICAgICB0eXBlb2Ygb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNEZWxldGVQYXRoczpcbiAgICAgICAgdHlwZW9mIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNSZW5hbWVQYXRoczpcbiAgICAgICAgdHlwZW9mIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nLFxuXG4gICAgICBjYW5Ub2dnbGVFcnJvcjogc3VwcG9ydHNUb2dnbGluZ0Vycm9yICYmIHRhcmdldEVycm9yQm91bmRhcnlJRCAhPSBudWxsLFxuICAgICAgLy8gSXMgdGhpcyBlcnJvciBib3VuZGFyeSBpbiBlcnJvciBzdGF0ZS5cbiAgICAgIGlzRXJyb3JlZCxcbiAgICAgIHRhcmdldEVycm9yQm91bmRhcnlJRCxcblxuICAgICAgY2FuVG9nZ2xlU3VzcGVuc2U6XG4gICAgICAgIHN1cHBvcnRzVG9nZ2xpbmdTdXNwZW5zZSAmJlxuICAgICAgICAvLyBJZiBpdCdzIHNob3dpbmcgdGhlIHJlYWwgY29udGVudCwgd2UgY2FuIGFsd2F5cyBmbGlwIGZhbGxiYWNrLlxuICAgICAgICAoIWlzVGltZWRPdXRTdXNwZW5zZSB8fFxuICAgICAgICAgIC8vIElmIGl0J3Mgc2hvd2luZyBmYWxsYmFjayBiZWNhdXNlIHdlIHByZXZpb3VzbHkgZm9yY2VkIGl0IHRvLFxuICAgICAgICAgIC8vIGFsbG93IHRvZ2dsaW5nIGl0IGJhY2sgdG8gcmVtb3ZlIHRoZSBmYWxsYmFjayBvdmVycmlkZS5cbiAgICAgICAgICBmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMuaGFzKGlkKSksXG5cbiAgICAgIC8vIENhbiB2aWV3IGNvbXBvbmVudCBzb3VyY2UgbG9jYXRpb24uXG4gICAgICBjYW5WaWV3U291cmNlLFxuXG4gICAgICAvLyBEb2VzIHRoZSBjb21wb25lbnQgaGF2ZSBsZWdhY3kgY29udGV4dCBhdHRhY2hlZCB0byBpdC5cbiAgICAgIGhhc0xlZ2FjeUNvbnRleHQsXG5cbiAgICAgIGtleToga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsLFxuXG4gICAgICBkaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlciksXG4gICAgICB0eXBlOiBlbGVtZW50VHlwZSxcblxuICAgICAgLy8gSW5zcGVjdGFibGUgcHJvcGVydGllcy5cbiAgICAgIC8vIFRPRE8gUmV2aWV3IHNhbml0aXphdGlvbiBhcHByb2FjaCBmb3IgdGhlIGJlbG93IGluc3BlY3RhYmxlIHZhbHVlcy5cbiAgICAgIGNvbnRleHQsXG4gICAgICBob29rcyxcbiAgICAgIHByb3BzOiBtZW1vaXplZFByb3BzLFxuICAgICAgc3RhdGU6IHNob3dTdGF0ZSA/IG1lbW9pemVkU3RhdGUgOiBudWxsLFxuICAgICAgZXJyb3JzOiBBcnJheS5mcm9tKGVycm9ycy5lbnRyaWVzKCkpLFxuICAgICAgd2FybmluZ3M6IEFycmF5LmZyb20od2FybmluZ3MuZW50cmllcygpKSxcblxuICAgICAgLy8gTGlzdCBvZiBvd25lcnNcbiAgICAgIG93bmVycyxcblxuICAgICAgLy8gTG9jYXRpb24gb2YgY29tcG9uZW50IGluIHNvdXJjZSBjb2RlLlxuICAgICAgc291cmNlOiBfZGVidWdTb3VyY2UgfHwgbnVsbCxcblxuICAgICAgcm9vdFR5cGUsXG4gICAgICByZW5kZXJlclBhY2thZ2VOYW1lOiByZW5kZXJlci5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgICAgcmVuZGVyZXJWZXJzaW9uOiByZW5kZXJlci52ZXJzaW9uLFxuXG4gICAgICBwbHVnaW5zLFxuICAgIH07XG4gIH1cblxuICBsZXQgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudDogSW5zcGVjdGVkRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBsZXQgaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgbGV0IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzOiBPYmplY3QgPSB7fTtcblxuICBmdW5jdGlvbiBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsICYmXG4gICAgICBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50LmlkID09PSBpZFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRDdXJyZW50KGlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSAmJiAhaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWRcbiAgICApO1xuICB9XG5cbiAgLy8gVHJhY2sgdGhlIGludGVyc2VjdGlvbiBvZiBjdXJyZW50bHkgaW5zcGVjdGVkIHBhdGhzLFxuICAvLyBzbyB0aGF0IHdlIGNhbiBzZW5kIHRoZWlyIGRhdGEgYWxvbmcgaWYgdGhlIGVsZW1lbnQgaXMgcmUtcmVuZGVyZWQuXG4gIGZ1bmN0aW9uIG1lcmdlSW5zcGVjdGVkUGF0aHMocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikge1xuICAgIGxldCBjdXJyZW50ID0gY3VycmVudGx5SW5zcGVjdGVkUGF0aHM7XG4gICAgcGF0aC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRba2V5XSkge1xuICAgICAgICBjdXJyZW50W2tleV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2tleV07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJc1BhdGhBbGxvd2VkKFxuICAgIGtleTogc3RyaW5nIHwgbnVsbCxcbiAgICBzZWNvbmRhcnlDYXRlZ29yeTogJ2hvb2tzJyB8IG51bGwsXG4gICkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGVscHMgcHJldmVudCBwcmV2aW91c2x5LWluc3BlY3RlZCBwYXRocyBmcm9tIGJlaW5nIGRlaHlkcmF0ZWQgaW4gdXBkYXRlcy5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCB0byBhdm9pZCBhIGJhZCB1c2VyIGV4cGVyaWVuY2Ugd2hlcmUgZXhwYW5kZWQgdG9nZ2xlcyBjb2xsYXBzZSBvbiB1cGRhdGUuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzUGF0aEFsbG93ZWQocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgc3dpdGNoIChzZWNvbmRhcnlDYXRlZ29yeSkge1xuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBOZXZlciBkZWh5ZHJhdGUgdGhlIFwiaG9va3NcIiBvYmplY3QgYXQgdGhlIHRvcCBsZXZlbHMuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMl0gPT09ICdob29rU291cmNlJyAmJlxuICAgICAgICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnZmlsZU5hbWUnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBwcmVzZXJ2ZSB0aGUgZnVsbCBmaWxlIG5hbWUgKFVSTCkgZm9yIGhvb2sgc291cmNlc1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgdXNlciBoYXMgZW5hYmxlZCB0aGUgbmFtZWQgaG9va3MgZmVhdHVyZS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgZnJvbnRlbmQgbWF5IGVuZCB1cCB3aXRoIGEgcGFydGlhbCBVUkwgd2hpY2ggaXQgY2FuJ3QgbG9hZC5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ3N1Ykhvb2tzJyB8fFxuICAgICAgICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDJdID09PSAnc3ViSG9va3MnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBEZWh5ZHJhdGluZyB0aGUgJ3N1Ykhvb2tzJyBwcm9wZXJ0eSBtYWtlcyB0aGUgSG9va3NUcmVlIFVJIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQsXG4gICAgICAgICAgICAvLyBzbyBpdCdzIGVhc2llc3QgZm9yIG5vdyBpZiB3ZSBqdXN0IGRvbid0IGJyZWFrIG9uIHRoaXMgYm91bmRhcnkuXG4gICAgICAgICAgICAvLyBXZSBjYW4gYWx3YXlzIGRlaHlkcmF0ZSBhIGxldmVsIGRlZXBlciAoaW4gdGhlIHZhbHVlIG9iamVjdCkuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxldCBjdXJyZW50ID1cbiAgICAgICAga2V5ID09PSBudWxsID8gY3VycmVudGx5SW5zcGVjdGVkUGF0aHMgOiBjdXJyZW50bHlJbnNwZWN0ZWRQYXRoc1trZXldO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoW2ldXTtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0ZWRFbGVtZW50KGluc3BlY3RlZEVsZW1lbnQ6IEluc3BlY3RlZEVsZW1lbnQpOiB2b2lkIHtcbiAgICBjb25zdCB7aG9va3MsIGlkLCBwcm9wc30gPSBpbnNwZWN0ZWRFbGVtZW50O1xuXG4gICAgY29uc3QgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGlkKTtcbiAgICBpZiAoZmliZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBGaWJlciB3aXRoIGlkIFwiJHtpZH1cImApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtlbGVtZW50VHlwZSwgc3RhdGVOb2RlLCB0YWcsIHR5cGV9ID0gZmliZXI7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHIgPSBzdGF0ZU5vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgZ2xvYmFsLiRyID0ge1xuICAgICAgICAgIGhvb2tzLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBnbG9iYWwuJHIgPSB7XG4gICAgICAgICAgaG9va3MsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgdHlwZTogdHlwZS5yZW5kZXIsXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHIgPSB7XG4gICAgICAgICAgaG9va3MsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgdHlwZTpcbiAgICAgICAgICAgIGVsZW1lbnRUeXBlICE9IG51bGwgJiYgZWxlbWVudFR5cGUudHlwZSAhPSBudWxsXG4gICAgICAgICAgICAgID8gZWxlbWVudFR5cGUudHlwZVxuICAgICAgICAgICAgICA6IHR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZ2xvYmFsLiRyID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcmVBc0dsb2JhbChcbiAgICBpZDogbnVtYmVyLFxuICAgIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gICAgY291bnQ6IG51bWJlcixcbiAgKTogdm9pZCB7XG4gICAgaWYgKGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudChpZCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0SW5PYmplY3QoXG4gICAgICAgICgobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudDogYW55KTogSW5zcGVjdGVkRWxlbWVudCksXG4gICAgICAgIHBhdGgsXG4gICAgICApO1xuICAgICAgY29uc3Qga2V5ID0gYCRyZWFjdFRlbXAke2NvdW50fWA7XG5cbiAgICAgIHdpbmRvd1trZXldID0gdmFsdWU7XG5cbiAgICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29weUVsZW1lbnRQYXRoKGlkOiBudW1iZXIsIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4pOiB2b2lkIHtcbiAgICBpZiAoaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSkge1xuICAgICAgY29weVRvQ2xpcGJvYXJkKFxuICAgICAgICBnZXRJbk9iamVjdChcbiAgICAgICAgICAoKG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQ6IGFueSk6IEluc3BlY3RlZEVsZW1lbnQpLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50KFxuICAgIHJlcXVlc3RJRDogbnVtYmVyLFxuICAgIGlkOiBudW1iZXIsXG4gICAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiB8IG51bGwsXG4gICAgZm9yY2VGdWxsRGF0YTogYm9vbGVhbixcbiAgKTogSW5zcGVjdGVkRWxlbWVudFBheWxvYWQge1xuICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICBtZXJnZUluc3BlY3RlZFBhdGhzKHBhdGgpO1xuICAgIH1cblxuICAgIGlmIChpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpICYmICFmb3JjZUZ1bGxEYXRhKSB7XG4gICAgICBpZiAoIWhhc0VsZW1lbnRVcGRhdGVkU2luY2VMYXN0SW5zcGVjdGVkKSB7XG4gICAgICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgbGV0IHNlY29uZGFyeUNhdGVnb3J5ID0gbnVsbDtcbiAgICAgICAgICBpZiAocGF0aFswXSA9PT0gJ2hvb2tzJykge1xuICAgICAgICAgICAgc2Vjb25kYXJ5Q2F0ZWdvcnkgPSAnaG9va3MnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBoYXMgbm90IGJlZW4gdXBkYXRlZCBzaW5jZSBpdCB3YXMgbGFzdCBpbnNwZWN0ZWQsXG4gICAgICAgICAgLy8gd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBzdWJzZXQgb2YgZGF0YSBpbiB0aGUgbmV3bHktaW5zcGVjdGVkIHBhdGguXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICAgICAgdHlwZTogJ2h5ZHJhdGVkLXBhdGgnLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiBjbGVhbkZvckJyaWRnZShcbiAgICAgICAgICAgICAgZ2V0SW5PYmplY3QoXG4gICAgICAgICAgICAgICAgKChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50OiBhbnkpOiBJbnNwZWN0ZWRFbGVtZW50KSxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjcmVhdGVJc1BhdGhBbGxvd2VkKG51bGwsIHNlY29uZGFyeUNhdGVnb3J5KSxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaGFzIG5vdCBiZWVuIHVwZGF0ZWQgc2luY2UgaXQgd2FzIGxhc3QgaW5zcGVjdGVkLCB3ZSBkb24ndCBuZWVkIHRvIHJldHVybiBpdC5cbiAgICAgICAgICAvLyBJbnN0ZWFkIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgSUQgdG8gaW5kaWNhdGUgdGhhdCBpdCBoYXMgbm90IGNoYW5nZWQuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICAgICAgdHlwZTogJ25vLWNoYW5nZScsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA9IHt9O1xuICAgIH1cblxuICAgIGhhc0VsZW1lbnRVcGRhdGVkU2luY2VMYXN0SW5zcGVjdGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCA9IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5zcGVjdGluZyBlbGVtZW50LlxcblxcbicsIGVycm9yKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgaWQsXG4gICAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgICAgdHlwZTogJ25vdC1mb3VuZCcsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFueSB0aW1lIGFuIGluc3BlY3RlZCBlbGVtZW50IGhhcyBhbiB1cGRhdGUsXG4gICAgLy8gd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgJHIgdmFsdWUgYXMgd2VsLlxuICAgIC8vIERvIHRoaXMgYmVmb3JlIGRlaHlkcmF0aW9uIChjbGVhbkZvckJyaWRnZSkuXG4gICAgdXBkYXRlU2VsZWN0ZWRFbGVtZW50KG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQpO1xuXG4gICAgLy8gQ2xvbmUgYmVmb3JlIGNsZWFuaW5nIHNvIHRoYXQgd2UgcHJlc2VydmUgdGhlIGZ1bGwgZGF0YS5cbiAgICAvLyBUaGlzIHdpbGwgZW5hYmxlIHVzIHRvIHNlbmQgcGF0Y2hlcyB3aXRob3V0IHJlLWluc3BlY3RpbmcgaWYgaHlkcmF0ZWQgcGF0aHMgYXJlIHJlcXVlc3RlZC5cbiAgICAvLyAoUmVkdWNpbmcgaG93IG9mdGVuIHdlIHNoYWxsb3ctcmVuZGVyIGlzIGEgYmV0dGVyIERYIGZvciBmdW5jdGlvbiBjb21wb25lbnRzIHRoYXQgdXNlIGhvb2tzLilcbiAgICBjb25zdCBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudCA9IHsuLi5tb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50fTtcbiAgICBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5jb250ZXh0ID0gY2xlYW5Gb3JCcmlkZ2UoXG4gICAgICBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5jb250ZXh0LFxuICAgICAgY3JlYXRlSXNQYXRoQWxsb3dlZCgnY29udGV4dCcsIG51bGwpLFxuICAgICk7XG4gICAgY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuaG9va3MgPSBjbGVhbkZvckJyaWRnZShcbiAgICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50Lmhvb2tzLFxuICAgICAgY3JlYXRlSXNQYXRoQWxsb3dlZCgnaG9va3MnLCAnaG9va3MnKSxcbiAgICApO1xuICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LnByb3BzID0gY2xlYW5Gb3JCcmlkZ2UoXG4gICAgICBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5wcm9wcyxcbiAgICAgIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ3Byb3BzJywgbnVsbCksXG4gICAgKTtcbiAgICBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5zdGF0ZSA9IGNsZWFuRm9yQnJpZGdlKFxuICAgICAgY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuc3RhdGUsXG4gICAgICBjcmVhdGVJc1BhdGhBbGxvd2VkKCdzdGF0ZScsIG51bGwpLFxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICB0eXBlOiAnZnVsbC1kYXRhJyxcbiAgICAgIHZhbHVlOiBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudCxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nRWxlbWVudFRvQ29uc29sZShpZCkge1xuICAgIGZ1bmN0aW9uIGZpYmVyVG9Ob2RlKGZpYmVyKSB7XG4gICAgICBpZiAoZmliZXIudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpZCA9IGZpYmVyVG9TZXJpYWxpemVkRWxlbWVudChmaWJlcikuaWQ7XG4gICAgICBjb25zdCByYXdFbGVtZW50ID0gaW5zcGVjdEVsZW1lbnRSYXcoaWQpO1xuXG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICBpZDogaWQudG9TdHJpbmcoKSxcbiAgICAgICAgbmFtZTogcmF3RWxlbWVudC5kaXNwbGF5TmFtZSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChyYXdFbGVtZW50Lm93bmVycykge1xuICAgICAgICBub2RlLm93bmVyID0gcmF3RWxlbWVudC5vd25lcnNbMF0uaWQudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5jaGlsZHJlbiA9IFtdO1xuICAgICAgbGV0IGNoaWxkRmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZEZpYmVyKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IGZpYmVyVG9Ob2RlKGNoaWxkRmliZXIpO1xuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRGaWJlciA9IGNoaWxkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ2JhY2tlbmQgcmVuZGVyZXInKTtcbiAgICBjb25zdCByZXN1bHQgPSBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRDdXJyZW50KGlkKVxuICAgICAgPyBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50XG4gICAgICA6IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIEZpYmVyIHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdHJlZSA9IGZpYmVyVG9Ob2RlKGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoQnlJZChyZXN1bHQuaWQpKTtcbiAgICBjb25zb2xlLmxvZygnQ29weSB0aGlzOicsIHRyZWUpO1xuICAgIC8vIGNvbnN0IHN1cHBvcnRzR3JvdXAgPSB0eXBlb2YgY29uc29sZS5ncm91cENvbGxhcHNlZCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvLyBpZiAoc3VwcG9ydHNHcm91cCkge1xuICAgIC8vICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICAvLyAgICAgYFtDbGljayB0byBleHBhbmRdICVjPCR7cmVzdWx0LmRpc3BsYXlOYW1lIHx8ICdDb21wb25lbnQnfSAvPmAsXG4gICAgLy8gICAgIC8vIC0tZG9tLXRhZy1uYW1lLWNvbG9yIGlzIHRoZSBDU1MgdmFyaWFibGUgQ2hyb21lIHN0eWxlcyBIVE1MIGVsZW1lbnRzIHdpdGggaW4gdGhlIGNvbnNvbGUuXG4gICAgLy8gICAgICdjb2xvcjogdmFyKC0tZG9tLXRhZy1uYW1lLWNvbG9yKTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsnLFxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgLy8gaWYgKHJlc3VsdC5wcm9wcyAhPT0gbnVsbCkge1xuICAgIC8vICAgY29uc29sZS5sb2coJ1Byb3BzOicsIHJlc3VsdC5wcm9wcyk7XG4gICAgLy8gfVxuICAgIC8vIGlmIChyZXN1bHQuc3RhdGUgIT09IG51bGwpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKCdTdGF0ZTonLCByZXN1bHQuc3RhdGUpO1xuICAgIC8vIH1cbiAgICAvLyBpZiAocmVzdWx0Lmhvb2tzICE9PSBudWxsKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZygnSG9va3M6JywgcmVzdWx0Lmhvb2tzKTtcbiAgICAvLyB9XG4gICAgLy8gY29uc3QgbmF0aXZlTm9kZXMgPSBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEKGlkKTtcbiAgICAvLyBpZiAobmF0aXZlTm9kZXMgIT09IG51bGwpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKCdOb2RlczonLCBuYXRpdmVOb2Rlcyk7XG4gICAgLy8gfVxuICAgIC8vIGlmIChyZXN1bHQuc291cmNlICE9PSBudWxsKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZygnTG9jYXRpb246JywgcmVzdWx0LnNvdXJjZSk7XG4gICAgLy8gfVxuICAgIC8vIGlmICh3aW5kb3cuY2hyb21lIHx8IC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIC8vICAgY29uc29sZS5sb2coXG4gICAgLy8gICAgICdSaWdodC1jbGljayBhbnkgdmFsdWUgdG8gc2F2ZSBpdCBhcyBhIGdsb2JhbCB2YXJpYWJsZSBmb3IgZnVydGhlciBpbnNwZWN0aW9uLicsXG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICAvLyBpZiAoc3VwcG9ydHNHcm91cCkge1xuICAgIC8vICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIC8vIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVBhdGgoXG4gICAgdHlwZTogJ2NvbnRleHQnIHwgJ2hvb2tzJyB8ICdwcm9wcycgfCAnc3RhdGUnLFxuICAgIGlkOiBudW1iZXIsXG4gICAgaG9va0lEOiA/bnVtYmVyLFxuICAgIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcbiAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgLy8gVG8gc2ltcGxpZnkgaHlkcmF0aW9uIGFuZCBkaXNwbGF5IG9mIHByaW1pdGl2ZSBjb250ZXh0IHZhbHVlcyAoZS5nLiBudW1iZXIsIHN0cmluZylcbiAgICAgICAgICAvLyB0aGUgaW5zcGVjdEVsZW1lbnQoKSBtZXRob2Qgd3JhcHMgY29udGV4dCBpbiBhIHt2YWx1ZTogLi4ufSBvYmplY3QuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHBhdGggKHRoZSBcInZhbHVlXCIpIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBjb250ZXh0IHZhbHVlIChub29wKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZVBhdGhJbk9iamVjdChpbnN0YW5jZS5jb250ZXh0LCBwYXRoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNvbXBvbmVudHMgdXNpbmcgbGVnYWN5IGNvbnRleHQgYXJlIG5vdCBlZGl0YWJsZVxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gaW5zdGFuY2Ugb24gd2hpY2ggdG8gY3JlYXRlIGEgY2xvbmVkLCBtdXRhdGVkIGNvbnRleHQuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgoZmliZXIsICgoaG9va0lEOiBhbnkpOiBudW1iZXIpLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgoZmliZXIsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShpbnN0YW5jZS5wcm9wcywgcGF0aCk7XG4gICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgIGRlbGV0ZVBhdGhJbk9iamVjdChpbnN0YW5jZS5zdGF0ZSwgcGF0aCk7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5hbWVQYXRoKFxuICAgIHR5cGU6ICdjb250ZXh0JyB8ICdob29rcycgfCAncHJvcHMnIHwgJ3N0YXRlJyxcbiAgICBpZDogbnVtYmVyLFxuICAgIGhvb2tJRDogP251bWJlcixcbiAgICBvbGRQYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICAgIG5ld1BhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcbiAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgLy8gVG8gc2ltcGxpZnkgaHlkcmF0aW9uIGFuZCBkaXNwbGF5IG9mIHByaW1pdGl2ZSBjb250ZXh0IHZhbHVlcyAoZS5nLiBudW1iZXIsIHN0cmluZylcbiAgICAgICAgICAvLyB0aGUgaW5zcGVjdEVsZW1lbnQoKSBtZXRob2Qgd3JhcHMgY29udGV4dCBpbiBhIHt2YWx1ZTogLi4ufSBvYmplY3QuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHBhdGggKHRoZSBcInZhbHVlXCIpIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgIG9sZFBhdGggPSBvbGRQYXRoLnNsaWNlKDEpO1xuICAgICAgICAgIG5ld1BhdGggPSBuZXdQYXRoLnNsaWNlKDEpO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGlmIChvbGRQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBjb250ZXh0IHZhbHVlIChub29wKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmFtZVBhdGhJbk9iamVjdChpbnN0YW5jZS5jb250ZXh0LCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNvbXBvbmVudHMgdXNpbmcgbGVnYWN5IGNvbnRleHQgYXJlIG5vdCBlZGl0YWJsZVxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gaW5zdGFuY2Ugb24gd2hpY2ggdG8gY3JlYXRlIGEgY2xvbmVkLCBtdXRhdGVkIGNvbnRleHQuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgoXG4gICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAoKGhvb2tJRDogYW55KTogbnVtYmVyKSxcbiAgICAgICAgICAgICAgb2xkUGF0aCxcbiAgICAgICAgICAgICAgbmV3UGF0aCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoXG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzLFxuICAgICAgICAgICAgICBvbGRQYXRoLFxuICAgICAgICAgICAgICBuZXdQYXRoLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAgICAgcmVuYW1lUGF0aEluT2JqZWN0KGluc3RhbmNlLnN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlVmFsdWVBdFBhdGgoXG4gICAgdHlwZTogJ2NvbnRleHQnIHwgJ2hvb2tzJyB8ICdwcm9wcycgfCAnc3RhdGUnLFxuICAgIGlkOiBudW1iZXIsXG4gICAgaG9va0lEOiA/bnVtYmVyLFxuICAgIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gICAgdmFsdWU6IGFueSxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAvLyBUbyBzaW1wbGlmeSBoeWRyYXRpb24gYW5kIGRpc3BsYXkgb2YgcHJpbWl0aXZlIGNvbnRleHQgdmFsdWVzIChlLmcuIG51bWJlciwgc3RyaW5nKVxuICAgICAgICAgIC8vIHRoZSBpbnNwZWN0RWxlbWVudCgpIG1ldGhvZCB3cmFwcyBjb250ZXh0IGluIGEge3ZhbHVlOiAuLi59IG9iamVjdC5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcGF0aCAodGhlIFwidmFsdWVcIikgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIGNvbnRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb250ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SW5PYmplY3QoaW5zdGFuY2UuY29udGV4dCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gY29tcG9uZW50cyB1c2luZyBsZWdhY3kgY29udGV4dCBhcmUgbm90IGVkaXRhYmxlXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBpbnN0YW5jZSBvbiB3aGljaCB0byBjcmVhdGUgYSBjbG9uZWQsIG11dGF0ZWQgY29udGV4dC5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3ZlcnJpZGVIb29rU3RhdGUoZmliZXIsICgoaG9va0lEOiBhbnkpOiBudW1iZXIpLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoU2V0KGluc3RhbmNlLnByb3BzLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVQcm9wcyhmaWJlciwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICBzZXRJbk9iamVjdChpbnN0YW5jZS5zdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHlwZSBDb21taXRQcm9maWxpbmdEYXRhID0ge3xcbiAgICBjaGFuZ2VEZXNjcmlwdGlvbnM6IE1hcDxudW1iZXIsIENoYW5nZURlc2NyaXB0aW9uPiB8IG51bGwsXG4gICAgY29tbWl0VGltZTogbnVtYmVyLFxuICAgIGR1cmF0aW9uczogQXJyYXk8bnVtYmVyPixcbiAgICBlZmZlY3REdXJhdGlvbjogbnVtYmVyIHwgbnVsbCxcbiAgICBtYXhBY3R1YWxEdXJhdGlvbjogbnVtYmVyLFxuICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogbnVtYmVyIHwgbnVsbCxcbiAgICBwcmlvcml0eUxldmVsOiBzdHJpbmcgfCBudWxsLFxuICAgIHVwZGF0ZXJzOiBBcnJheTxTZXJpYWxpemVkRWxlbWVudD4gfCBudWxsLFxuICB8fTtcblxuICB0eXBlIENvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwID0gTWFwPG51bWJlciwgQXJyYXk8Q29tbWl0UHJvZmlsaW5nRGF0YT4+O1xuICB0eXBlIERpc3BsYXlOYW1lc0J5Um9vdElEID0gTWFwPG51bWJlciwgc3RyaW5nPjtcblxuICBsZXQgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhOiBDb21taXRQcm9maWxpbmdEYXRhIHwgbnVsbCA9IG51bGw7XG4gIGxldCBkaXNwbGF5TmFtZXNCeVJvb3RJRDogRGlzcGxheU5hbWVzQnlSb290SUQgfCBudWxsID0gbnVsbDtcbiAgbGV0IGlkVG9Db250ZXh0c01hcDogTWFwPG51bWJlciwgYW55PiB8IG51bGwgPSBudWxsO1xuICBsZXQgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zTWFwOiBNYXA8bnVtYmVyLCBudW1iZXI+IHwgbnVsbCA9IG51bGw7XG4gIGxldCBpbml0aWFsSURUb1Jvb3RNYXA6IE1hcDxudW1iZXIsIG51bWJlcj4gfCBudWxsID0gbnVsbDtcbiAgbGV0IGlzUHJvZmlsaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIGxldCBwcm9maWxpbmdTdGFydFRpbWU6IG51bWJlciA9IDA7XG4gIGxldCByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgbGV0IHJvb3RUb0NvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwOiBDb21taXRQcm9maWxpbmdNZXRhZGF0YU1hcCB8IG51bGwgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGdldFByb2ZpbGluZ0RhdGEoKTogUHJvZmlsaW5nRGF0YUJhY2tlbmQge1xuICAgIGNvbnN0IGRhdGFGb3JSb290czogQXJyYXk8UHJvZmlsaW5nRGF0YUZvclJvb3RCYWNrZW5kPiA9IFtdO1xuXG4gICAgaWYgKHJvb3RUb0NvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ2dldFByb2ZpbGluZ0RhdGEoKSBjYWxsZWQgYmVmb3JlIGFueSBwcm9maWxpbmcgZGF0YSB3YXMgcmVjb3JkZWQnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcC5mb3JFYWNoKFxuICAgICAgKGNvbW1pdFByb2ZpbGluZ01ldGFkYXRhLCByb290SUQpID0+IHtcbiAgICAgICAgY29uc3QgY29tbWl0RGF0YTogQXJyYXk8Q29tbWl0RGF0YUJhY2tlbmQ+ID0gW107XG4gICAgICAgIGNvbnN0IGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcblxuICAgICAgICBjb25zdCBkaXNwbGF5TmFtZSA9XG4gICAgICAgICAgKGRpc3BsYXlOYW1lc0J5Um9vdElEICE9PSBudWxsICYmIGRpc3BsYXlOYW1lc0J5Um9vdElELmdldChyb290SUQpKSB8fFxuICAgICAgICAgICdVbmtub3duJztcblxuICAgICAgICBpZiAoaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zTWFwICE9IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnNNYXAuZm9yRWFjaCgodHJlZUJhc2VEdXJhdGlvbiwgaWQpID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaW5pdGlhbElEVG9Sb290TWFwICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgaW5pdGlhbElEVG9Sb290TWFwLmdldChpZCkgPT09IHJvb3RJRFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29udmVydCBtaWxsaXNlY29uZHMgdG8gbWljcm9zZWNvbmRzIGluIHRoaXMgY2FzZSxcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgcHJvZmlsaW5nIHN1bW1hcnkgaXMgSlNPTiBzZXJpYWxpemVkLlxuICAgICAgICAgICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnMucHVzaChbaWQsIHRyZWVCYXNlRHVyYXRpb25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbW1pdFByb2ZpbGluZ01ldGFkYXRhLmZvckVhY2goKGNvbW1pdFByb2ZpbGluZ0RhdGEsIGNvbW1pdEluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2hhbmdlRGVzY3JpcHRpb25zLFxuICAgICAgICAgICAgZHVyYXRpb25zLFxuICAgICAgICAgICAgZWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICBtYXhBY3R1YWxEdXJhdGlvbixcbiAgICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gICAgICAgICAgICBjb21taXRUaW1lLFxuICAgICAgICAgICAgdXBkYXRlcnMsXG4gICAgICAgICAgfSA9IGNvbW1pdFByb2ZpbGluZ0RhdGE7XG5cbiAgICAgICAgICBjb25zdCBmaWJlckFjdHVhbER1cmF0aW9uczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcbiAgICAgICAgICBjb25zdCBmaWJlclNlbGZEdXJhdGlvbnM6IEFycmF5PFtudW1iZXIsIG51bWJlcl0+ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkdXJhdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpYmVySUQgPSBkdXJhdGlvbnNbaV07XG4gICAgICAgICAgICBmaWJlckFjdHVhbER1cmF0aW9ucy5wdXNoKFtmaWJlcklELCBkdXJhdGlvbnNbaSArIDFdXSk7XG4gICAgICAgICAgICBmaWJlclNlbGZEdXJhdGlvbnMucHVzaChbZmliZXJJRCwgZHVyYXRpb25zW2kgKyAyXV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1pdERhdGEucHVzaCh7XG4gICAgICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnM6XG4gICAgICAgICAgICAgIGNoYW5nZURlc2NyaXB0aW9ucyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQXJyYXkuZnJvbShjaGFuZ2VEZXNjcmlwdGlvbnMuZW50cmllcygpKVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBtYXhBY3R1YWxEdXJhdGlvbixcbiAgICAgICAgICAgIGVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgZmliZXJBY3R1YWxEdXJhdGlvbnMsXG4gICAgICAgICAgICBmaWJlclNlbGZEdXJhdGlvbnMsXG4gICAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBjb21taXRUaW1lLFxuICAgICAgICAgICAgdXBkYXRlcnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRhdGFGb3JSb290cy5wdXNoKHtcbiAgICAgICAgICBjb21taXREYXRhLFxuICAgICAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgICAgIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9ucyxcbiAgICAgICAgICByb290SUQsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGFGb3JSb290cyxcbiAgICAgIHJlbmRlcmVySUQsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0UHJvZmlsaW5nKHNob3VsZFJlY29yZENoYW5nZURlc2NyaXB0aW9uczogYm9vbGVhbikge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA9IHNob3VsZFJlY29yZENoYW5nZURlc2NyaXB0aW9ucztcblxuICAgIC8vIENhcHR1cmUgaW5pdGlhbCB2YWx1ZXMgYXMgb2YgdGhlIHRpbWUgcHJvZmlsaW5nIHN0YXJ0cy5cbiAgICAvLyBJdCdzIGltcG9ydGFudCB3ZSBzbmFwc2hvdCBib3RoIHRoZSBkdXJhdGlvbnMgYW5kIHRoZSBpZC10by1yb290IG1hcCxcbiAgICAvLyBzaW5jZSBlaXRoZXIgb2YgdGhlc2UgbWF5IGNoYW5nZSBkdXJpbmcgdGhlIHByb2ZpbGluZyBzZXNzaW9uXG4gICAgLy8gKGUuZy4gd2hlbiBhIGZpYmVyIGlzIHJlLXJlbmRlcmVkIG9yIHdoZW4gYSBmaWJlciBnZXRzIHJlbW92ZWQpLlxuICAgIGRpc3BsYXlOYW1lc0J5Um9vdElEID0gbmV3IE1hcCgpO1xuICAgIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uc01hcCA9IG5ldyBNYXAoaWRUb1RyZWVCYXNlRHVyYXRpb25NYXApO1xuICAgIGluaXRpYWxJRFRvUm9vdE1hcCA9IG5ldyBNYXAoaWRUb1Jvb3RNYXApO1xuICAgIGlkVG9Db250ZXh0c01hcCA9IG5ldyBNYXAoKTtcblxuICAgIGhvb2suZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKS5mb3JFYWNoKHJvb3QgPT4ge1xuICAgICAgY29uc3Qgcm9vdElEID0gZ2V0RmliZXJJRFRocm93cyhyb290LmN1cnJlbnQpO1xuICAgICAgKChkaXNwbGF5TmFtZXNCeVJvb3RJRDogYW55KTogRGlzcGxheU5hbWVzQnlSb290SUQpLnNldChcbiAgICAgICAgcm9vdElELFxuICAgICAgICBnZXREaXNwbGF5TmFtZUZvclJvb3Qocm9vdC5jdXJyZW50KSxcbiAgICAgICk7XG5cbiAgICAgIGlmIChzaG91bGRSZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgLy8gUmVjb3JkIGFsbCBjb250ZXh0cyBhdCB0aGUgdGltZSBwcm9maWxpbmcgaXMgc3RhcnRlZC5cbiAgICAgICAgLy8gRmliZXJzIG9ubHkgc3RvcmUgdGhlIGN1cnJlbnQgY29udGV4dCB2YWx1ZSxcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byB0cmFjayB0aGVtIHNlcGFyYXRlbHkgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGNoYW5nZWQga2V5cy5cbiAgICAgICAgY3Jhd2xUb0luaXRpYWxpemVDb250ZXh0c01hcChyb290LmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXNQcm9maWxpbmcgPSB0cnVlO1xuICAgIHByb2ZpbGluZ1N0YXJ0VGltZSA9IGdldEN1cnJlbnRUaW1lKCk7XG4gICAgcm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wUHJvZmlsaW5nKCkge1xuICAgIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gZmFsc2U7XG4gIH1cblxuICAvLyBBdXRvbWF0aWNhbGx5IHN0YXJ0IHByb2ZpbGluZyBzbyB0aGF0IHdlIGRvbid0IG1pc3MgdGltaW5nIGluZm8gZnJvbSBpbml0aWFsIFwibW91bnRcIi5cbiAgaWYgKFxuICAgIHNlc3Npb25TdG9yYWdlR2V0SXRlbShTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWSkgPT09ICd0cnVlJ1xuICApIHtcbiAgICBzdGFydFByb2ZpbGluZyhcbiAgICAgIHNlc3Npb25TdG9yYWdlR2V0SXRlbShTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX0NIQU5HRV9ERVNDUklQVElPTlNfS0VZKSA9PT1cbiAgICAgICAgJ3RydWUnLFxuICAgICk7XG4gIH1cblxuICAvLyBSZWFjdCB3aWxsIHN3aXRjaCBiZXR3ZWVuIHRoZXNlIGltcGxlbWVudGF0aW9ucyBkZXBlbmRpbmcgb24gd2hldGhlclxuICAvLyB3ZSBoYXZlIGFueSBtYW51YWxseSBzdXNwZW5kZWQvZXJyb3JlZC1vdXQgRmliZXJzIG9yIG5vdC5cbiAgZnVuY3Rpb24gc2hvdWxkRXJyb3JGaWJlckFsd2F5c051bGwoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBNYXAgb2YgaWQgYW5kIGl0cyBmb3JjZSBlcnJvciBzdGF0dXM6IHRydWUgKGVycm9yKSwgZmFsc2UgKHRvZ2dsZWQgb2ZmKSxcbiAgLy8gbnVsbCAoZG8gbm90aGluZylcbiAgY29uc3QgZm9yY2VFcnJvckZvckZpYmVySURzID0gbmV3IE1hcCgpO1xuXG4gIGZ1bmN0aW9uIHNob3VsZEVycm9yRmliZXJBY2NvcmRpbmdUb01hcChmaWJlcikge1xuICAgIGlmICh0eXBlb2Ygc2V0RXJyb3JIYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCBvdmVycmlkZUVycm9yKCkgdG8gbm90IGdldCBjYWxsZWQgZm9yIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKTtcbiAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBzdGF0dXMgPSBudWxsO1xuICAgIGlmIChmb3JjZUVycm9yRm9yRmliZXJJRHMuaGFzKGlkKSkge1xuICAgICAgc3RhdHVzID0gZm9yY2VFcnJvckZvckZpYmVySURzLmdldChpZCk7XG4gICAgICBpZiAoc3RhdHVzID09PSBmYWxzZSkge1xuICAgICAgICAvLyBUUklDS1kgb3ZlcnJpZGVFcnJvciBhZGRzIGVudHJpZXMgdG8gdGhpcyBNYXAsXG4gICAgICAgIC8vIHNvIGlkZWFsbHkgaXQgd291bGQgYmUgdGhlIG1ldGhvZCB0aGF0IGNsZWFycyB0aGVtIHRvbyxcbiAgICAgICAgLy8gYnV0IHRoYXQgd291bGQgYnJlYWsgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGZlYXR1cmUsXG4gICAgICAgIC8vIHNpbmNlIERldlRvb2xzIG5lZWRzIHRvIHRlbGwgUmVhY3QgdG8gYWN0IGRpZmZlcmVudGx5IHRoYW4gaXQgbm9ybWFsbHkgd291bGRcbiAgICAgICAgLy8gKGRvbid0IGp1c3QgcmUtcmVuZGVyIHRoZSBmYWlsZWQgYm91bmRhcnksIGJ1dCByZXNldCBpdHMgZXJyb3JlZCBzdGF0ZSB0b28pLlxuICAgICAgICAvLyBTbyB3ZSBjYW4gb25seSBjbGVhciBpdCBhZnRlciB0ZWxsaW5nIFJlYWN0IHRvIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBpcyBwcmVtYXR1cmUgYW5kIHdlIHNob3VsZCBzY2hlZHVsZSBpdCBmb3IgbGF0ZXIsXG4gICAgICAgIC8vIHNpbmNlIHRoZSByZW5kZXIgY291bGQgYWx3YXlzIGZhaWwgd2l0aG91dCBjb21taXR0aW5nIHRoZSB1cGRhdGVkIGVycm9yIGJvdW5kYXJ5LFxuICAgICAgICAvLyBidXQgc2luY2UgdGhpcyBpcyBhIERFVi1vbmx5IGZlYXR1cmUsIHRoZSBzaW1wbGljaXR5IGlzIHdvcnRoIHRoZSB0cmFkZSBvZmYuXG4gICAgICAgIGZvcmNlRXJyb3JGb3JGaWJlcklEcy5kZWxldGUoaWQpO1xuXG4gICAgICAgIGlmIChmb3JjZUVycm9yRm9yRmliZXJJRHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIExhc3Qgb3ZlcnJpZGUgaXMgZ29uZS4gU3dpdGNoIFJlYWN0IGJhY2sgdG8gZmFzdCBwYXRoLlxuICAgICAgICAgIHNldEVycm9ySGFuZGxlcihzaG91bGRFcnJvckZpYmVyQWx3YXlzTnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXR1cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlRXJyb3IoaWQsIGZvcmNlRXJyb3IpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygc2V0RXJyb3JIYW5kbGVyICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygc2NoZWR1bGVVcGRhdGUgIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIG92ZXJyaWRlRXJyb3IoKSB0byBub3QgZ2V0IGNhbGxlZCBmb3IgZWFybGllciBSZWFjdCB2ZXJzaW9ucy4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3JjZUVycm9yRm9yRmliZXJJRHMuc2V0KGlkLCBmb3JjZUVycm9yKTtcblxuICAgIGlmIChmb3JjZUVycm9yRm9yRmliZXJJRHMuc2l6ZSA9PT0gMSkge1xuICAgICAgLy8gRmlyc3Qgb3ZlcnJpZGUgaXMgYWRkZWQuIFN3aXRjaCBSZWFjdCB0byBzbG93ZXIgcGF0aC5cbiAgICAgIHNldEVycm9ySGFuZGxlcihzaG91bGRFcnJvckZpYmVyQWNjb3JkaW5nVG9NYXApO1xuICAgIH1cblxuICAgIGNvbnN0IGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG4gICAgaWYgKGZpYmVyICE9IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlKGZpYmVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRTdXNwZW5kRmliZXJBbHdheXNGYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMgPSBuZXcgU2V0KCk7XG5cbiAgZnVuY3Rpb24gc2hvdWxkU3VzcGVuZEZpYmVyQWNjb3JkaW5nVG9TZXQoZmliZXIpIHtcbiAgICBjb25zdCBtYXliZUlEID0gZ2V0RmliZXJJRFVuc2FmZSgoKGZpYmVyOiBhbnkpOiBGaWJlcikpO1xuICAgIHJldHVybiBtYXliZUlEICE9PSBudWxsICYmIGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcy5oYXMobWF5YmVJRCk7XG4gIH1cblxuICBmdW5jdGlvbiBvdmVycmlkZVN1c3BlbnNlKGlkLCBmb3JjZUZhbGxiYWNrKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHNldFN1c3BlbnNlSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIHNjaGVkdWxlVXBkYXRlICE9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCBvdmVycmlkZVN1c3BlbnNlKCkgdG8gbm90IGdldCBjYWxsZWQgZm9yIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuJyxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmb3JjZUZhbGxiYWNrKSB7XG4gICAgICBmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMuYWRkKGlkKTtcbiAgICAgIGlmIChmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAvLyBGaXJzdCBvdmVycmlkZSBpcyBhZGRlZC4gU3dpdGNoIFJlYWN0IHRvIHNsb3dlciBwYXRoLlxuICAgICAgICBzZXRTdXNwZW5zZUhhbmRsZXIoc2hvdWxkU3VzcGVuZEZpYmVyQWNjb3JkaW5nVG9TZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMuZGVsZXRlKGlkKTtcbiAgICAgIGlmIChmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBMYXN0IG92ZXJyaWRlIGlzIGdvbmUuIFN3aXRjaCBSZWFjdCBiYWNrIHRvIGZhc3QgcGF0aC5cbiAgICAgICAgc2V0U3VzcGVuc2VIYW5kbGVyKHNob3VsZFN1c3BlbmRGaWJlckFsd2F5c0ZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGlkKTtcbiAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGUoZmliZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbWVtYmVyIGlmIHdlJ3JlIHRyeWluZyB0byByZXN0b3JlIHRoZSBzZWxlY3Rpb24gYWZ0ZXIgcmVsb2FkLlxuICAvLyBJbiB0aGF0IGNhc2UsIHdlJ2xsIGRvIHNvbWUgZXh0cmEgY2hlY2tzIGZvciBtYXRjaGluZyBtb3VudHMuXG4gIGxldCB0cmFja2VkUGF0aDogQXJyYXk8UGF0aEZyYW1lPiB8IG51bGwgPSBudWxsO1xuICBsZXQgdHJhY2tlZFBhdGhNYXRjaEZpYmVyOiBGaWJlciB8IG51bGwgPSBudWxsO1xuICBsZXQgdHJhY2tlZFBhdGhNYXRjaERlcHRoID0gLTE7XG4gIGxldCBtaWdodEJlT25UcmFja2VkUGF0aCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNldFRyYWNrZWRQYXRoKHBhdGg6IEFycmF5PFBhdGhGcmFtZT4gfCBudWxsKSB7XG4gICAgaWYgKHBhdGggPT09IG51bGwpIHtcbiAgICAgIHRyYWNrZWRQYXRoTWF0Y2hGaWJlciA9IG51bGw7XG4gICAgICB0cmFja2VkUGF0aE1hdGNoRGVwdGggPSAtMTtcbiAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gZmFsc2U7XG4gICAgfVxuICAgIHRyYWNrZWRQYXRoID0gcGF0aDtcbiAgfVxuXG4gIC8vIFdlIGNhbGwgdGhpcyBiZWZvcmUgdHJhdmVyc2luZyBhIG5ldyBtb3VudC5cbiAgLy8gSXQgcmVtZW1iZXJzIHdoZXRoZXIgdGhpcyBGaWJlciBpcyB0aGUgbmV4dCBiZXN0IG1hdGNoIGZvciB0cmFja2VkIHBhdGguXG4gIC8vIFRoZSByZXR1cm4gdmFsdWUgc2lnbmFscyB3aGV0aGVyIHdlIHNob3VsZCBrZWVwIG1hdGNoaW5nIHNpYmxpbmdzIG9yIG5vdC5cbiAgZnVuY3Rpb24gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUJlZm9yZU1vdW50KGZpYmVyOiBGaWJlcik6IGJvb2xlYW4ge1xuICAgIGlmICh0cmFja2VkUGF0aCA9PT0gbnVsbCB8fCAhbWlnaHRCZU9uVHJhY2tlZFBhdGgpIHtcbiAgICAgIC8vIEZhc3QgcGF0aDogdGhlcmUncyBub3RoaW5nIHRvIHRyYWNrIHNvIGRvIG5vdGhpbmcgYW5kIGlnbm9yZSBzaWJsaW5ncy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmV0dXJuRmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgY29uc3QgcmV0dXJuQWx0ZXJuYXRlID0gcmV0dXJuRmliZXIgIT09IG51bGwgPyByZXR1cm5GaWJlci5hbHRlcm5hdGUgOiBudWxsO1xuICAgIC8vIEJ5IG5vdyB3ZSBrbm93IHRoZXJlJ3Mgc29tZSBzZWxlY3Rpb24gdG8gcmVzdG9yZSwgYW5kIHRoaXMgaXMgYSBuZXcgRmliZXIuXG4gICAgLy8gSXMgdGhpcyBuZXdseSBtb3VudGVkIEZpYmVyIGEgZGlyZWN0IGNoaWxkIG9mIHRoZSBjdXJyZW50IGJlc3QgbWF0Y2g/XG4gICAgLy8gKFRoaXMgd2lsbCBhbHNvIGJlIHRydWUgZm9yIG5ldyByb290cyBpZiB3ZSBoYXZlbid0IG1hdGNoZWQgYW55dGhpbmcgeWV0LilcbiAgICBpZiAoXG4gICAgICB0cmFja2VkUGF0aE1hdGNoRmliZXIgPT09IHJldHVybkZpYmVyIHx8XG4gICAgICAodHJhY2tlZFBhdGhNYXRjaEZpYmVyID09PSByZXR1cm5BbHRlcm5hdGUgJiYgcmV0dXJuQWx0ZXJuYXRlICE9PSBudWxsKVxuICAgICkge1xuICAgICAgLy8gSXMgdGhpcyB0aGUgbmV4dCBGaWJlciB3ZSBzaG91bGQgc2VsZWN0PyBMZXQncyBjb21wYXJlIHRoZSBmcmFtZXMuXG4gICAgICBjb25zdCBhY3R1YWxGcmFtZSA9IGdldFBhdGhGcmFtZShmaWJlcik7XG4gICAgICBjb25zdCBleHBlY3RlZEZyYW1lID0gdHJhY2tlZFBhdGhbdHJhY2tlZFBhdGhNYXRjaERlcHRoICsgMV07XG4gICAgICBpZiAoZXhwZWN0ZWRGcmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gc2VlIGEgZnJhbWUgYXQgdGhlIG5leHQgZGVwdGguJyk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGFjdHVhbEZyYW1lLmluZGV4ID09PSBleHBlY3RlZEZyYW1lLmluZGV4ICYmXG4gICAgICAgIGFjdHVhbEZyYW1lLmtleSA9PT0gZXhwZWN0ZWRGcmFtZS5rZXkgJiZcbiAgICAgICAgYWN0dWFsRnJhbWUuZGlzcGxheU5hbWUgPT09IGV4cGVjdGVkRnJhbWUuZGlzcGxheU5hbWVcbiAgICAgICkge1xuICAgICAgICAvLyBXZSBoYXZlIG91ciBuZXh0IG1hdGNoLlxuICAgICAgICB0cmFja2VkUGF0aE1hdGNoRmliZXIgPSBmaWJlcjtcbiAgICAgICAgdHJhY2tlZFBhdGhNYXRjaERlcHRoKys7XG4gICAgICAgIC8vIEFyZSB3ZSBvdXQgb2YgZnJhbWVzIHRvIG1hdGNoP1xuICAgICAgICBpZiAodHJhY2tlZFBhdGhNYXRjaERlcHRoID09PSB0cmFja2VkUGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBub3RoaW5nIHRoYXQgY2FuIHBvc3NpYmx5IG1hdGNoIGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy8gRG9uJ3QgY2hlY2sgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2hlY2sgdGhlIGNoaWxkcmVuLCBhcyB0aGV5IG1pZ2h0IHJldmVhbCB0aGUgbmV4dCBtYXRjaC5cbiAgICAgICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gZWl0aGVyIGNhc2UsIHNpbmNlIHdlIGhhdmUgYSBtYXRjaCwgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAvLyB0byBjaGVjayB0aGUgc2libGluZ3MuIFRoZXknbGwgbmV2ZXIgbWF0Y2guXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBGaWJlcidzIHBhcmVudCBpcyBvbiB0aGUgcGF0aCwgYnV0IHRoaXMgRmliZXIgaXRzZWxmIGlzbid0LlxuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBpdHMgY2hpbGRyZW4tLXRoZXkgd29uJ3QgYmUgb24gdGhlIHBhdGggZWl0aGVyLlxuICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gZmFsc2U7XG4gICAgLy8gSG93ZXZlciwgb25lIG9mIGl0cyBzaWJsaW5ncyBtYXkgYmUgb24gdGhlIHBhdGggc28ga2VlcCBzZWFyY2hpbmcuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUcmFja2VkUGF0aFN0YXRlQWZ0ZXJNb3VudChtaWdodFNpYmxpbmdzQmVPblRyYWNrZWRQYXRoKSB7XG4gICAgLy8gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUJlZm9yZU1vdW50KCkgdG9sZCB1cyB3aGV0aGVyIHRvIG1hdGNoIHNpYmxpbmdzLlxuICAgIC8vIE5vdyB0aGF0IHdlJ3JlIGVudGVyaW5nIHNpYmxpbmdzLCBsZXQncyB1c2UgdGhhdCBpbmZvcm1hdGlvbi5cbiAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IG1pZ2h0U2libGluZ3NCZU9uVHJhY2tlZFBhdGg7XG4gIH1cblxuICAvLyBSb290cyBkb24ndCBoYXZlIGEgcmVhbCBwZXJzaXN0ZW50IGlkZW50aXR5LlxuICAvLyBBIHJvb3QncyBcInBzZXVkbyBrZXlcIiBpcyBcImNoaWxkRGlzcGxheU5hbWU6aW5kZXhXaXRoVGhhdE5hbWVcIi5cbiAgLy8gRm9yIGV4YW1wbGUsIFwiQXBwOjBcIiBvciwgaW4gY2FzZSBvZiBzaW1pbGFyIHJvb3RzLCBcIlN0b3J5OjBcIiwgXCJTdG9yeToxXCIsIGV0Yy5cbiAgLy8gV2Ugd2lsbCB1c2UgdGhpcyB0byB0cnkgdG8gZGlzYW1iaWd1YXRlIHJvb3RzIHdoZW4gcmVzdG9yaW5nIHNlbGVjdGlvbiBiZXR3ZWVuIHJlbG9hZHMuXG4gIGNvbnN0IHJvb3RQc2V1ZG9LZXlzOiBNYXA8bnVtYmVyLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuICBjb25zdCByb290RGlzcGxheU5hbWVDb3VudGVyOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuXG4gIGZ1bmN0aW9uIHNldFJvb3RQc2V1ZG9LZXkoaWQ6IG51bWJlciwgZmliZXI6IEZpYmVyKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldERpc3BsYXlOYW1lRm9yUm9vdChmaWJlcik7XG4gICAgY29uc3QgY291bnRlciA9IHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuZ2V0KG5hbWUpIHx8IDA7XG4gICAgcm9vdERpc3BsYXlOYW1lQ291bnRlci5zZXQobmFtZSwgY291bnRlciArIDEpO1xuICAgIGNvbnN0IHBzZXVkb0tleSA9IGAke25hbWV9OiR7Y291bnRlcn1gO1xuICAgIHJvb3RQc2V1ZG9LZXlzLnNldChpZCwgcHNldWRvS2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVJvb3RQc2V1ZG9LZXkoaWQ6IG51bWJlcikge1xuICAgIGNvbnN0IHBzZXVkb0tleSA9IHJvb3RQc2V1ZG9LZXlzLmdldChpZCk7XG4gICAgaWYgKHBzZXVkb0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJvb3QgcHNldWRvIGtleSB0byBiZSBrbm93bi4nKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHBzZXVkb0tleS5zdWJzdHJpbmcoMCwgcHNldWRvS2V5Lmxhc3RJbmRleE9mKCc6JykpO1xuICAgIGNvbnN0IGNvdW50ZXIgPSByb290RGlzcGxheU5hbWVDb3VudGVyLmdldChuYW1lKTtcbiAgICBpZiAoY291bnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGNvdW50ZXIgdG8gYmUga25vd24uJyk7XG4gICAgfVxuICAgIGlmIChjb3VudGVyID4gMSkge1xuICAgICAgcm9vdERpc3BsYXlOYW1lQ291bnRlci5zZXQobmFtZSwgY291bnRlciAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RGlzcGxheU5hbWVDb3VudGVyLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gICAgcm9vdFBzZXVkb0tleXMuZGVsZXRlKGlkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yUm9vdChmaWJlcjogRmliZXIpOiBzdHJpbmcge1xuICAgIGxldCBwcmVmZXJyZWREaXNwbGF5TmFtZSA9IG51bGw7XG4gICAgbGV0IGZhbGxiYWNrRGlzcGxheU5hbWUgPSBudWxsO1xuICAgIGxldCBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuICAgIC8vIEdvIGF0IG1vc3QgdGhyZWUgbGV2ZWxzIGRlZXAgaW50byBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyB3aGlsZSBzZWFyY2hpbmcgZm9yIGEgY2hpbGQgdGhhdCBoYXMgYSBkaXNwbGF5TmFtZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGNoaWxkKTtcbiAgICAgIGlmIChkaXNwbGF5TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBQcmVmZXIgZGlzcGxheSBuYW1lcyB0aGF0IHdlIGdldCBmcm9tIHVzZXItZGVmaW5lZCBjb21wb25lbnRzLlxuICAgICAgICAvLyBXZSB3YW50IHRvIGF2b2lkIHVzaW5nIGUuZy4gJ1N1c3BlbnNlJyB1bmxlc3Mgd2UgZmluZCBub3RoaW5nIGVsc2UuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFRoZXJlJ3MgYSBmZXcgdXNlci1kZWZpbmVkIHRhZ3MsIGJ1dCB3ZSdsbCBwcmVmZXIgdGhlIG9uZXNcbiAgICAgICAgICAvLyB0aGF0IGFyZSB1c3VhbGx5IGV4cGxpY2l0bHkgbmFtZWQgKGZ1bmN0aW9uIG9yIGNsYXNzIGNvbXBvbmVudHMpLlxuICAgICAgICAgIHByZWZlcnJlZERpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmFsbGJhY2tEaXNwbGF5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGZhbGxiYWNrRGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByZWZlcnJlZERpc3BsYXlOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5jaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHByZWZlcnJlZERpc3BsYXlOYW1lIHx8IGZhbGxiYWNrRGlzcGxheU5hbWUgfHwgJ0Fub255bW91cyc7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXRoRnJhbWUoZmliZXI6IEZpYmVyKTogUGF0aEZyYW1lIHtcbiAgICBjb25zdCB7a2V5fSA9IGZpYmVyO1xuICAgIGxldCBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpO1xuICAgIGNvbnN0IGluZGV4ID0gZmliZXIuaW5kZXg7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIC8vIFJvb3RzIGRvbid0IGhhdmUgYSByZWFsIGRpc3BsYXlOYW1lLCBpbmRleCwgb3Iga2V5LlxuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSdsbCB1c2UgdGhlIHBzZXVkbyBrZXkgKGNoaWxkRGlzcGxheU5hbWU6aW5kZXhXaXRoVGhhdE5hbWUpLlxuICAgICAgICBjb25zdCBpZCA9IGdldEZpYmVySURUaHJvd3MoZmliZXIpO1xuICAgICAgICBjb25zdCBwc2V1ZG9LZXkgPSByb290UHNldWRvS2V5cy5nZXQoaWQpO1xuICAgICAgICBpZiAocHNldWRvS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG1vdW50ZWQgcm9vdCB0byBoYXZlIGtub3duIHBzZXVkbyBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGxheU5hbWUgPSBwc2V1ZG9LZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaXNwbGF5TmFtZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5TmFtZSxcbiAgICAgIGtleSxcbiAgICAgIGluZGV4LFxuICAgIH07XG4gIH1cblxuICAvLyBQcm9kdWNlcyBhIHNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiB0aGF0IGRvZXMgYSBiZXN0IGVmZm9ydFxuICAvLyBvZiBpZGVudGlmeWluZyBhIHBhcnRpY3VsYXIgRmliZXIgYmV0d2VlbiBwYWdlIHJlbG9hZHMuXG4gIC8vIFRoZSByZXR1cm4gcGF0aCB3aWxsIGNvbnRhaW4gRmliZXJzIHRoYXQgYXJlIFwiaW52aXNpYmxlXCIgdG8gdGhlIHN0b3JlXG4gIC8vIGJlY2F1c2UgdGhlaXIga2V5cyBhbmQgaW5kZXhlcyBhcmUgaW1wb3J0YW50IHRvIHJlc3RvcmluZyB0aGUgc2VsZWN0aW9uLlxuICBmdW5jdGlvbiBnZXRQYXRoRm9yRWxlbWVudChpZDogbnVtYmVyKTogQXJyYXk8UGF0aEZyYW1lPiB8IG51bGwge1xuICAgIGxldCBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuICAgIGlmIChmaWJlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qga2V5UGF0aCA9IFtdO1xuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAga2V5UGF0aC5wdXNoKGdldFBhdGhGcmFtZShmaWJlcikpO1xuICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgfVxuICAgIGtleVBhdGgucmV2ZXJzZSgpO1xuICAgIHJldHVybiBrZXlQYXRoO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgoKTogUGF0aE1hdGNoIHwgbnVsbCB7XG4gICAgaWYgKHRyYWNrZWRQYXRoID09PSBudWxsKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIG1hdGNoLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0cmFja2VkUGF0aE1hdGNoRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgRmliZXIgc3RvcmUgaXMgYXdhcmUgb2YuXG4gICAgbGV0IGZpYmVyID0gdHJhY2tlZFBhdGhNYXRjaEZpYmVyO1xuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCAmJiBzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikpIHtcbiAgICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGdldEZpYmVySURUaHJvd3MoZmliZXIpLFxuICAgICAgaXNGdWxsTWF0Y2g6IHRyYWNrZWRQYXRoTWF0Y2hEZXB0aCA9PT0gdHJhY2tlZFBhdGgubGVuZ3RoIC0gMSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZm9ybWF0UHJpb3JpdHlMZXZlbCA9IChwcmlvcml0eUxldmVsOiA/bnVtYmVyKSA9PiB7XG4gICAgaWYgKHByaW9yaXR5TGV2ZWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICAgIHJldHVybiAnSW1tZWRpYXRlJztcbiAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgIHJldHVybiAnVXNlci1CbG9ja2luZyc7XG4gICAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgICByZXR1cm4gJ05vcm1hbCc7XG4gICAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgICByZXR1cm4gJ0xvdyc7XG4gICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgcmV0dXJuICdJZGxlJztcbiAgICAgIGNhc2UgTm9Qcmlvcml0eTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQoaXNFbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdHJhY2VVcGRhdGVzRW5hYmxlZCA9IGlzRW5hYmxlZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYW51cCxcbiAgICBjbGVhckVycm9yc0FuZFdhcm5pbmdzLFxuICAgIGNsZWFyRXJyb3JzRm9yRmliZXJJRCxcbiAgICBjbGVhcldhcm5pbmdzRm9yRmliZXJJRCxcbiAgICBjb3B5RWxlbWVudFBhdGgsXG4gICAgZGVsZXRlUGF0aCxcbiAgICBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklELFxuICAgIGZsdXNoSW5pdGlhbE9wZXJhdGlvbnMsXG4gICAgZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgsXG4gICAgZ2V0RGlzcGxheU5hbWVGb3JGaWJlcklELFxuICAgIGdldEZpYmVySURGb3JOYXRpdmUsXG4gICAgZ2V0SW5zdGFuY2VBbmRTdHlsZSxcbiAgICBnZXRPd25lcnNMaXN0LFxuICAgIGdldFBhdGhGb3JFbGVtZW50LFxuICAgIGdldFByb2ZpbGluZ0RhdGEsXG4gICAgaGFuZGxlQ29tbWl0RmliZXJSb290LFxuICAgIGhhbmRsZUNvbW1pdEZpYmVyVW5tb3VudCxcbiAgICBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290LFxuICAgIGluc3BlY3RFbGVtZW50LFxuICAgIGxvZ0VsZW1lbnRUb0NvbnNvbGUsXG4gICAgcGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZSxcbiAgICBwcmVwYXJlVmlld0F0dHJpYnV0ZVNvdXJjZSxcbiAgICBwcmVwYXJlVmlld0VsZW1lbnRTb3VyY2UsXG4gICAgb3ZlcnJpZGVFcnJvcixcbiAgICBvdmVycmlkZVN1c3BlbnNlLFxuICAgIG92ZXJyaWRlVmFsdWVBdFBhdGgsXG4gICAgcmVuYW1lUGF0aCxcbiAgICByZW5kZXJlcixcbiAgICBzZXRUcmFjZVVwZGF0ZXNFbmFibGVkLFxuICAgIHNldFRyYWNrZWRQYXRoLFxuICAgIHN0YXJ0UHJvZmlsaW5nLFxuICAgIHN0b3BQcm9maWxpbmcsXG4gICAgc3RvcmVBc0dsb2JhbCxcbiAgICB1bnBhdGNoQ29uc29sZUZvclN0cmljdE1vZGUsXG4gICAgdXBkYXRlQ29tcG9uZW50RmlsdGVycyxcbiAgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFrQkE7QUFVQTtBQUNBO0FBUUE7QUFZQTtBQUNBO0FBTUE7QUFtQkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBeUJBO0FBQ0E7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUE1QkE7QUE2QkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUE1QkE7QUE2QkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUE1QkE7QUE2QkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTVCQTtBQTZCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBM0JBO0FBNkJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBbENBO0FBQ0E7QUF2REE7QUEyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFJQTtBQVNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQXZCQTtBQXlCQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBUkE7QUFDQTtBQXJCQTtBQUNBO0FBK0JBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFsQkE7QUFDQTtBQTVCQTtBQWdEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQVJBO0FBQ0E7QUFjQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQTlDQTtBQWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQTNCQTtBQTZCQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQWxDQTtBQW9DQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQXFCQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQU1BO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVlBO0FBRUE7QUFPQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQTVEQTtBQThEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBNUJBO0FBQ0E7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFqQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUlBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUNBO0FBYUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUF4Q0E7QUEwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUNBO0FBYUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFsREE7QUFvREE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFjQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVRBO0FBQ0E7QUFVQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQUtBO0FBaERBO0FBa0RBO0FBQ0E7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQWZBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFxQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/renderer.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/utils.js":
/*!*****************************************************!*\
  !*** ../react-devtools-shared/src/backend/utils.js ***!
  \*****************************************************/
/*! exports provided: cleanForBridge, copyToClipboard, copyWithDelete, copyWithRename, copyWithSet, getEffectDurations, serializeToString, format, isSynchronousXHRSupported */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cleanForBridge\", function() { return cleanForBridge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyToClipboard\", function() { return copyToClipboard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyWithDelete\", function() { return copyWithDelete; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyWithRename\", function() { return copyWithRename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyWithSet\", function() { return copyWithSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getEffectDurations\", function() { return getEffectDurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"serializeToString\", function() { return serializeToString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"format\", function() { return format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isSynchronousXHRSupported\", function() { return isSynchronousXHRSupported; });\n/* harmony import */ var clipboard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clipboard-js */ \"../../node_modules/clipboard-js/clipboard.js\");\n/* harmony import */ var clipboard_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clipboard_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hydration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hydration */ \"../react-devtools-shared/src/hydration.js\");\n/* harmony import */ var shared_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shared/isArray */ \"../shared/isArray.js\");\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\nfunction cleanForBridge(data, isPathAllowed, path = []) {\n  if (data !== null) {\n    const cleanedPaths = [];\n    const unserializablePaths = [];\n    const cleanedData = Object(_hydration__WEBPACK_IMPORTED_MODULE_1__[\"dehydrate\"])(data, cleanedPaths, unserializablePaths, path, isPathAllowed);\n    return {\n      data: cleanedData,\n      cleaned: cleanedPaths,\n      unserializable: unserializablePaths\n    };\n  } else {\n    return null;\n  }\n}\nfunction copyToClipboard(value) {\n  const safeToCopy = serializeToString(value);\n  const text = safeToCopy === undefined ? 'undefined' : safeToCopy;\n  const {\n    clipboardCopyText\n  } = window.__REACT_DEVTOOLS_GLOBAL_HOOK__; // On Firefox navigator.clipboard.writeText has to be called from\n  // the content script js code (because it requires the clipboardWrite\n  // permission to be allowed out of a \"user handling\" callback),\n  // clipboardCopyText is an helper injected into the page from.\n  // injectGlobalHook.\n\n  if (typeof clipboardCopyText === 'function') {\n    clipboardCopyText(text).catch(err => {});\n  } else {\n    Object(clipboard_js__WEBPACK_IMPORTED_MODULE_0__[\"copy\"])(text);\n  }\n}\nfunction copyWithDelete(obj, path, index = 0) {\n  const key = path[index];\n  const updated = Object(shared_isArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(obj) ? obj.slice() : { ...obj\n  };\n\n  if (index + 1 === path.length) {\n    if (Object(shared_isArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(updated)) {\n      updated.splice(key, 1);\n    } else {\n      delete updated[key];\n    }\n  } else {\n    // $FlowFixMe number or string is fine here\n    updated[key] = copyWithDelete(obj[key], path, index + 1);\n  }\n\n  return updated;\n} // This function expects paths to be the same except for the final value.\n// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']\n\nfunction copyWithRename(obj, oldPath, newPath, index = 0) {\n  const oldKey = oldPath[index];\n  const updated = Object(shared_isArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(obj) ? obj.slice() : { ...obj\n  };\n\n  if (index + 1 === oldPath.length) {\n    const newKey = newPath[index]; // $FlowFixMe number or string is fine here\n\n    updated[newKey] = updated[oldKey];\n\n    if (Object(shared_isArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(updated)) {\n      updated.splice(oldKey, 1);\n    } else {\n      delete updated[oldKey];\n    }\n  } else {\n    // $FlowFixMe number or string is fine here\n    updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);\n  }\n\n  return updated;\n}\nfunction copyWithSet(obj, path, value, index = 0) {\n  if (index >= path.length) {\n    return value;\n  }\n\n  const key = path[index];\n  const updated = Object(shared_isArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(obj) ? obj.slice() : { ...obj\n  }; // $FlowFixMe number or string is fine here\n\n  updated[key] = copyWithSet(obj[key], path, value, index + 1);\n  return updated;\n}\nfunction getEffectDurations(root) {\n  // Profiling durations are only available for certain builds.\n  // If available, they'll be stored on the HostRoot.\n  let effectDuration = null;\n  let passiveEffectDuration = null;\n  const hostRoot = root.current;\n\n  if (hostRoot != null) {\n    const stateNode = hostRoot.stateNode;\n\n    if (stateNode != null) {\n      effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;\n      passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;\n    }\n  }\n\n  return {\n    effectDuration,\n    passiveEffectDuration\n  };\n}\nfunction serializeToString(data) {\n  const cache = new Set(); // Use a custom replacer function to protect against circular references.\n\n  return JSON.stringify(data, (key, value) => {\n    if (typeof value === 'object' && value !== null) {\n      if (cache.has(value)) {\n        return;\n      }\n\n      cache.add(value);\n    } // $FlowFixMe\n\n\n    if (typeof value === 'bigint') {\n      return value.toString() + 'n';\n    }\n\n    return value;\n  });\n} // based on https://github.com/tmpfs/format-util/blob/0e62d430efb0a1c51448709abd3e2406c14d8401/format.js#L1\n// based on https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions\n// Implements s, d, i and f placeholders\n// NOTE: KEEP IN SYNC with src/hook.js\n\nfunction format(maybeMessage, ...inputArgs) {\n  const args = inputArgs.slice();\n  let formatted = String(maybeMessage); // If the first argument is a string, check for substitutions.\n\n  if (typeof maybeMessage === 'string') {\n    if (args.length) {\n      const REGEXP = /(%?)(%([jds]))/g;\n      formatted = formatted.replace(REGEXP, (match, escaped, ptn, flag) => {\n        let arg = args.shift();\n\n        switch (flag) {\n          case 's':\n            arg += '';\n            break;\n\n          case 'd':\n          case 'i':\n            arg = parseInt(arg, 10).toString();\n            break;\n\n          case 'f':\n            arg = parseFloat(arg).toString();\n            break;\n        }\n\n        if (!escaped) {\n          return arg;\n        }\n\n        args.unshift(arg);\n        return match;\n      });\n    }\n  } // Arguments that remain after formatting.\n\n\n  if (args.length) {\n    for (let i = 0; i < args.length; i++) {\n      formatted += ' ' + String(args[i]);\n    }\n  } // Update escaped %% values.\n\n\n  formatted = formatted.replace(/%{2,2}/g, '%');\n  return String(formatted);\n}\nfunction isSynchronousXHRSupported() {\n  return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature('sync-xhr'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC91dGlscy5qcz8wMTRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge2NvcHl9IGZyb20gJ2NsaXBib2FyZC1qcyc7XG5pbXBvcnQge2RlaHlkcmF0ZX0gZnJvbSAnLi4vaHlkcmF0aW9uJztcbmltcG9ydCBpc0FycmF5IGZyb20gJ3NoYXJlZC9pc0FycmF5JztcblxuaW1wb3J0IHR5cGUge0RlaHlkcmF0ZWREYXRhfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL3ZpZXdzL0NvbXBvbmVudHMvdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5Gb3JCcmlkZ2UoXG4gIGRhdGE6IE9iamVjdCB8IG51bGwsXG4gIGlzUGF0aEFsbG93ZWQ6IChwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+KSA9PiBib29sZWFuLFxuICBwYXRoPzogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiA9IFtdLFxuKTogRGVoeWRyYXRlZERhdGEgfCBudWxsIHtcbiAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICBjb25zdCBjbGVhbmVkUGF0aHMgPSBbXTtcbiAgICBjb25zdCB1bnNlcmlhbGl6YWJsZVBhdGhzID0gW107XG4gICAgY29uc3QgY2xlYW5lZERhdGEgPSBkZWh5ZHJhdGUoXG4gICAgICBkYXRhLFxuICAgICAgY2xlYW5lZFBhdGhzLFxuICAgICAgdW5zZXJpYWxpemFibGVQYXRocyxcbiAgICAgIHBhdGgsXG4gICAgICBpc1BhdGhBbGxvd2VkLFxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogY2xlYW5lZERhdGEsXG4gICAgICBjbGVhbmVkOiBjbGVhbmVkUGF0aHMsXG4gICAgICB1bnNlcmlhbGl6YWJsZTogdW5zZXJpYWxpemFibGVQYXRocyxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQodmFsdWU6IGFueSk6IHZvaWQge1xuICBjb25zdCBzYWZlVG9Db3B5ID0gc2VyaWFsaXplVG9TdHJpbmcodmFsdWUpO1xuICBjb25zdCB0ZXh0ID0gc2FmZVRvQ29weSA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiBzYWZlVG9Db3B5O1xuICBjb25zdCB7Y2xpcGJvYXJkQ29weVRleHR9ID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICAvLyBPbiBGaXJlZm94IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0IGhhcyB0byBiZSBjYWxsZWQgZnJvbVxuICAvLyB0aGUgY29udGVudCBzY3JpcHQganMgY29kZSAoYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgY2xpcGJvYXJkV3JpdGVcbiAgLy8gcGVybWlzc2lvbiB0byBiZSBhbGxvd2VkIG91dCBvZiBhIFwidXNlciBoYW5kbGluZ1wiIGNhbGxiYWNrKSxcbiAgLy8gY2xpcGJvYXJkQ29weVRleHQgaXMgYW4gaGVscGVyIGluamVjdGVkIGludG8gdGhlIHBhZ2UgZnJvbS5cbiAgLy8gaW5qZWN0R2xvYmFsSG9vay5cbiAgaWYgKHR5cGVvZiBjbGlwYm9hcmRDb3B5VGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNsaXBib2FyZENvcHlUZXh0KHRleHQpLmNhdGNoKGVyciA9PiB7fSk7XG4gIH0gZWxzZSB7XG4gICAgY29weSh0ZXh0KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weVdpdGhEZWxldGUoXG4gIG9iajogT2JqZWN0IHwgQXJyYXk8YW55PixcbiAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgaW5kZXg6IG51bWJlciA9IDAsXG4pOiBPYmplY3QgfCBBcnJheTxhbnk+IHtcbiAgY29uc3Qga2V5ID0gcGF0aFtpbmRleF07XG4gIGNvbnN0IHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IHsuLi5vYmp9O1xuICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICB1cGRhdGVkLnNwbGljZSgoKGtleTogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZShvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgfVxuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGZpbmFsIHZhbHVlLlxuLy8gZS5nLiBbJ3BhdGgnLCAndG8nLCAnZm9vJ10gYW5kIFsncGF0aCcsICd0bycsICdiYXInXVxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lKFxuICBvYmo6IE9iamVjdCB8IEFycmF5PGFueT4sXG4gIG9sZFBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIG5ld1BhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIGluZGV4OiBudW1iZXIgPSAwLFxuKTogT2JqZWN0IHwgQXJyYXk8YW55PiB7XG4gIGNvbnN0IG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdO1xuICBjb25zdCB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiB7Li4ub2JqfTtcbiAgaWYgKGluZGV4ICsgMSA9PT0gb2xkUGF0aC5sZW5ndGgpIHtcbiAgICBjb25zdCBuZXdLZXkgPSBuZXdQYXRoW2luZGV4XTtcbiAgICAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgdXBkYXRlZFtuZXdLZXldID0gdXBkYXRlZFtvbGRLZXldO1xuICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICB1cGRhdGVkLnNwbGljZSgoKG9sZEtleTogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICB1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZShvYmpbb2xkS2V5XSwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXggKyAxKTtcbiAgfVxuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlXaXRoU2V0KFxuICBvYmo6IE9iamVjdCB8IEFycmF5PGFueT4sXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIHZhbHVlOiBhbnksXG4gIGluZGV4OiBudW1iZXIgPSAwLFxuKTogT2JqZWN0IHwgQXJyYXk8YW55PiB7XG4gIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25zdCBrZXkgPSBwYXRoW2luZGV4XTtcbiAgY29uc3QgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogey4uLm9ian07XG4gIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXQob2JqW2tleV0sIHBhdGgsIHZhbHVlLCBpbmRleCArIDEpO1xuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVmZmVjdER1cmF0aW9ucyhyb290OiBPYmplY3QpIHtcbiAgLy8gUHJvZmlsaW5nIGR1cmF0aW9ucyBhcmUgb25seSBhdmFpbGFibGUgZm9yIGNlcnRhaW4gYnVpbGRzLlxuICAvLyBJZiBhdmFpbGFibGUsIHRoZXknbGwgYmUgc3RvcmVkIG9uIHRoZSBIb3N0Um9vdC5cbiAgbGV0IGVmZmVjdER1cmF0aW9uID0gbnVsbDtcbiAgbGV0IHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IG51bGw7XG4gIGNvbnN0IGhvc3RSb290ID0gcm9vdC5jdXJyZW50O1xuICBpZiAoaG9zdFJvb3QgIT0gbnVsbCkge1xuICAgIGNvbnN0IHN0YXRlTm9kZSA9IGhvc3RSb290LnN0YXRlTm9kZTtcbiAgICBpZiAoc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgIGVmZmVjdER1cmF0aW9uID1cbiAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICE9IG51bGwgPyBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gOiBudWxsO1xuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID1cbiAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiAhPSBudWxsXG4gICAgICAgICAgPyBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2VmZmVjdER1cmF0aW9uLCBwYXNzaXZlRWZmZWN0RHVyYXRpb259O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplVG9TdHJpbmcoZGF0YTogYW55KTogc3RyaW5nIHtcbiAgY29uc3QgY2FjaGUgPSBuZXcgU2V0KCk7XG4gIC8vIFVzZSBhIGN1c3RvbSByZXBsYWNlciBmdW5jdGlvbiB0byBwcm90ZWN0IGFnYWluc3QgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjYWNoZS5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhY2hlLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIC8vICRGbG93Rml4TWVcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyAnbic7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS90bXBmcy9mb3JtYXQtdXRpbC9ibG9iLzBlNjJkNDMwZWZiMGExYzUxNDQ4NzA5YWJkM2UyNDA2YzE0ZDg0MDEvZm9ybWF0LmpzI0wxXG4vLyBiYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvY29uc29sZSNVc2luZ19zdHJpbmdfc3Vic3RpdHV0aW9uc1xuLy8gSW1wbGVtZW50cyBzLCBkLCBpIGFuZCBmIHBsYWNlaG9sZGVyc1xuLy8gTk9URTogS0VFUCBJTiBTWU5DIHdpdGggc3JjL2hvb2suanNcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoXG4gIG1heWJlTWVzc2FnZTogYW55LFxuICAuLi5pbnB1dEFyZ3M6ICRSZWFkT25seUFycmF5PGFueT5cbik6IHN0cmluZyB7XG4gIGNvbnN0IGFyZ3MgPSBpbnB1dEFyZ3Muc2xpY2UoKTtcblxuICBsZXQgZm9ybWF0dGVkOiBzdHJpbmcgPSBTdHJpbmcobWF5YmVNZXNzYWdlKTtcblxuICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIGNoZWNrIGZvciBzdWJzdGl0dXRpb25zLlxuICBpZiAodHlwZW9mIG1heWJlTWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFJFR0VYUCA9IC8oJT8pKCUoW2pkc10pKS9nO1xuXG4gICAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZShSRUdFWFAsIChtYXRjaCwgZXNjYXBlZCwgcHRuLCBmbGFnKSA9PiB7XG4gICAgICAgIGxldCBhcmcgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgYXJnICs9ICcnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBhcmcgPSBwYXJzZUludChhcmcsIDEwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBhcmcgPSBwYXJzZUZsb2F0KGFyZykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy51bnNoaWZ0KGFyZyk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFyZ3VtZW50cyB0aGF0IHJlbWFpbiBhZnRlciBmb3JtYXR0aW5nLlxuICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvcm1hdHRlZCArPSAnICcgKyBTdHJpbmcoYXJnc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIGVzY2FwZWQgJSUgdmFsdWVzLlxuICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZSgvJXsyLDJ9L2csICclJyk7XG5cbiAgcmV0dXJuIFN0cmluZyhmb3JtYXR0ZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTeW5jaHJvbm91c1hIUlN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhKFxuICAgIHdpbmRvdy5kb2N1bWVudCAmJlxuICAgIHdpbmRvdy5kb2N1bWVudC5mZWF0dXJlUG9saWN5ICYmXG4gICAgd2luZG93LmRvY3VtZW50LmZlYXR1cmVQb2xpY3kuYWxsb3dzRmVhdHVyZSgnc3luYy14aHInKVxuICApO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFLQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/utils.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/config/DevToolsFeatureFlags.extension-oss.js":
/*!*********************************************************************************!*\
  !*** ../react-devtools-shared/src/config/DevToolsFeatureFlags.extension-oss.js ***!
  \*********************************************************************************/
/*! exports provided: consoleManagedByDevToolsDuringStrictMode, enableLogger, enableNamedHooksFeature, enableProfilerChangedHookIndices, enableStyleXFeatures, isInternalFacebookBuild */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"consoleManagedByDevToolsDuringStrictMode\", function() { return consoleManagedByDevToolsDuringStrictMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableLogger\", function() { return enableLogger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableNamedHooksFeature\", function() { return enableNamedHooksFeature; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableProfilerChangedHookIndices\", function() { return enableProfilerChangedHookIndices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableStyleXFeatures\", function() { return enableStyleXFeatures; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isInternalFacebookBuild\", function() { return isInternalFacebookBuild; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/************************************************************************\n * This file is forked between different DevTools implementations.\n * It should never be imported directly!\n * It should always be imported from \"react-devtools-feature-flags\".\n ************************************************************************/\nconst consoleManagedByDevToolsDuringStrictMode = true;\nconst enableLogger = false;\nconst enableNamedHooksFeature = true;\nconst enableProfilerChangedHookIndices = true;\nconst enableStyleXFeatures = false;\nconst isInternalFacebookBuild = false;\n/************************************************************************\n * Do not edit the code below.\n * It ensures this fork exports the same types as the default flags file.\n ************************************************************************/\n\n// eslint-disable-next-line no-unused-expressions\nnull;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25maWcvRGV2VG9vbHNGZWF0dXJlRmxhZ3MuZXh0ZW5zaW9uLW9zcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2NvbmZpZy9EZXZUb29sc0ZlYXR1cmVGbGFncy5leHRlbnNpb24tb3NzLmpzPzJkMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRoaXMgZmlsZSBpcyBmb3JrZWQgYmV0d2VlbiBkaWZmZXJlbnQgRGV2VG9vbHMgaW1wbGVtZW50YXRpb25zLlxuICogSXQgc2hvdWxkIG5ldmVyIGJlIGltcG9ydGVkIGRpcmVjdGx5IVxuICogSXQgc2hvdWxkIGFsd2F5cyBiZSBpbXBvcnRlZCBmcm9tIFwicmVhY3QtZGV2dG9vbHMtZmVhdHVyZS1mbGFnc1wiLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZXhwb3J0IGNvbnN0IGNvbnNvbGVNYW5hZ2VkQnlEZXZUb29sc0R1cmluZ1N0cmljdE1vZGUgPSB0cnVlO1xuZXhwb3J0IGNvbnN0IGVuYWJsZUxvZ2dlciA9IGZhbHNlO1xuZXhwb3J0IGNvbnN0IGVuYWJsZU5hbWVkSG9va3NGZWF0dXJlID0gdHJ1ZTtcbmV4cG9ydCBjb25zdCBlbmFibGVQcm9maWxlckNoYW5nZWRIb29rSW5kaWNlcyA9IHRydWU7XG5leHBvcnQgY29uc3QgZW5hYmxlU3R5bGVYRmVhdHVyZXMgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBpc0ludGVybmFsRmFjZWJvb2tCdWlsZCA9IGZhbHNlO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBEbyBub3QgZWRpdCB0aGUgY29kZSBiZWxvdy5cbiAqIEl0IGVuc3VyZXMgdGhpcyBmb3JrIGV4cG9ydHMgdGhlIHNhbWUgdHlwZXMgYXMgdGhlIGRlZmF1bHQgZmxhZ3MgZmlsZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmltcG9ydCB0eXBlb2YgKiBhcyBGZWF0dXJlRmxhZ3NUeXBlIGZyb20gJy4vRGV2VG9vbHNGZWF0dXJlRmxhZ3MuZGVmYXVsdCc7XG5pbXBvcnQgdHlwZW9mICogYXMgRXhwb3J0c1R5cGUgZnJvbSAnLi9EZXZUb29sc0ZlYXR1cmVGbGFncy5leHRlbnNpb24tb3NzJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG50eXBlIENoZWNrPF9YLCBZOiBfWCwgWDogWSA9IF9YPiA9IG51bGw7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4obnVsbDogQ2hlY2s8RXhwb3J0c1R5cGUsIEZlYXR1cmVGbGFnc1R5cGU+KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7O0FBU0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBVUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/config/DevToolsFeatureFlags.extension-oss.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/constants.js":
/*!*************************************************!*\
  !*** ../react-devtools-shared/src/constants.js ***!
  \*************************************************/
/*! exports provided: CHROME_WEBSTORE_EXTENSION_ID, INTERNAL_EXTENSION_ID, LOCAL_EXTENSION_ID, __DEBUG__, __PERFORMANCE_PROFILE__, TREE_OPERATION_ADD, TREE_OPERATION_REMOVE, TREE_OPERATION_REORDER_CHILDREN, TREE_OPERATION_UPDATE_TREE_BASE_DURATION, TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS, TREE_OPERATION_REMOVE_ROOT, TREE_OPERATION_SET_SUBTREE_MODE, LOCAL_STORAGE_DEFAULT_TAB_KEY, LOCAL_STORAGE_FILTER_PREFERENCES_KEY, SESSION_STORAGE_LAST_SELECTION_KEY, LOCAL_STORAGE_OPEN_IN_EDITOR_URL, LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY, SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS, LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY, LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY, LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY, LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE, PROFILER_EXPORT_VERSION, CHANGE_LOG_URL, UNSUPPORTED_VERSION_URL, REACT_DEVTOOLS_WORKPLACE_URL, THEME_STYLES, COMFORTABLE_LINE_HEIGHT, COMPACT_LINE_HEIGHT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CHROME_WEBSTORE_EXTENSION_ID\", function() { return CHROME_WEBSTORE_EXTENSION_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INTERNAL_EXTENSION_ID\", function() { return INTERNAL_EXTENSION_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_EXTENSION_ID\", function() { return LOCAL_EXTENSION_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__DEBUG__\", function() { return __DEBUG__; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__PERFORMANCE_PROFILE__\", function() { return __PERFORMANCE_PROFILE__; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_ADD\", function() { return TREE_OPERATION_ADD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_REMOVE\", function() { return TREE_OPERATION_REMOVE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_REORDER_CHILDREN\", function() { return TREE_OPERATION_REORDER_CHILDREN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_UPDATE_TREE_BASE_DURATION\", function() { return TREE_OPERATION_UPDATE_TREE_BASE_DURATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS\", function() { return TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_REMOVE_ROOT\", function() { return TREE_OPERATION_REMOVE_ROOT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TREE_OPERATION_SET_SUBTREE_MODE\", function() { return TREE_OPERATION_SET_SUBTREE_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_DEFAULT_TAB_KEY\", function() { return LOCAL_STORAGE_DEFAULT_TAB_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_FILTER_PREFERENCES_KEY\", function() { return LOCAL_STORAGE_FILTER_PREFERENCES_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SESSION_STORAGE_LAST_SELECTION_KEY\", function() { return SESSION_STORAGE_LAST_SELECTION_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_OPEN_IN_EDITOR_URL\", function() { return LOCAL_STORAGE_OPEN_IN_EDITOR_URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY\", function() { return LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY\", function() { return SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SESSION_STORAGE_RELOAD_AND_PROFILE_KEY\", function() { return SESSION_STORAGE_RELOAD_AND_PROFILE_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS\", function() { return LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY\", function() { return LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY\", function() { return LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY\", function() { return LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE\", function() { return LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PROFILER_EXPORT_VERSION\", function() { return PROFILER_EXPORT_VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CHANGE_LOG_URL\", function() { return CHANGE_LOG_URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UNSUPPORTED_VERSION_URL\", function() { return UNSUPPORTED_VERSION_URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_DEVTOOLS_WORKPLACE_URL\", function() { return REACT_DEVTOOLS_WORKPLACE_URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"THEME_STYLES\", function() { return THEME_STYLES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMFORTABLE_LINE_HEIGHT\", function() { return COMFORTABLE_LINE_HEIGHT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMPACT_LINE_HEIGHT\", function() { return COMPACT_LINE_HEIGHT; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst CHROME_WEBSTORE_EXTENSION_ID = 'fmkadmapgofadopljbjfkapdkoienihi';\nconst INTERNAL_EXTENSION_ID = 'dnjnjgbfilfphmojnmhliehogmojhclc';\nconst LOCAL_EXTENSION_ID = 'ikiahnapldjmdmpkmfhjdjilojjhgcbf'; // Flip this flag to true to enable verbose console debug logging.\n\nconst __DEBUG__ = false; // Flip this flag to true to enable performance.mark() and performance.measure() timings.\n\nconst __PERFORMANCE_PROFILE__ = false;\nconst TREE_OPERATION_ADD = 1;\nconst TREE_OPERATION_REMOVE = 2;\nconst TREE_OPERATION_REORDER_CHILDREN = 3;\nconst TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;\nconst TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;\nconst TREE_OPERATION_REMOVE_ROOT = 6;\nconst TREE_OPERATION_SET_SUBTREE_MODE = 7;\nconst LOCAL_STORAGE_DEFAULT_TAB_KEY = 'React::DevTools::defaultTab';\nconst LOCAL_STORAGE_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';\nconst SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';\nconst LOCAL_STORAGE_OPEN_IN_EDITOR_URL = 'React::DevTools::openInEditorUrl';\nconst LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = 'React::DevTools::parseHookNames';\nconst SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';\nconst SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';\nconst LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = 'React::DevTools::breakOnConsoleErrors';\nconst LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY = 'React::DevTools::appendComponentStack';\nconst LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY = 'React::DevTools::showInlineWarningsAndErrors';\nconst LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';\nconst LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE = 'React::DevTools::hideConsoleLogsInStrictMode';\nconst PROFILER_EXPORT_VERSION = 5;\nconst CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md';\nconst UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back';\nconst REACT_DEVTOOLS_WORKPLACE_URL = 'https://fburl.com/react-devtools-workplace-group';\nconst THEME_STYLES = {\n  light: {\n    '--color-attribute-name': '#ef6632',\n    '--color-attribute-name-not-editable': '#23272f',\n    '--color-attribute-name-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-attribute-value': '#1a1aa6',\n    '--color-attribute-value-inverted': '#ffffff',\n    '--color-attribute-editable-value': '#1a1aa6',\n    '--color-background': '#ffffff',\n    '--color-background-hover': 'rgba(0, 136, 250, 0.1)',\n    '--color-background-inactive': '#e5e5e5',\n    '--color-background-invalid': '#fff0f0',\n    '--color-background-selected': '#0088fa',\n    '--color-button-background': '#ffffff',\n    '--color-button-background-focus': '#ededed',\n    '--color-button': '#5f6673',\n    '--color-button-disabled': '#cfd1d5',\n    '--color-button-active': '#0088fa',\n    '--color-button-focus': '#23272f',\n    '--color-button-hover': '#23272f',\n    '--color-border': '#eeeeee',\n    '--color-commit-did-not-render-fill': '#cfd1d5',\n    '--color-commit-did-not-render-fill-text': '#000000',\n    '--color-commit-did-not-render-pattern': '#cfd1d5',\n    '--color-commit-did-not-render-pattern-text': '#333333',\n    '--color-commit-gradient-0': '#37afa9',\n    '--color-commit-gradient-1': '#63b19e',\n    '--color-commit-gradient-2': '#80b393',\n    '--color-commit-gradient-3': '#97b488',\n    '--color-commit-gradient-4': '#abb67d',\n    '--color-commit-gradient-5': '#beb771',\n    '--color-commit-gradient-6': '#cfb965',\n    '--color-commit-gradient-7': '#dfba57',\n    '--color-commit-gradient-8': '#efbb49',\n    '--color-commit-gradient-9': '#febc38',\n    '--color-commit-gradient-text': '#000000',\n    '--color-component-name': '#6a51b2',\n    '--color-component-name-inverted': '#ffffff',\n    '--color-component-badge-background': 'rgba(0, 0, 0, 0.1)',\n    '--color-component-badge-background-inverted': 'rgba(255, 255, 255, 0.25)',\n    '--color-component-badge-count': '#777d88',\n    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-console-error-badge-text': '#ffffff',\n    '--color-console-error-background': '#fff0f0',\n    '--color-console-error-border': '#ffd6d6',\n    '--color-console-error-icon': '#eb3941',\n    '--color-console-error-text': '#fe2e31',\n    '--color-console-warning-badge-text': '#000000',\n    '--color-console-warning-background': '#fffbe5',\n    '--color-console-warning-border': '#fff5c1',\n    '--color-console-warning-icon': '#f4bd00',\n    '--color-console-warning-text': '#64460c',\n    '--color-context-background': 'rgba(0,0,0,.9)',\n    '--color-context-background-hover': 'rgba(255, 255, 255, 0.1)',\n    '--color-context-background-selected': '#178fb9',\n    '--color-context-border': '#3d424a',\n    '--color-context-text': '#ffffff',\n    '--color-context-text-selected': '#ffffff',\n    '--color-dim': '#777d88',\n    '--color-dimmer': '#cfd1d5',\n    '--color-dimmest': '#eff0f1',\n    '--color-error-background': 'hsl(0, 100%, 97%)',\n    '--color-error-border': 'hsl(0, 100%, 92%)',\n    '--color-error-text': '#ff0000',\n    '--color-expand-collapse-toggle': '#777d88',\n    '--color-link': '#0000ff',\n    '--color-modal-background': 'rgba(255, 255, 255, 0.75)',\n    '--color-bridge-version-npm-background': '#eff0f1',\n    '--color-bridge-version-npm-text': '#000000',\n    '--color-bridge-version-number': '#0088fa',\n    '--color-primitive-hook-badge-background': '#e5e5e5',\n    '--color-primitive-hook-badge-text': '#5f6673',\n    '--color-record-active': '#fc3a4b',\n    '--color-record-hover': '#3578e5',\n    '--color-record-inactive': '#0088fa',\n    '--color-resize-bar': '#eeeeee',\n    '--color-resize-bar-active': '#dcdcdc',\n    '--color-resize-bar-border': '#d1d1d1',\n    '--color-resize-bar-dot': '#333333',\n    '--color-timeline-internal-module': '#d1d1d1',\n    '--color-timeline-internal-module-hover': '#c9c9c9',\n    '--color-timeline-internal-module-text': '#444',\n    '--color-timeline-native-event': '#ccc',\n    '--color-timeline-native-event-hover': '#aaa',\n    '--color-timeline-network-primary': '#fcf3dc',\n    '--color-timeline-network-primary-hover': '#f0e7d1',\n    '--color-timeline-network-secondary': '#efc457',\n    '--color-timeline-network-secondary-hover': '#e3ba52',\n    '--color-timeline-priority-background': '#f6f6f6',\n    '--color-timeline-priority-border': '#eeeeee',\n    '--color-timeline-user-timing': '#c9cacd',\n    '--color-timeline-user-timing-hover': '#93959a',\n    '--color-timeline-react-idle': '#d3e5f6',\n    '--color-timeline-react-idle-hover': '#c3d9ef',\n    '--color-timeline-react-render': '#9fc3f3',\n    '--color-timeline-react-render-hover': '#83afe9',\n    '--color-timeline-react-render-text': '#11365e',\n    '--color-timeline-react-commit': '#c88ff0',\n    '--color-timeline-react-commit-hover': '#b281d6',\n    '--color-timeline-react-commit-text': '#3e2c4a',\n    '--color-timeline-react-layout-effects': '#b281d6',\n    '--color-timeline-react-layout-effects-hover': '#9d71bd',\n    '--color-timeline-react-layout-effects-text': '#3e2c4a',\n    '--color-timeline-react-passive-effects': '#b281d6',\n    '--color-timeline-react-passive-effects-hover': '#9d71bd',\n    '--color-timeline-react-passive-effects-text': '#3e2c4a',\n    '--color-timeline-react-schedule': '#9fc3f3',\n    '--color-timeline-react-schedule-hover': '#2683E2',\n    '--color-timeline-react-suspense-rejected': '#f1cc14',\n    '--color-timeline-react-suspense-rejected-hover': '#ffdf37',\n    '--color-timeline-react-suspense-resolved': '#a6e59f',\n    '--color-timeline-react-suspense-resolved-hover': '#89d281',\n    '--color-timeline-react-suspense-unresolved': '#c9cacd',\n    '--color-timeline-react-suspense-unresolved-hover': '#93959a',\n    '--color-timeline-thrown-error': '#ee1638',\n    '--color-timeline-thrown-error-hover': '#da1030',\n    '--color-timeline-text-color': '#000000',\n    '--color-timeline-text-dim-color': '#ccc',\n    '--color-timeline-react-work-border': '#eeeeee',\n    '--color-search-match': 'yellow',\n    '--color-search-match-current': '#f7923b',\n    '--color-selected-tree-highlight-active': 'rgba(0, 136, 250, 0.1)',\n    '--color-selected-tree-highlight-inactive': 'rgba(0, 0, 0, 0.05)',\n    '--color-scroll-caret': 'rgba(150, 150, 150, 0.5)',\n    '--color-tab-selected-border': '#0088fa',\n    '--color-text': '#000000',\n    '--color-text-invalid': '#ff0000',\n    '--color-text-selected': '#ffffff',\n    '--color-toggle-background-invalid': '#fc3a4b',\n    '--color-toggle-background-on': '#0088fa',\n    '--color-toggle-background-off': '#cfd1d5',\n    '--color-toggle-text': '#ffffff',\n    '--color-warning-background': '#fb3655',\n    '--color-warning-background-hover': '#f82042',\n    '--color-warning-text-color': '#ffffff',\n    '--color-warning-text-color-inverted': '#fd4d69',\n    // The styles below should be kept in sync with 'root.css'\n    // They are repeated there because they're used by e.g. tooltips or context menus\n    // which get rendered outside of the DOM subtree (where normal theme/styles are written).\n    '--color-scroll-thumb': '#c2c2c2',\n    '--color-scroll-track': '#fafafa',\n    '--color-tooltip-background': 'rgba(0, 0, 0, 0.9)',\n    '--color-tooltip-text': '#ffffff'\n  },\n  dark: {\n    '--color-attribute-name': '#9d87d2',\n    '--color-attribute-name-not-editable': '#ededed',\n    '--color-attribute-name-inverted': '#282828',\n    '--color-attribute-value': '#cedae0',\n    '--color-attribute-value-inverted': '#ffffff',\n    '--color-attribute-editable-value': 'yellow',\n    '--color-background': '#282c34',\n    '--color-background-hover': 'rgba(255, 255, 255, 0.1)',\n    '--color-background-inactive': '#3d424a',\n    '--color-background-invalid': '#5c0000',\n    '--color-background-selected': '#178fb9',\n    '--color-button-background': '#282c34',\n    '--color-button-background-focus': '#3d424a',\n    '--color-button': '#afb3b9',\n    '--color-button-active': '#61dafb',\n    '--color-button-disabled': '#4f5766',\n    '--color-button-focus': '#a2e9fc',\n    '--color-button-hover': '#ededed',\n    '--color-border': '#3d424a',\n    '--color-commit-did-not-render-fill': '#777d88',\n    '--color-commit-did-not-render-fill-text': '#000000',\n    '--color-commit-did-not-render-pattern': '#666c77',\n    '--color-commit-did-not-render-pattern-text': '#ffffff',\n    '--color-commit-gradient-0': '#37afa9',\n    '--color-commit-gradient-1': '#63b19e',\n    '--color-commit-gradient-2': '#80b393',\n    '--color-commit-gradient-3': '#97b488',\n    '--color-commit-gradient-4': '#abb67d',\n    '--color-commit-gradient-5': '#beb771',\n    '--color-commit-gradient-6': '#cfb965',\n    '--color-commit-gradient-7': '#dfba57',\n    '--color-commit-gradient-8': '#efbb49',\n    '--color-commit-gradient-9': '#febc38',\n    '--color-commit-gradient-text': '#000000',\n    '--color-component-name': '#61dafb',\n    '--color-component-name-inverted': '#282828',\n    '--color-component-badge-background': 'rgba(255, 255, 255, 0.25)',\n    '--color-component-badge-background-inverted': 'rgba(0, 0, 0, 0.25)',\n    '--color-component-badge-count': '#8f949d',\n    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-console-error-badge-text': '#000000',\n    '--color-console-error-background': '#290000',\n    '--color-console-error-border': '#5c0000',\n    '--color-console-error-icon': '#eb3941',\n    '--color-console-error-text': '#fc7f7f',\n    '--color-console-warning-badge-text': '#000000',\n    '--color-console-warning-background': '#332b00',\n    '--color-console-warning-border': '#665500',\n    '--color-console-warning-icon': '#f4bd00',\n    '--color-console-warning-text': '#f5f2ed',\n    '--color-context-background': 'rgba(255,255,255,.95)',\n    '--color-context-background-hover': 'rgba(0, 136, 250, 0.1)',\n    '--color-context-background-selected': '#0088fa',\n    '--color-context-border': '#eeeeee',\n    '--color-context-text': '#000000',\n    '--color-context-text-selected': '#ffffff',\n    '--color-dim': '#8f949d',\n    '--color-dimmer': '#777d88',\n    '--color-dimmest': '#4f5766',\n    '--color-error-background': '#200',\n    '--color-error-border': '#900',\n    '--color-error-text': '#f55',\n    '--color-expand-collapse-toggle': '#8f949d',\n    '--color-link': '#61dafb',\n    '--color-modal-background': 'rgba(0, 0, 0, 0.75)',\n    '--color-bridge-version-npm-background': 'rgba(0, 0, 0, 0.25)',\n    '--color-bridge-version-npm-text': '#ffffff',\n    '--color-bridge-version-number': 'yellow',\n    '--color-primitive-hook-badge-background': 'rgba(0, 0, 0, 0.25)',\n    '--color-primitive-hook-badge-text': 'rgba(255, 255, 255, 0.7)',\n    '--color-record-active': '#fc3a4b',\n    '--color-record-hover': '#a2e9fc',\n    '--color-record-inactive': '#61dafb',\n    '--color-resize-bar': '#282c34',\n    '--color-resize-bar-active': '#31363f',\n    '--color-resize-bar-border': '#3d424a',\n    '--color-resize-bar-dot': '#cfd1d5',\n    '--color-timeline-internal-module': '#303542',\n    '--color-timeline-internal-module-hover': '#363b4a',\n    '--color-timeline-internal-module-text': '#7f8899',\n    '--color-timeline-native-event': '#b2b2b2',\n    '--color-timeline-native-event-hover': '#949494',\n    '--color-timeline-network-primary': '#fcf3dc',\n    '--color-timeline-network-primary-hover': '#e3dbc5',\n    '--color-timeline-network-secondary': '#efc457',\n    '--color-timeline-network-secondary-hover': '#d6af4d',\n    '--color-timeline-priority-background': '#1d2129',\n    '--color-timeline-priority-border': '#282c34',\n    '--color-timeline-user-timing': '#c9cacd',\n    '--color-timeline-user-timing-hover': '#93959a',\n    '--color-timeline-react-idle': '#3d485b',\n    '--color-timeline-react-idle-hover': '#465269',\n    '--color-timeline-react-render': '#2683E2',\n    '--color-timeline-react-render-hover': '#1a76d4',\n    '--color-timeline-react-render-text': '#11365e',\n    '--color-timeline-react-commit': '#731fad',\n    '--color-timeline-react-commit-hover': '#611b94',\n    '--color-timeline-react-commit-text': '#e5c1ff',\n    '--color-timeline-react-layout-effects': '#611b94',\n    '--color-timeline-react-layout-effects-hover': '#51167a',\n    '--color-timeline-react-layout-effects-text': '#e5c1ff',\n    '--color-timeline-react-passive-effects': '#611b94',\n    '--color-timeline-react-passive-effects-hover': '#51167a',\n    '--color-timeline-react-passive-effects-text': '#e5c1ff',\n    '--color-timeline-react-schedule': '#2683E2',\n    '--color-timeline-react-schedule-hover': '#1a76d4',\n    '--color-timeline-react-suspense-rejected': '#f1cc14',\n    '--color-timeline-react-suspense-rejected-hover': '#e4c00f',\n    '--color-timeline-react-suspense-resolved': '#a6e59f',\n    '--color-timeline-react-suspense-resolved-hover': '#89d281',\n    '--color-timeline-react-suspense-unresolved': '#c9cacd',\n    '--color-timeline-react-suspense-unresolved-hover': '#93959a',\n    '--color-timeline-thrown-error': '#fb3655',\n    '--color-timeline-thrown-error-hover': '#f82042',\n    '--color-timeline-text-color': '#282c34',\n    '--color-timeline-text-dim-color': '#555b66',\n    '--color-timeline-react-work-border': '#3d424a',\n    '--color-search-match': 'yellow',\n    '--color-search-match-current': '#f7923b',\n    '--color-selected-tree-highlight-active': 'rgba(23, 143, 185, 0.15)',\n    '--color-selected-tree-highlight-inactive': 'rgba(255, 255, 255, 0.05)',\n    '--color-scroll-caret': '#4f5766',\n    '--color-shadow': 'rgba(0, 0, 0, 0.5)',\n    '--color-tab-selected-border': '#178fb9',\n    '--color-text': '#ffffff',\n    '--color-text-invalid': '#ff8080',\n    '--color-text-selected': '#ffffff',\n    '--color-toggle-background-invalid': '#fc3a4b',\n    '--color-toggle-background-on': '#178fb9',\n    '--color-toggle-background-off': '#777d88',\n    '--color-toggle-text': '#ffffff',\n    '--color-warning-background': '#ee1638',\n    '--color-warning-background-hover': '#da1030',\n    '--color-warning-text-color': '#ffffff',\n    '--color-warning-text-color-inverted': '#ee1638',\n    // The styles below should be kept in sync with 'root.css'\n    // They are repeated there because they're used by e.g. tooltips or context menus\n    // which get rendered outside of the DOM subtree (where normal theme/styles are written).\n    '--color-scroll-thumb': '#afb3b9',\n    '--color-scroll-track': '#313640',\n    '--color-tooltip-background': 'rgba(255, 255, 255, 0.95)',\n    '--color-tooltip-text': '#000000'\n  },\n  compact: {\n    '--font-size-monospace-small': '9px',\n    '--font-size-monospace-normal': '11px',\n    '--font-size-monospace-large': '15px',\n    '--font-size-sans-small': '10px',\n    '--font-size-sans-normal': '12px',\n    '--font-size-sans-large': '14px',\n    '--line-height-data': '18px'\n  },\n  comfortable: {\n    '--font-size-monospace-small': '10px',\n    '--font-size-monospace-normal': '13px',\n    '--font-size-monospace-large': '17px',\n    '--font-size-sans-small': '12px',\n    '--font-size-sans-normal': '14px',\n    '--font-size-sans-large': '16px',\n    '--line-height-data': '22px'\n  }\n}; // HACK\n//\n// Sometimes the inline target is rendered before root styles are applied,\n// which would result in e.g. NaN itemSize being passed to react-window list.\n\nconst COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable['--line-height-data'], 10);\nconst COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact['--line-height-data'], 10);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25zdGFudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25zdGFudHMuanM/YTMwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuZXhwb3J0IGNvbnN0IENIUk9NRV9XRUJTVE9SRV9FWFRFTlNJT05fSUQgPSAnZm1rYWRtYXBnb2ZhZG9wbGpiamZrYXBka29pZW5paGknO1xuZXhwb3J0IGNvbnN0IElOVEVSTkFMX0VYVEVOU0lPTl9JRCA9ICdkbmpuamdiZmlsZnBobW9qbm1obGllaG9nbW9qaGNsYyc7XG5leHBvcnQgY29uc3QgTE9DQUxfRVhURU5TSU9OX0lEID0gJ2lraWFobmFwbGRqbWRtcGttZmhqZGppbG9qamhnY2JmJztcblxuLy8gRmxpcCB0aGlzIGZsYWcgdG8gdHJ1ZSB0byBlbmFibGUgdmVyYm9zZSBjb25zb2xlIGRlYnVnIGxvZ2dpbmcuXG5leHBvcnQgY29uc3QgX19ERUJVR19fID0gZmFsc2U7XG5cbi8vIEZsaXAgdGhpcyBmbGFnIHRvIHRydWUgdG8gZW5hYmxlIHBlcmZvcm1hbmNlLm1hcmsoKSBhbmQgcGVyZm9ybWFuY2UubWVhc3VyZSgpIHRpbWluZ3MuXG5leHBvcnQgY29uc3QgX19QRVJGT1JNQU5DRV9QUk9GSUxFX18gPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IFRSRUVfT1BFUkFUSU9OX0FERCA9IDE7XG5leHBvcnQgY29uc3QgVFJFRV9PUEVSQVRJT05fUkVNT1ZFID0gMjtcbmV4cG9ydCBjb25zdCBUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOID0gMztcbmV4cG9ydCBjb25zdCBUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OID0gNDtcbmV4cG9ydCBjb25zdCBUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTID0gNTtcbmV4cG9ydCBjb25zdCBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCA9IDY7XG5leHBvcnQgY29uc3QgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERSA9IDc7XG5cbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX0RFRkFVTFRfVEFCX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6OmRlZmF1bHRUYWInO1xuXG5leHBvcnQgY29uc3QgTE9DQUxfU1RPUkFHRV9GSUxURVJfUFJFRkVSRU5DRVNfS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6Y29tcG9uZW50RmlsdGVycyc7XG5cbmV4cG9ydCBjb25zdCBTRVNTSU9OX1NUT1JBR0VfTEFTVF9TRUxFQ1RJT05fS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6bGFzdFNlbGVjdGlvbic7XG5cbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX09QRU5fSU5fRURJVE9SX1VSTCA9XG4gICdSZWFjdDo6RGV2VG9vbHM6Om9wZW5JbkVkaXRvclVybCc7XG5cbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX1BBUlNFX0hPT0tfTkFNRVNfS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6cGFyc2VIb29rTmFtZXMnO1xuXG5leHBvcnQgY29uc3QgU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OnJlY29yZENoYW5nZURlc2NyaXB0aW9ucyc7XG5cbmV4cG9ydCBjb25zdCBTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OnJlbG9hZEFuZFByb2ZpbGUnO1xuXG5leHBvcnQgY29uc3QgTE9DQUxfU1RPUkFHRV9TSE9VTERfQlJFQUtfT05fQ09OU09MRV9FUlJPUlMgPVxuICAnUmVhY3Q6OkRldlRvb2xzOjpicmVha09uQ29uc29sZUVycm9ycyc7XG5cbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX1NIT1VMRF9QQVRDSF9DT05TT0xFX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OmFwcGVuZENvbXBvbmVudFN0YWNrJztcblxuZXhwb3J0IGNvbnN0IExPQ0FMX1NUT1JBR0VfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19LRVkgPVxuICAnUmVhY3Q6OkRldlRvb2xzOjpzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMnO1xuXG5leHBvcnQgY29uc3QgTE9DQUxfU1RPUkFHRV9UUkFDRV9VUERBVEVTX0VOQUJMRURfS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6dHJhY2VVcGRhdGVzRW5hYmxlZCc7XG5cbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX0hJREVfQ09OU09MRV9MT0dTX0lOX1NUUklDVF9NT0RFID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6aGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlJztcblxuZXhwb3J0IGNvbnN0IFBST0ZJTEVSX0VYUE9SVF9WRVJTSU9OID0gNTtcblxuZXhwb3J0IGNvbnN0IENIQU5HRV9MT0dfVVJMID1cbiAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QtZGV2dG9vbHMvQ0hBTkdFTE9HLm1kJztcblxuZXhwb3J0IGNvbnN0IFVOU1VQUE9SVEVEX1ZFUlNJT05fVVJMID1cbiAgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvYmxvZy8yMDE5LzA4LzE1L25ldy1yZWFjdC1kZXZ0b29scy5odG1sI2hvdy1kby1pLWdldC10aGUtb2xkLXZlcnNpb24tYmFjayc7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9ERVZUT09MU19XT1JLUExBQ0VfVVJMID1cbiAgJ2h0dHBzOi8vZmJ1cmwuY29tL3JlYWN0LWRldnRvb2xzLXdvcmtwbGFjZS1ncm91cCc7XG5cbmltcG9ydCB0eXBlIHtcbiAgVGhlbWUsXG4gIERpc3BsYXlEZW5zaXR5LFxufSBmcm9tICcuL2RldnRvb2xzL3ZpZXdzL1NldHRpbmdzL1NldHRpbmdzQ29udGV4dCc7XG5cbmV4cG9ydCBjb25zdCBUSEVNRV9TVFlMRVM6IHtbc3R5bGU6IFRoZW1lIHwgRGlzcGxheURlbnNpdHldOiBhbnl9ID0ge1xuICBsaWdodDoge1xuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lJzogJyNlZjY2MzInLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lLW5vdC1lZGl0YWJsZSc6ICcjMjMyNzJmJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtbmFtZS1pbnZlcnRlZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS12YWx1ZSc6ICcjMWExYWE2JyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtdmFsdWUtaW52ZXJ0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLWVkaXRhYmxlLXZhbHVlJzogJyMxYTFhYTYnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1ob3Zlcic6ICdyZ2JhKDAsIDEzNiwgMjUwLCAwLjEpJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWluYWN0aXZlJzogJyNlNWU1ZTUnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaW52YWxpZCc6ICcjZmZmMGYwJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLXNlbGVjdGVkJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1iYWNrZ3JvdW5kJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1iYWNrZ3JvdW5kLWZvY3VzJzogJyNlZGVkZWQnLFxuICAgICctLWNvbG9yLWJ1dHRvbic6ICcjNWY2NjczJyxcbiAgICAnLS1jb2xvci1idXR0b24tZGlzYWJsZWQnOiAnI2NmZDFkNScsXG4gICAgJy0tY29sb3ItYnV0dG9uLWFjdGl2ZSc6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci1idXR0b24tZm9jdXMnOiAnIzIzMjcyZicsXG4gICAgJy0tY29sb3ItYnV0dG9uLWhvdmVyJzogJyMyMzI3MmYnLFxuICAgICctLWNvbG9yLWJvcmRlcic6ICcjZWVlZWVlJyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItZmlsbCc6ICcjY2ZkMWQ1JyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItZmlsbC10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1wYXR0ZXJuJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1wYXR0ZXJuLXRleHQnOiAnIzMzMzMzMycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTAnOiAnIzM3YWZhOScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTEnOiAnIzYzYjE5ZScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTInOiAnIzgwYjM5MycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTMnOiAnIzk3YjQ4OCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTQnOiAnI2FiYjY3ZCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTUnOiAnI2JlYjc3MScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTYnOiAnI2NmYjk2NScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTcnOiAnI2RmYmE1NycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTgnOiAnI2VmYmI0OScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTknOiAnI2ZlYmMzOCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LW5hbWUnOiAnIzZhNTFiMicsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LW5hbWUtaW52ZXJ0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWJhY2tncm91bmQnOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtYmFja2dyb3VuZC1pbnZlcnRlZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjUpJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtY291bnQnOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWNvdW50LWludmVydGVkJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1iYWRnZS10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYmFja2dyb3VuZCc6ICcjZmZmMGYwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJvcmRlcic6ICcjZmZkNmQ2JyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWljb24nOiAnI2ViMzk0MScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci10ZXh0JzogJyNmZTJlMzEnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWRnZS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWNrZ3JvdW5kJzogJyNmZmZiZTUnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1ib3JkZXInOiAnI2ZmZjVjMScsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWljb24nOiAnI2Y0YmQwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLXRleHQnOiAnIzY0NDYwYycsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwwLDAsLjkpJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQtaG92ZXInOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQtc2VsZWN0ZWQnOiAnIzE3OGZiOScsXG4gICAgJy0tY29sb3ItY29udGV4dC1ib3JkZXInOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3ItY29udGV4dC10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWNvbnRleHQtdGV4dC1zZWxlY3RlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1kaW0nOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItZGltbWVyJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLWRpbW1lc3QnOiAnI2VmZjBmMScsXG4gICAgJy0tY29sb3ItZXJyb3ItYmFja2dyb3VuZCc6ICdoc2woMCwgMTAwJSwgOTclKScsXG4gICAgJy0tY29sb3ItZXJyb3ItYm9yZGVyJzogJ2hzbCgwLCAxMDAlLCA5MiUpJyxcbiAgICAnLS1jb2xvci1lcnJvci10ZXh0JzogJyNmZjAwMDAnLFxuICAgICctLWNvbG9yLWV4cGFuZC1jb2xsYXBzZS10b2dnbGUnOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItbGluayc6ICcjMDAwMGZmJyxcbiAgICAnLS1jb2xvci1tb2RhbC1iYWNrZ3JvdW5kJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS1iYWNrZ3JvdW5kJzogJyNlZmYwZjEnLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW51bWJlcic6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci1wcmltaXRpdmUtaG9vay1iYWRnZS1iYWNrZ3JvdW5kJzogJyNlNWU1ZTUnLFxuICAgICctLWNvbG9yLXByaW1pdGl2ZS1ob29rLWJhZGdlLXRleHQnOiAnIzVmNjY3MycsXG4gICAgJy0tY29sb3ItcmVjb3JkLWFjdGl2ZSc6ICcjZmMzYTRiJyxcbiAgICAnLS1jb2xvci1yZWNvcmQtaG92ZXInOiAnIzM1NzhlNScsXG4gICAgJy0tY29sb3ItcmVjb3JkLWluYWN0aXZlJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXInOiAnI2VlZWVlZScsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1hY3RpdmUnOiAnI2RjZGNkYycsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1ib3JkZXInOiAnI2QxZDFkMScsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1kb3QnOiAnIzMzMzMzMycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtaW50ZXJuYWwtbW9kdWxlJzogJyNkMWQxZDEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLWludGVybmFsLW1vZHVsZS1ob3Zlcic6ICcjYzljOWM5JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1pbnRlcm5hbC1tb2R1bGUtdGV4dCc6ICcjNDQ0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uYXRpdmUtZXZlbnQnOiAnI2NjYycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmF0aXZlLWV2ZW50LWhvdmVyJzogJyNhYWEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstcHJpbWFyeSc6ICcjZmNmM2RjJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXByaW1hcnktaG92ZXInOiAnI2YwZTdkMScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1zZWNvbmRhcnknOiAnI2VmYzQ1NycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1zZWNvbmRhcnktaG92ZXInOiAnI2UzYmE1MicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcHJpb3JpdHktYmFja2dyb3VuZCc6ICcjZjZmNmY2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1wcmlvcml0eS1ib3JkZXInOiAnI2VlZWVlZScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdXNlci10aW1pbmcnOiAnI2M5Y2FjZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdXNlci10aW1pbmctaG92ZXInOiAnIzkzOTU5YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtaWRsZSc6ICcjZDNlNWY2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1pZGxlLWhvdmVyJzogJyNjM2Q5ZWYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXJlbmRlcic6ICcjOWZjM2YzJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1yZW5kZXItaG92ZXInOiAnIzgzYWZlOScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcmVuZGVyLXRleHQnOiAnIzExMzY1ZScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtY29tbWl0JzogJyNjODhmZjAnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWNvbW1pdC1ob3Zlcic6ICcjYjI4MWQ2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1jb21taXQtdGV4dCc6ICcjM2UyYzRhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1sYXlvdXQtZWZmZWN0cyc6ICcjYjI4MWQ2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1sYXlvdXQtZWZmZWN0cy1ob3Zlcic6ICcjOWQ3MWJkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1sYXlvdXQtZWZmZWN0cy10ZXh0JzogJyMzZTJjNGEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXBhc3NpdmUtZWZmZWN0cyc6ICcjYjI4MWQ2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1wYXNzaXZlLWVmZmVjdHMtaG92ZXInOiAnIzlkNzFiZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcGFzc2l2ZS1lZmZlY3RzLXRleHQnOiAnIzNlMmM0YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc2NoZWR1bGUnOiAnIzlmYzNmMycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc2NoZWR1bGUtaG92ZXInOiAnIzI2ODNFMicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVqZWN0ZWQnOiAnI2YxY2MxNCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVqZWN0ZWQtaG92ZXInOiAnI2ZmZGYzNycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVzb2x2ZWQnOiAnI2E2ZTU5ZicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVzb2x2ZWQtaG92ZXInOiAnIzg5ZDI4MScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtdW5yZXNvbHZlZCc6ICcjYzljYWNkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS11bnJlc29sdmVkLWhvdmVyJzogJyM5Mzk1OWEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRocm93bi1lcnJvcic6ICcjZWUxNjM4JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10aHJvd24tZXJyb3ItaG92ZXInOiAnI2RhMTAzMCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGV4dC1jb2xvcic6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10ZXh0LWRpbS1jb2xvcic6ICcjY2NjJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC13b3JrLWJvcmRlcic6ICcjZWVlZWVlJyxcbiAgICAnLS1jb2xvci1zZWFyY2gtbWF0Y2gnOiAneWVsbG93JyxcbiAgICAnLS1jb2xvci1zZWFyY2gtbWF0Y2gtY3VycmVudCc6ICcjZjc5MjNiJyxcbiAgICAnLS1jb2xvci1zZWxlY3RlZC10cmVlLWhpZ2hsaWdodC1hY3RpdmUnOiAncmdiYSgwLCAxMzYsIDI1MCwgMC4xKScsXG4gICAgJy0tY29sb3Itc2VsZWN0ZWQtdHJlZS1oaWdobGlnaHQtaW5hY3RpdmUnOiAncmdiYSgwLCAwLCAwLCAwLjA1KScsXG4gICAgJy0tY29sb3Itc2Nyb2xsLWNhcmV0JzogJ3JnYmEoMTUwLCAxNTAsIDE1MCwgMC41KScsXG4gICAgJy0tY29sb3ItdGFiLXNlbGVjdGVkLWJvcmRlcic6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLXRleHQtaW52YWxpZCc6ICcjZmYwMDAwJyxcbiAgICAnLS1jb2xvci10ZXh0LXNlbGVjdGVkJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLWludmFsaWQnOiAnI2ZjM2E0YicsXG4gICAgJy0tY29sb3ItdG9nZ2xlLWJhY2tncm91bmQtb24nOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItdG9nZ2xlLWJhY2tncm91bmQtb2ZmJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLXRvZ2dsZS10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXdhcm5pbmctYmFja2dyb3VuZCc6ICcjZmIzNjU1JyxcbiAgICAnLS1jb2xvci13YXJuaW5nLWJhY2tncm91bmQtaG92ZXInOiAnI2Y4MjA0MicsXG4gICAgJy0tY29sb3Itd2FybmluZy10ZXh0LWNvbG9yJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXdhcm5pbmctdGV4dC1jb2xvci1pbnZlcnRlZCc6ICcjZmQ0ZDY5JyxcblxuICAgIC8vIFRoZSBzdHlsZXMgYmVsb3cgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoICdyb290LmNzcydcbiAgICAvLyBUaGV5IGFyZSByZXBlYXRlZCB0aGVyZSBiZWNhdXNlIHRoZXkncmUgdXNlZCBieSBlLmcuIHRvb2x0aXBzIG9yIGNvbnRleHQgbWVudXNcbiAgICAvLyB3aGljaCBnZXQgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgRE9NIHN1YnRyZWUgKHdoZXJlIG5vcm1hbCB0aGVtZS9zdHlsZXMgYXJlIHdyaXR0ZW4pLlxuICAgICctLWNvbG9yLXNjcm9sbC10aHVtYic6ICcjYzJjMmMyJyxcbiAgICAnLS1jb2xvci1zY3JvbGwtdHJhY2snOiAnI2ZhZmFmYScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC45KScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC10ZXh0JzogJyNmZmZmZmYnLFxuICB9LFxuICBkYXJrOiB7XG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUnOiAnIzlkODdkMicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUtbm90LWVkaXRhYmxlJzogJyNlZGVkZWQnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lLWludmVydGVkJzogJyMyODI4MjgnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS12YWx1ZSc6ICcjY2VkYWUwJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtdmFsdWUtaW52ZXJ0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLWVkaXRhYmxlLXZhbHVlJzogJ3llbGxvdycsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZCc6ICcjMjgyYzM0JyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWhvdmVyJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKScsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1pbmFjdGl2ZSc6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWludmFsaWQnOiAnIzVjMDAwMCcsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1zZWxlY3RlZCc6ICcjMTc4ZmI5JyxcbiAgICAnLS1jb2xvci1idXR0b24tYmFja2dyb3VuZCc6ICcjMjgyYzM0JyxcbiAgICAnLS1jb2xvci1idXR0b24tYmFja2dyb3VuZC1mb2N1cyc6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1idXR0b24nOiAnI2FmYjNiOScsXG4gICAgJy0tY29sb3ItYnV0dG9uLWFjdGl2ZSc6ICcjNjFkYWZiJyxcbiAgICAnLS1jb2xvci1idXR0b24tZGlzYWJsZWQnOiAnIzRmNTc2NicsXG4gICAgJy0tY29sb3ItYnV0dG9uLWZvY3VzJzogJyNhMmU5ZmMnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1ob3Zlcic6ICcjZWRlZGVkJyxcbiAgICAnLS1jb2xvci1ib3JkZXInOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLWZpbGwnOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLWZpbGwtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItcGF0dGVybic6ICcjNjY2Yzc3JyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItcGF0dGVybi10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0wJzogJyMzN2FmYTknLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0xJzogJyM2M2IxOWUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0yJzogJyM4MGIzOTMnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0zJzogJyM5N2I0ODgnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC00JzogJyNhYmI2N2QnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC01JzogJyNiZWI3NzEnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC02JzogJyNjZmI5NjUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC03JzogJyNkZmJhNTcnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC04JzogJyNlZmJiNDknLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC05JzogJyNmZWJjMzgnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1uYW1lJzogJyM2MWRhZmInLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1uYW1lLWludmVydGVkJzogJyMyODI4MjgnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1iYWNrZ3JvdW5kJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4yNSknLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1iYWNrZ3JvdW5kLWludmVydGVkJzogJ3JnYmEoMCwgMCwgMCwgMC4yNSknLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1jb3VudCc6ICcjOGY5NDlkJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtY291bnQtaW52ZXJ0ZWQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJhZGdlLXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1iYWNrZ3JvdW5kJzogJyMyOTAwMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYm9yZGVyJzogJyM1YzAwMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItaWNvbic6ICcjZWIzOTQxJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLXRleHQnOiAnI2ZjN2Y3ZicsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWJhZGdlLXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWJhY2tncm91bmQnOiAnIzMzMmIwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWJvcmRlcic6ICcjNjY1NTAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctaWNvbic6ICcjZjRiZDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctdGV4dCc6ICcjZjVmMmVkJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQnOiAncmdiYSgyNTUsMjU1LDI1NSwuOTUpJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQtaG92ZXInOiAncmdiYSgwLCAxMzYsIDI1MCwgMC4xKScsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kLXNlbGVjdGVkJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLWNvbnRleHQtYm9yZGVyJzogJyNlZWVlZWUnLFxuICAgICctLWNvbG9yLWNvbnRleHQtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LXRleHQtc2VsZWN0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItZGltJzogJyM4Zjk0OWQnLFxuICAgICctLWNvbG9yLWRpbW1lcic6ICcjNzc3ZDg4JyxcbiAgICAnLS1jb2xvci1kaW1tZXN0JzogJyM0ZjU3NjYnLFxuICAgICctLWNvbG9yLWVycm9yLWJhY2tncm91bmQnOiAnIzIwMCcsXG4gICAgJy0tY29sb3ItZXJyb3ItYm9yZGVyJzogJyM5MDAnLFxuICAgICctLWNvbG9yLWVycm9yLXRleHQnOiAnI2Y1NScsXG4gICAgJy0tY29sb3ItZXhwYW5kLWNvbGxhcHNlLXRvZ2dsZSc6ICcjOGY5NDlkJyxcbiAgICAnLS1jb2xvci1saW5rJzogJyM2MWRhZmInLFxuICAgICctLWNvbG9yLW1vZGFsLWJhY2tncm91bmQnOiAncmdiYSgwLCAwLCAwLCAwLjc1KScsXG4gICAgJy0tY29sb3ItYnJpZGdlLXZlcnNpb24tbnBtLWJhY2tncm91bmQnOiAncmdiYSgwLCAwLCAwLCAwLjI1KScsXG4gICAgJy0tY29sb3ItYnJpZGdlLXZlcnNpb24tbnBtLXRleHQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItYnJpZGdlLXZlcnNpb24tbnVtYmVyJzogJ3llbGxvdycsXG4gICAgJy0tY29sb3ItcHJpbWl0aXZlLWhvb2stYmFkZ2UtYmFja2dyb3VuZCc6ICdyZ2JhKDAsIDAsIDAsIDAuMjUpJyxcbiAgICAnLS1jb2xvci1wcmltaXRpdmUtaG9vay1iYWRnZS10ZXh0JzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KScsXG4gICAgJy0tY29sb3ItcmVjb3JkLWFjdGl2ZSc6ICcjZmMzYTRiJyxcbiAgICAnLS1jb2xvci1yZWNvcmQtaG92ZXInOiAnI2EyZTlmYycsXG4gICAgJy0tY29sb3ItcmVjb3JkLWluYWN0aXZlJzogJyM2MWRhZmInLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXInOiAnIzI4MmMzNCcsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1hY3RpdmUnOiAnIzMxMzYzZicsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1ib3JkZXInOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1kb3QnOiAnI2NmZDFkNScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtaW50ZXJuYWwtbW9kdWxlJzogJyMzMDM1NDInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLWludGVybmFsLW1vZHVsZS1ob3Zlcic6ICcjMzYzYjRhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1pbnRlcm5hbC1tb2R1bGUtdGV4dCc6ICcjN2Y4ODk5JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uYXRpdmUtZXZlbnQnOiAnI2IyYjJiMicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmF0aXZlLWV2ZW50LWhvdmVyJzogJyM5NDk0OTQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstcHJpbWFyeSc6ICcjZmNmM2RjJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXByaW1hcnktaG92ZXInOiAnI2UzZGJjNScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1zZWNvbmRhcnknOiAnI2VmYzQ1NycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1zZWNvbmRhcnktaG92ZXInOiAnI2Q2YWY0ZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcHJpb3JpdHktYmFja2dyb3VuZCc6ICcjMWQyMTI5JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1wcmlvcml0eS1ib3JkZXInOiAnIzI4MmMzNCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdXNlci10aW1pbmcnOiAnI2M5Y2FjZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdXNlci10aW1pbmctaG92ZXInOiAnIzkzOTU5YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtaWRsZSc6ICcjM2Q0ODViJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1pZGxlLWhvdmVyJzogJyM0NjUyNjknLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXJlbmRlcic6ICcjMjY4M0UyJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1yZW5kZXItaG92ZXInOiAnIzFhNzZkNCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcmVuZGVyLXRleHQnOiAnIzExMzY1ZScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtY29tbWl0JzogJyM3MzFmYWQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWNvbW1pdC1ob3Zlcic6ICcjNjExYjk0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1jb21taXQtdGV4dCc6ICcjZTVjMWZmJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1sYXlvdXQtZWZmZWN0cyc6ICcjNjExYjk0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1sYXlvdXQtZWZmZWN0cy1ob3Zlcic6ICcjNTExNjdhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1sYXlvdXQtZWZmZWN0cy10ZXh0JzogJyNlNWMxZmYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXBhc3NpdmUtZWZmZWN0cyc6ICcjNjExYjk0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1wYXNzaXZlLWVmZmVjdHMtaG92ZXInOiAnIzUxMTY3YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcGFzc2l2ZS1lZmZlY3RzLXRleHQnOiAnI2U1YzFmZicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc2NoZWR1bGUnOiAnIzI2ODNFMicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc2NoZWR1bGUtaG92ZXInOiAnIzFhNzZkNCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVqZWN0ZWQnOiAnI2YxY2MxNCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVqZWN0ZWQtaG92ZXInOiAnI2U0YzAwZicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVzb2x2ZWQnOiAnI2E2ZTU5ZicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVzb2x2ZWQtaG92ZXInOiAnIzg5ZDI4MScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtdW5yZXNvbHZlZCc6ICcjYzljYWNkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS11bnJlc29sdmVkLWhvdmVyJzogJyM5Mzk1OWEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRocm93bi1lcnJvcic6ICcjZmIzNjU1JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10aHJvd24tZXJyb3ItaG92ZXInOiAnI2Y4MjA0MicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGV4dC1jb2xvcic6ICcjMjgyYzM0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10ZXh0LWRpbS1jb2xvcic6ICcjNTU1YjY2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC13b3JrLWJvcmRlcic6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1zZWFyY2gtbWF0Y2gnOiAneWVsbG93JyxcbiAgICAnLS1jb2xvci1zZWFyY2gtbWF0Y2gtY3VycmVudCc6ICcjZjc5MjNiJyxcbiAgICAnLS1jb2xvci1zZWxlY3RlZC10cmVlLWhpZ2hsaWdodC1hY3RpdmUnOiAncmdiYSgyMywgMTQzLCAxODUsIDAuMTUpJyxcbiAgICAnLS1jb2xvci1zZWxlY3RlZC10cmVlLWhpZ2hsaWdodC1pbmFjdGl2ZSc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDUpJyxcbiAgICAnLS1jb2xvci1zY3JvbGwtY2FyZXQnOiAnIzRmNTc2NicsXG4gICAgJy0tY29sb3Itc2hhZG93JzogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgJy0tY29sb3ItdGFiLXNlbGVjdGVkLWJvcmRlcic6ICcjMTc4ZmI5JyxcbiAgICAnLS1jb2xvci10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXRleHQtaW52YWxpZCc6ICcjZmY4MDgwJyxcbiAgICAnLS1jb2xvci10ZXh0LXNlbGVjdGVkJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLWludmFsaWQnOiAnI2ZjM2E0YicsXG4gICAgJy0tY29sb3ItdG9nZ2xlLWJhY2tncm91bmQtb24nOiAnIzE3OGZiOScsXG4gICAgJy0tY29sb3ItdG9nZ2xlLWJhY2tncm91bmQtb2ZmJzogJyM3NzdkODgnLFxuICAgICctLWNvbG9yLXRvZ2dsZS10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXdhcm5pbmctYmFja2dyb3VuZCc6ICcjZWUxNjM4JyxcbiAgICAnLS1jb2xvci13YXJuaW5nLWJhY2tncm91bmQtaG92ZXInOiAnI2RhMTAzMCcsXG4gICAgJy0tY29sb3Itd2FybmluZy10ZXh0LWNvbG9yJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXdhcm5pbmctdGV4dC1jb2xvci1pbnZlcnRlZCc6ICcjZWUxNjM4JyxcblxuICAgIC8vIFRoZSBzdHlsZXMgYmVsb3cgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoICdyb290LmNzcydcbiAgICAvLyBUaGV5IGFyZSByZXBlYXRlZCB0aGVyZSBiZWNhdXNlIHRoZXkncmUgdXNlZCBieSBlLmcuIHRvb2x0aXBzIG9yIGNvbnRleHQgbWVudXNcbiAgICAvLyB3aGljaCBnZXQgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgRE9NIHN1YnRyZWUgKHdoZXJlIG5vcm1hbCB0aGVtZS9zdHlsZXMgYXJlIHdyaXR0ZW4pLlxuICAgICctLWNvbG9yLXNjcm9sbC10aHVtYic6ICcjYWZiM2I5JyxcbiAgICAnLS1jb2xvci1zY3JvbGwtdHJhY2snOiAnIzMxMzY0MCcsXG4gICAgJy0tY29sb3ItdG9vbHRpcC1iYWNrZ3JvdW5kJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSknLFxuICAgICctLWNvbG9yLXRvb2x0aXAtdGV4dCc6ICcjMDAwMDAwJyxcbiAgfSxcbiAgY29tcGFjdDoge1xuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2Utc21hbGwnOiAnOXB4JyxcbiAgICAnLS1mb250LXNpemUtbW9ub3NwYWNlLW5vcm1hbCc6ICcxMXB4JyxcbiAgICAnLS1mb250LXNpemUtbW9ub3NwYWNlLWxhcmdlJzogJzE1cHgnLFxuICAgICctLWZvbnQtc2l6ZS1zYW5zLXNtYWxsJzogJzEwcHgnLFxuICAgICctLWZvbnQtc2l6ZS1zYW5zLW5vcm1hbCc6ICcxMnB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1sYXJnZSc6ICcxNHB4JyxcbiAgICAnLS1saW5lLWhlaWdodC1kYXRhJzogJzE4cHgnLFxuICB9LFxuICBjb21mb3J0YWJsZToge1xuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2Utc21hbGwnOiAnMTBweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1ub3JtYWwnOiAnMTNweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1sYXJnZSc6ICcxN3B4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1zbWFsbCc6ICcxMnB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1ub3JtYWwnOiAnMTRweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtbGFyZ2UnOiAnMTZweCcsXG4gICAgJy0tbGluZS1oZWlnaHQtZGF0YSc6ICcyMnB4JyxcbiAgfSxcbn07XG5cbi8vIEhBQ0tcbi8vXG4vLyBTb21ldGltZXMgdGhlIGlubGluZSB0YXJnZXQgaXMgcmVuZGVyZWQgYmVmb3JlIHJvb3Qgc3R5bGVzIGFyZSBhcHBsaWVkLFxuLy8gd2hpY2ggd291bGQgcmVzdWx0IGluIGUuZy4gTmFOIGl0ZW1TaXplIGJlaW5nIHBhc3NlZCB0byByZWFjdC13aW5kb3cgbGlzdC5cbmNvbnN0IENPTUZPUlRBQkxFX0xJTkVfSEVJR0hUID0gcGFyc2VJbnQoXG4gIFRIRU1FX1NUWUxFUy5jb21mb3J0YWJsZVsnLS1saW5lLWhlaWdodC1kYXRhJ10sXG4gIDEwLFxuKTtcbmNvbnN0IENPTVBBQ1RfTElORV9IRUlHSFQgPSBwYXJzZUludChcbiAgVEhFTUVfU1RZTEVTLmNvbXBhY3RbJy0tbGluZS1oZWlnaHQtZGF0YSddLFxuICAxMCxcbik7XG5cbmV4cG9ydCB7Q09NRk9SVEFCTEVfTElORV9IRUlHSFQsIENPTVBBQ1RfTElORV9IRUlHSFR9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBRUE7QUFHQTtBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlJQTtBQWdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0lBO0FBaUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQTNTQTtBQXVUQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/constants.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/hydration.js":
/*!*************************************************!*\
  !*** ../react-devtools-shared/src/hydration.js ***!
  \*************************************************/
/*! exports provided: meta, dehydrate, fillInPath, hydrate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"meta\", function() { return meta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dehydrate\", function() { return dehydrate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fillInPath\", function() { return fillInPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return hydrate; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"../react-devtools-shared/src/utils.js\");\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst meta = {\n  inspectable: Symbol('inspectable'),\n  inspected: Symbol('inspected'),\n  name: Symbol('name'),\n  preview_long: Symbol('preview_long'),\n  preview_short: Symbol('preview_short'),\n  readonly: Symbol('readonly'),\n  size: Symbol('size'),\n  type: Symbol('type'),\n  unserializable: Symbol('unserializable')\n};\n// This threshold determines the depth at which the bridge \"dehydrates\" nested data.\n// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,\n// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).\n//\n// Reducing this threshold will improve the speed of initial component inspection,\n// but may decrease the responsiveness of expanding objects/arrays to inspect further.\nconst LEVEL_THRESHOLD = 2;\n/**\n * Generate the dehydrated metadata for complex object instances\n */\n\nfunction createDehydrated(type, inspectable, data, cleaned, path) {\n  cleaned.push(path);\n  const dehydrated = {\n    inspectable,\n    type,\n    preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n    preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n    name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name\n  };\n\n  if (type === 'array' || type === 'typed_array') {\n    dehydrated.size = data.length;\n  } else if (type === 'object') {\n    dehydrated.size = Object.keys(data).length;\n  }\n\n  if (type === 'iterator' || type === 'typed_array') {\n    dehydrated.readonly = true;\n  }\n\n  return dehydrated;\n}\n/**\n * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).\n * The paths of the stripped out objects are appended to the `cleaned` list.\n * On the other side of the barrier, the cleaned list is used to \"re-hydrate\" the cleaned representation into\n * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.\n *\n * Input: {\"some\": {\"attr\": fn()}, \"other\": AnInstance}\n * Output: {\n *   \"some\": {\n *     \"attr\": {\"name\": the fn.name, type: \"function\"}\n *   },\n *   \"other\": {\n *     \"name\": \"AnInstance\",\n *     \"type\": \"object\",\n *   },\n * }\n * and cleaned = [[\"some\", \"attr\"], [\"other\"]]\n */\n\n\nfunction dehydrate(data, cleaned, unserializable, path, isPathAllowed, level = 0) {\n  const type = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDataType\"])(data);\n  let isPathAllowedCheck;\n\n  switch (type) {\n    case 'html_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        name: data.tagName,\n        type\n      };\n\n    case 'function':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,\n        type\n      };\n\n    case 'string':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (isPathAllowedCheck) {\n        return data;\n      } else {\n        return data.length <= 500 ? data : data.slice(0, 500) + '...';\n      }\n\n    case 'bigint':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        name: data.toString(),\n        type\n      };\n\n    case 'symbol':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        name: data.toString(),\n        type\n      };\n    // React Elements aren't very inspector-friendly,\n    // and often contain private fields or circular references.\n\n    case 'react_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        name: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDisplayNameForReactElement\"])(data) || 'Unknown',\n        type\n      };\n    // ArrayBuffers error if you try to inspect them.\n\n    case 'array_buffer':\n    case 'data_view':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',\n        size: data.byteLength,\n        type\n      };\n\n    case 'array':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      }\n\n      return data.map((item, i) => dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1));\n\n    case 'html_all_collection':\n    case 'typed_array':\n    case 'iterator':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        const unserializableValue = {\n          unserializable: true,\n          type: type,\n          readonly: true,\n          size: type === 'typed_array' ? data.length : undefined,\n          preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n          preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n          name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name\n        }; // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n\n        Array.from(data).forEach((item, i) => unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1));\n        unserializable.push(path);\n        return unserializableValue;\n      }\n\n    case 'opaque_iterator':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        name: data[Symbol.toStringTag],\n        type\n      };\n\n    case 'date':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        name: data.toString(),\n        type\n      };\n\n    case 'regexp':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"formatDataForPreview\"])(data, true),\n        name: data.toString(),\n        type\n      };\n\n    case 'object':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        const object = {};\n        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getAllEnumerableKeys\"])(data).forEach(key => {\n          const name = key.toString();\n          object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n        });\n        return object;\n      }\n\n    case 'infinity':\n    case 'nan':\n    case 'undefined':\n      // Some values are lossy when sent through a WebSocket.\n      // We dehydrate+rehydrate them to preserve their type.\n      cleaned.push(path);\n      return {\n        type\n      };\n\n    default:\n      return data;\n  }\n}\nfunction fillInPath(object, data, path, value) {\n  const target = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getInObject\"])(object, path);\n\n  if (target != null) {\n    if (!target[meta.unserializable]) {\n      delete target[meta.inspectable];\n      delete target[meta.inspected];\n      delete target[meta.name];\n      delete target[meta.preview_long];\n      delete target[meta.preview_short];\n      delete target[meta.readonly];\n      delete target[meta.size];\n      delete target[meta.type];\n    }\n  }\n\n  if (value !== null && data.unserializable.length > 0) {\n    const unserializablePath = data.unserializable[0];\n    let isMatch = unserializablePath.length === path.length;\n\n    for (let i = 0; i < path.length; i++) {\n      if (path[i] !== unserializablePath[i]) {\n        isMatch = false;\n        break;\n      }\n    }\n\n    if (isMatch) {\n      upgradeUnserializable(value, value);\n    }\n  }\n\n  Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"setInObject\"])(object, path, value);\n}\nfunction hydrate(object, cleaned, unserializable) {\n  cleaned.forEach(path => {\n    const length = path.length;\n    const last = path[length - 1];\n    const parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getInObject\"])(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    const value = parent[last];\n\n    if (!value) {\n      return;\n    } else if (value.type === 'infinity') {\n      parent[last] = Infinity;\n    } else if (value.type === 'nan') {\n      parent[last] = NaN;\n    } else if (value.type === 'undefined') {\n      parent[last] = undefined;\n    } else {\n      // Replace the string keys with Symbols so they're non-enumerable.\n      const replaced = {};\n      replaced[meta.inspectable] = !!value.inspectable;\n      replaced[meta.inspected] = false;\n      replaced[meta.name] = value.name;\n      replaced[meta.preview_long] = value.preview_long;\n      replaced[meta.preview_short] = value.preview_short;\n      replaced[meta.size] = value.size;\n      replaced[meta.readonly] = !!value.readonly;\n      replaced[meta.type] = value.type;\n      parent[last] = replaced;\n    }\n  });\n  unserializable.forEach(path => {\n    const length = path.length;\n    const last = path[length - 1];\n    const parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getInObject\"])(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    const node = parent[last];\n    const replacement = { ...node\n    };\n    upgradeUnserializable(replacement, node);\n    parent[last] = replacement;\n  });\n  return object;\n}\n\nfunction upgradeUnserializable(destination, source) {\n  Object.defineProperties(destination, {\n    [meta.inspected]: {\n      configurable: true,\n      enumerable: false,\n      value: !!source.inspected\n    },\n    [meta.name]: {\n      configurable: true,\n      enumerable: false,\n      value: source.name\n    },\n    [meta.preview_long]: {\n      configurable: true,\n      enumerable: false,\n      value: source.preview_long\n    },\n    [meta.preview_short]: {\n      configurable: true,\n      enumerable: false,\n      value: source.preview_short\n    },\n    [meta.size]: {\n      configurable: true,\n      enumerable: false,\n      value: source.size\n    },\n    [meta.readonly]: {\n      configurable: true,\n      enumerable: false,\n      value: !!source.readonly\n    },\n    [meta.type]: {\n      configurable: true,\n      enumerable: false,\n      value: source.type\n    },\n    [meta.unserializable]: {\n      configurable: true,\n      enumerable: false,\n      value: !!source.unserializable\n    }\n  });\n  delete destination.inspected;\n  delete destination.name;\n  delete destination.preview_long;\n  delete destination.preview_short;\n  delete destination.size;\n  delete destination.readonly;\n  delete destination.type;\n  delete destination.unserializable;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9oeWRyYXRpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9oeWRyYXRpb24uanM/MGI3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHtcbiAgZ2V0RGF0YVR5cGUsXG4gIGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50LFxuICBnZXRBbGxFbnVtZXJhYmxlS2V5cyxcbiAgZ2V0SW5PYmplY3QsXG4gIGZvcm1hdERhdGFGb3JQcmV2aWV3LFxuICBzZXRJbk9iamVjdCxcbn0gZnJvbSAnLi91dGlscyc7XG5cbmltcG9ydCB0eXBlIHtEZWh5ZHJhdGVkRGF0YX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy92aWV3cy9Db21wb25lbnRzL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IG1ldGEgPSB7XG4gIGluc3BlY3RhYmxlOiBTeW1ib2woJ2luc3BlY3RhYmxlJyksXG4gIGluc3BlY3RlZDogU3ltYm9sKCdpbnNwZWN0ZWQnKSxcbiAgbmFtZTogU3ltYm9sKCduYW1lJyksXG4gIHByZXZpZXdfbG9uZzogU3ltYm9sKCdwcmV2aWV3X2xvbmcnKSxcbiAgcHJldmlld19zaG9ydDogU3ltYm9sKCdwcmV2aWV3X3Nob3J0JyksXG4gIHJlYWRvbmx5OiBTeW1ib2woJ3JlYWRvbmx5JyksXG4gIHNpemU6IFN5bWJvbCgnc2l6ZScpLFxuICB0eXBlOiBTeW1ib2woJ3R5cGUnKSxcbiAgdW5zZXJpYWxpemFibGU6IFN5bWJvbCgndW5zZXJpYWxpemFibGUnKSxcbn07XG5cbmV4cG9ydCB0eXBlIERlaHlkcmF0ZWQgPSB7fFxuICBpbnNwZWN0YWJsZTogYm9vbGVhbixcbiAgbmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgcHJldmlld19sb25nOiBzdHJpbmcgfCBudWxsLFxuICBwcmV2aWV3X3Nob3J0OiBzdHJpbmcgfCBudWxsLFxuICByZWFkb25seT86IGJvb2xlYW4sXG4gIHNpemU/OiBudW1iZXIsXG4gIHR5cGU6IHN0cmluZyxcbnx9O1xuXG4vLyBUeXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbXBsZXggaXRlcmF0YWJsZSBvYmplY3RzIChlLmcuIE1hcCwgU2V0LCBJbW11dGFibGVKUykgbmVlZCBzcGVjaWFsIGhhbmRsaW5nLlxuLy8gVGhlc2Ugb2JqZWN0cyBjYW4ndCBiZSBzZXJpYWxpemVkIHdpdGhvdXQgbG9zaW5nIHR5cGUgaW5mb3JtYXRpb24sXG4vLyBzbyBhIFwiVW5zZXJpYWxpemFibGVcIiB0eXBlIHdyYXBwZXIgaXMgdXNlZCAod2l0aCBtZXRhLWRhdGEga2V5cykgdG8gc2VuZCBuZXN0ZWQgdmFsdWVzLVxuLy8gd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgdHlwZSBhbmQgbmFtZS5cbmV4cG9ydCB0eXBlIFVuc2VyaWFsaXphYmxlID0ge1xuICBuYW1lOiBzdHJpbmcgfCBudWxsLFxuICBwcmV2aWV3X2xvbmc6IHN0cmluZyB8IG51bGwsXG4gIHByZXZpZXdfc2hvcnQ6IHN0cmluZyB8IG51bGwsXG4gIHJlYWRvbmx5PzogYm9vbGVhbixcbiAgc2l6ZT86IG51bWJlcixcbiAgdHlwZTogc3RyaW5nLFxuICB1bnNlcmlhbGl6YWJsZTogYm9vbGVhbixcbiAgLi4uXG59O1xuXG4vLyBUaGlzIHRocmVzaG9sZCBkZXRlcm1pbmVzIHRoZSBkZXB0aCBhdCB3aGljaCB0aGUgYnJpZGdlIFwiZGVoeWRyYXRlc1wiIG5lc3RlZCBkYXRhLlxuLy8gRGVoeWRyYXRpb24gbWVhbnMgdGhhdCB3ZSBkb24ndCBzZXJpYWxpemUgdGhlIGRhdGEgZm9yIGUuZy4gcG9zdE1lc3NhZ2Ugb3Igc3RyaW5naWZ5LFxuLy8gdW5sZXNzIHRoZSBmcm9udGVuZCBleHBsaWNpdGx5IHJlcXVlc3RzIGl0IChlLmcuIGEgdXNlciBjbGlja3MgdG8gZXhwYW5kIGEgcHJvcHMgb2JqZWN0KS5cbi8vXG4vLyBSZWR1Y2luZyB0aGlzIHRocmVzaG9sZCB3aWxsIGltcHJvdmUgdGhlIHNwZWVkIG9mIGluaXRpYWwgY29tcG9uZW50IGluc3BlY3Rpb24sXG4vLyBidXQgbWF5IGRlY3JlYXNlIHRoZSByZXNwb25zaXZlbmVzcyBvZiBleHBhbmRpbmcgb2JqZWN0cy9hcnJheXMgdG8gaW5zcGVjdCBmdXJ0aGVyLlxuY29uc3QgTEVWRUxfVEhSRVNIT0xEID0gMjtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgZGVoeWRyYXRlZCBtZXRhZGF0YSBmb3IgY29tcGxleCBvYmplY3QgaW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlaHlkcmF0ZWQoXG4gIHR5cGU6IHN0cmluZyxcbiAgaW5zcGVjdGFibGU6IGJvb2xlYW4sXG4gIGRhdGE6IE9iamVjdCxcbiAgY2xlYW5lZDogQXJyYXk8QXJyYXk8c3RyaW5nIHwgbnVtYmVyPj4sXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4pOiBEZWh5ZHJhdGVkIHtcbiAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuXG4gIGNvbnN0IGRlaHlkcmF0ZWQ6IERlaHlkcmF0ZWQgPSB7XG4gICAgaW5zcGVjdGFibGUsXG4gICAgdHlwZSxcbiAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICBuYW1lOlxuICAgICAgIWRhdGEuY29uc3RydWN0b3IgfHwgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0J1xuICAgICAgICA/ICcnXG4gICAgICAgIDogZGF0YS5jb25zdHJ1Y3Rvci5uYW1lLFxuICB9O1xuXG4gIGlmICh0eXBlID09PSAnYXJyYXknIHx8IHR5cGUgPT09ICd0eXBlZF9hcnJheScpIHtcbiAgICBkZWh5ZHJhdGVkLnNpemUgPSBkYXRhLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGRlaHlkcmF0ZWQuc2l6ZSA9IE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnaXRlcmF0b3InIHx8IHR5cGUgPT09ICd0eXBlZF9hcnJheScpIHtcbiAgICBkZWh5ZHJhdGVkLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZWh5ZHJhdGVkO1xufVxuXG4vKipcbiAqIFN0cmlwIG91dCBjb21wbGV4IGRhdGEgKGluc3RhbmNlcywgZnVuY3Rpb25zLCBhbmQgZGF0YSBuZXN0ZWQgPiBMRVZFTF9USFJFU0hPTEQgbGV2ZWxzIGRlZXApLlxuICogVGhlIHBhdGhzIG9mIHRoZSBzdHJpcHBlZCBvdXQgb2JqZWN0cyBhcmUgYXBwZW5kZWQgdG8gdGhlIGBjbGVhbmVkYCBsaXN0LlxuICogT24gdGhlIG90aGVyIHNpZGUgb2YgdGhlIGJhcnJpZXIsIHRoZSBjbGVhbmVkIGxpc3QgaXMgdXNlZCB0byBcInJlLWh5ZHJhdGVcIiB0aGUgY2xlYW5lZCByZXByZXNlbnRhdGlvbiBpbnRvXG4gKiBhbiBvYmplY3Qgd2l0aCBzeW1ib2xzIGFzIGF0dHJpYnV0ZXMsIHNvIHRoYXQgYSBzYW5pdGl6ZWQgb2JqZWN0IGNhbiBiZSBkaXN0aW5ndWlzaGVkIGZyb20gYSBub3JtYWwgb2JqZWN0LlxuICpcbiAqIElucHV0OiB7XCJzb21lXCI6IHtcImF0dHJcIjogZm4oKX0sIFwib3RoZXJcIjogQW5JbnN0YW5jZX1cbiAqIE91dHB1dDoge1xuICogICBcInNvbWVcIjoge1xuICogICAgIFwiYXR0clwiOiB7XCJuYW1lXCI6IHRoZSBmbi5uYW1lLCB0eXBlOiBcImZ1bmN0aW9uXCJ9XG4gKiAgIH0sXG4gKiAgIFwib3RoZXJcIjoge1xuICogICAgIFwibmFtZVwiOiBcIkFuSW5zdGFuY2VcIixcbiAqICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAqICAgfSxcbiAqIH1cbiAqIGFuZCBjbGVhbmVkID0gW1tcInNvbWVcIiwgXCJhdHRyXCJdLCBbXCJvdGhlclwiXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlaHlkcmF0ZShcbiAgZGF0YTogT2JqZWN0LFxuICBjbGVhbmVkOiBBcnJheTxBcnJheTxzdHJpbmcgfCBudW1iZXI+PixcbiAgdW5zZXJpYWxpemFibGU6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICBpc1BhdGhBbGxvd2VkOiAocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikgPT4gYm9vbGVhbixcbiAgbGV2ZWw/OiBudW1iZXIgPSAwLFxuKTpcbiAgfCBzdHJpbmdcbiAgfCBEZWh5ZHJhdGVkXG4gIHwgVW5zZXJpYWxpemFibGVcbiAgfCBBcnJheTxEZWh5ZHJhdGVkPlxuICB8IEFycmF5PFVuc2VyaWFsaXphYmxlPlxuICB8IHtba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBEZWh5ZHJhdGVkIHwgVW5zZXJpYWxpemFibGUsIC4uLn0ge1xuICBjb25zdCB0eXBlID0gZ2V0RGF0YVR5cGUoZGF0YSk7XG5cbiAgbGV0IGlzUGF0aEFsbG93ZWRDaGVjaztcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdodG1sX2VsZW1lbnQnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudGFnTmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgIH07XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTpcbiAgICAgICAgICB0eXBlb2YgZGF0YS5uYW1lID09PSAnZnVuY3Rpb24nIHx8ICFkYXRhLm5hbWVcbiAgICAgICAgICAgID8gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgOiBkYXRhLm5hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA9IGlzUGF0aEFsbG93ZWQocGF0aCk7XG4gICAgICBpZiAoaXNQYXRoQWxsb3dlZENoZWNrKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoIDw9IDUwMCA/IGRhdGEgOiBkYXRhLnNsaWNlKDAsIDUwMCkgKyAnLi4uJztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIC8vIFJlYWN0IEVsZW1lbnRzIGFyZW4ndCB2ZXJ5IGluc3BlY3Rvci1mcmllbmRseSxcbiAgICAvLyBhbmQgb2Z0ZW4gY29udGFpbiBwcml2YXRlIGZpZWxkcyBvciBjaXJjdWxhciByZWZlcmVuY2VzLlxuICAgIGNhc2UgJ3JlYWN0X2VsZW1lbnQnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50KGRhdGEpIHx8ICdVbmtub3duJyxcbiAgICAgICAgdHlwZSxcbiAgICAgIH07XG5cbiAgICAvLyBBcnJheUJ1ZmZlcnMgZXJyb3IgaWYgeW91IHRyeSB0byBpbnNwZWN0IHRoZW0uXG4gICAgY2FzZSAnYXJyYXlfYnVmZmVyJzpcbiAgICBjYXNlICdkYXRhX3ZpZXcnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IHR5cGUgPT09ICdkYXRhX3ZpZXcnID8gJ0RhdGFWaWV3JyA6ICdBcnJheUJ1ZmZlcicsXG4gICAgICAgIHNpemU6IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgICAgdHlwZSxcbiAgICAgIH07XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuICAgICAgaWYgKGxldmVsID49IExFVkVMX1RIUkVTSE9MRCAmJiAhaXNQYXRoQWxsb3dlZENoZWNrKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWh5ZHJhdGVkKHR5cGUsIHRydWUsIGRhdGEsIGNsZWFuZWQsIHBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGEubWFwKChpdGVtLCBpKSA9PlxuICAgICAgICBkZWh5ZHJhdGUoXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBjbGVhbmVkLFxuICAgICAgICAgIHVuc2VyaWFsaXphYmxlLFxuICAgICAgICAgIHBhdGguY29uY2F0KFtpXSksXG4gICAgICAgICAgaXNQYXRoQWxsb3dlZCxcbiAgICAgICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPyAxIDogbGV2ZWwgKyAxLFxuICAgICAgICApLFxuICAgICAgKTtcblxuICAgIGNhc2UgJ2h0bWxfYWxsX2NvbGxlY3Rpb24nOlxuICAgIGNhc2UgJ3R5cGVkX2FycmF5JzpcbiAgICBjYXNlICdpdGVyYXRvcic6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuICAgICAgaWYgKGxldmVsID49IExFVkVMX1RIUkVTSE9MRCAmJiAhaXNQYXRoQWxsb3dlZENoZWNrKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWh5ZHJhdGVkKHR5cGUsIHRydWUsIGRhdGEsIGNsZWFuZWQsIHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdW5zZXJpYWxpemFibGVWYWx1ZTogVW5zZXJpYWxpemFibGUgPSB7XG4gICAgICAgICAgdW5zZXJpYWxpemFibGU6IHRydWUsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICBzaXplOiB0eXBlID09PSAndHlwZWRfYXJyYXknID8gZGF0YS5sZW5ndGggOiB1bmRlZmluZWQsXG4gICAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgICAgbmFtZTpcbiAgICAgICAgICAgICFkYXRhLmNvbnN0cnVjdG9yIHx8IGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCdcbiAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICA6IGRhdGEuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUUklDS1lcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFsuLi5zcHJlYWRdIHN5bnRheCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICAvLyBUaGlzIHByb2plY3QgdXNlcyBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1zcHJlYWQgaW4gXCJsb29zZVwiIG1vZGUgd2hpY2ggb25seSB3b3JrcyB3aXRoIEFycmF5IHZhbHVlcy5cbiAgICAgICAgLy8gT3RoZXIgdHlwZXMgKGUuZy4gdHlwZWQgYXJyYXlzLCBTZXRzKSB3aWxsIG5vdCBzcHJlYWQgY29ycmVjdGx5LlxuICAgICAgICBBcnJheS5mcm9tKGRhdGEpLmZvckVhY2goXG4gICAgICAgICAgKGl0ZW0sIGkpID0+XG4gICAgICAgICAgICAodW5zZXJpYWxpemFibGVWYWx1ZVtpXSA9IGRlaHlkcmF0ZShcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgY2xlYW5lZCxcbiAgICAgICAgICAgICAgdW5zZXJpYWxpemFibGUsXG4gICAgICAgICAgICAgIHBhdGguY29uY2F0KFtpXSksXG4gICAgICAgICAgICAgIGlzUGF0aEFsbG93ZWQsXG4gICAgICAgICAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA/IDEgOiBsZXZlbCArIDEsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgKTtcblxuICAgICAgICB1bnNlcmlhbGl6YWJsZS5wdXNoKHBhdGgpO1xuXG4gICAgICAgIHJldHVybiB1bnNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb3BhcXVlX2l0ZXJhdG9yJzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhW1N5bWJvbC50b1N0cmluZ1RhZ10sXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuICAgICAgaWYgKGxldmVsID49IExFVkVMX1RIUkVTSE9MRCAmJiAhaXNQYXRoQWxsb3dlZENoZWNrKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWh5ZHJhdGVkKHR5cGUsIHRydWUsIGRhdGEsIGNsZWFuZWQsIHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICAgIGdldEFsbEVudW1lcmFibGVLZXlzKGRhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgb2JqZWN0W25hbWVdID0gZGVoeWRyYXRlKFxuICAgICAgICAgICAgZGF0YVtrZXldLFxuICAgICAgICAgICAgY2xlYW5lZCxcbiAgICAgICAgICAgIHVuc2VyaWFsaXphYmxlLFxuICAgICAgICAgICAgcGF0aC5jb25jYXQoW25hbWVdKSxcbiAgICAgICAgICAgIGlzUGF0aEFsbG93ZWQsXG4gICAgICAgICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPyAxIDogbGV2ZWwgKyAxLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW5maW5pdHknOlxuICAgIGNhc2UgJ25hbic6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIC8vIFNvbWUgdmFsdWVzIGFyZSBsb3NzeSB3aGVuIHNlbnQgdGhyb3VnaCBhIFdlYlNvY2tldC5cbiAgICAgIC8vIFdlIGRlaHlkcmF0ZStyZWh5ZHJhdGUgdGhlbSB0byBwcmVzZXJ2ZSB0aGVpciB0eXBlLlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGxJblBhdGgoXG4gIG9iamVjdDogT2JqZWN0LFxuICBkYXRhOiBEZWh5ZHJhdGVkRGF0YSxcbiAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgdmFsdWU6IGFueSxcbikge1xuICBjb25zdCB0YXJnZXQgPSBnZXRJbk9iamVjdChvYmplY3QsIHBhdGgpO1xuICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICBpZiAoIXRhcmdldFttZXRhLnVuc2VyaWFsaXphYmxlXSkge1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLmluc3BlY3RhYmxlXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5pbnNwZWN0ZWRdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLm5hbWVdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLnByZXZpZXdfbG9uZ107XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEucHJldmlld19zaG9ydF07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEucmVhZG9ubHldO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLnNpemVdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLnR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBkYXRhLnVuc2VyaWFsaXphYmxlLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB1bnNlcmlhbGl6YWJsZVBhdGggPSBkYXRhLnVuc2VyaWFsaXphYmxlWzBdO1xuICAgIGxldCBpc01hdGNoID0gdW5zZXJpYWxpemFibGVQYXRoLmxlbmd0aCA9PT0gcGF0aC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXSAhPT0gdW5zZXJpYWxpemFibGVQYXRoW2ldKSB7XG4gICAgICAgIGlzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc01hdGNoKSB7XG4gICAgICB1cGdyYWRlVW5zZXJpYWxpemFibGUodmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBzZXRJbk9iamVjdChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUoXG4gIG9iamVjdDogYW55LFxuICBjbGVhbmVkOiBBcnJheTxBcnJheTxzdHJpbmcgfCBudW1iZXI+PixcbiAgdW5zZXJpYWxpemFibGU6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuKTogT2JqZWN0IHtcbiAgY2xlYW5lZC5mb3JFYWNoKChwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+KSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgY29uc3QgbGFzdCA9IHBhdGhbbGVuZ3RoIC0gMV07XG4gICAgY29uc3QgcGFyZW50ID0gZ2V0SW5PYmplY3Qob2JqZWN0LCBwYXRoLnNsaWNlKDAsIGxlbmd0aCAtIDEpKTtcbiAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50Lmhhc093blByb3BlcnR5KGxhc3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBwYXJlbnRbbGFzdF07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAnaW5maW5pdHknKSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSBJbmZpbml0eTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICduYW4nKSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSBOYU47XG4gICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcGFyZW50W2xhc3RdID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXBsYWNlIHRoZSBzdHJpbmcga2V5cyB3aXRoIFN5bWJvbHMgc28gdGhleSdyZSBub24tZW51bWVyYWJsZS5cbiAgICAgIGNvbnN0IHJlcGxhY2VkOiB7W2tleTogU3ltYm9sXTogYm9vbGVhbiB8IHN0cmluZywgLi4ufSA9IHt9O1xuICAgICAgcmVwbGFjZWRbbWV0YS5pbnNwZWN0YWJsZV0gPSAhIXZhbHVlLmluc3BlY3RhYmxlO1xuICAgICAgcmVwbGFjZWRbbWV0YS5pbnNwZWN0ZWRdID0gZmFsc2U7XG4gICAgICByZXBsYWNlZFttZXRhLm5hbWVdID0gdmFsdWUubmFtZTtcbiAgICAgIHJlcGxhY2VkW21ldGEucHJldmlld19sb25nXSA9IHZhbHVlLnByZXZpZXdfbG9uZztcbiAgICAgIHJlcGxhY2VkW21ldGEucHJldmlld19zaG9ydF0gPSB2YWx1ZS5wcmV2aWV3X3Nob3J0O1xuICAgICAgcmVwbGFjZWRbbWV0YS5zaXplXSA9IHZhbHVlLnNpemU7XG4gICAgICByZXBsYWNlZFttZXRhLnJlYWRvbmx5XSA9ICEhdmFsdWUucmVhZG9ubHk7XG4gICAgICByZXBsYWNlZFttZXRhLnR5cGVdID0gdmFsdWUudHlwZTtcblxuICAgICAgcGFyZW50W2xhc3RdID0gcmVwbGFjZWQ7XG4gICAgfVxuICB9KTtcbiAgdW5zZXJpYWxpemFibGUuZm9yRWFjaCgocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3QgPSBwYXRoW2xlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC5oYXNPd25Qcm9wZXJ0eShsYXN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBwYXJlbnRbbGFzdF07XG5cbiAgICBjb25zdCByZXBsYWNlbWVudCA9IHtcbiAgICAgIC4uLm5vZGUsXG4gICAgfTtcblxuICAgIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZShyZXBsYWNlbWVudCwgbm9kZSk7XG5cbiAgICBwYXJlbnRbbGFzdF0gPSByZXBsYWNlbWVudDtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZShkZXN0aW5hdGlvbjogT2JqZWN0LCBzb3VyY2U6IE9iamVjdCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkZXN0aW5hdGlvbiwge1xuICAgIFttZXRhLmluc3BlY3RlZF06IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6ICEhc291cmNlLmluc3BlY3RlZCxcbiAgICB9LFxuICAgIFttZXRhLm5hbWVdOiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2UubmFtZSxcbiAgICB9LFxuICAgIFttZXRhLnByZXZpZXdfbG9uZ106IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZS5wcmV2aWV3X2xvbmcsXG4gICAgfSxcbiAgICBbbWV0YS5wcmV2aWV3X3Nob3J0XToge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlLnByZXZpZXdfc2hvcnQsXG4gICAgfSxcbiAgICBbbWV0YS5zaXplXToge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlLnNpemUsXG4gICAgfSxcbiAgICBbbWV0YS5yZWFkb25seV06IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6ICEhc291cmNlLnJlYWRvbmx5LFxuICAgIH0sXG4gICAgW21ldGEudHlwZV06IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZS50eXBlLFxuICAgIH0sXG4gICAgW21ldGEudW5zZXJpYWxpemFibGVdOiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiAhIXNvdXJjZS51bnNlcmlhbGl6YWJsZSxcbiAgICB9LFxuICB9KTtcblxuICBkZWxldGUgZGVzdGluYXRpb24uaW5zcGVjdGVkO1xuICBkZWxldGUgZGVzdGluYXRpb24ubmFtZTtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnByZXZpZXdfbG9uZztcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnByZXZpZXdfc2hvcnQ7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi5zaXplO1xuICBkZWxldGUgZGVzdGluYXRpb24ucmVhZG9ubHk7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi50eXBlO1xuICBkZWxldGUgZGVzdGluYXRpb24udW5zZXJpYWxpemFibGU7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7OztBQVNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFjQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQW5NQTtBQXFNQTtBQUVBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFwQ0E7QUEyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/hydration.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/isArray.js":
/*!***********************************************!*\
  !*** ../react-devtools-shared/src/isArray.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst isArray = Array.isArray;\n/* harmony default export */ __webpack_exports__[\"default\"] = (isArray);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9pc0FycmF5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvaXNBcnJheS5qcz9hNDk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7Ozs7Ozs7QUFTQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/isArray.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/storage.js":
/*!***********************************************!*\
  !*** ../react-devtools-shared/src/storage.js ***!
  \***********************************************/
/*! exports provided: localStorageGetItem, localStorageRemoveItem, localStorageSetItem, sessionStorageGetItem, sessionStorageRemoveItem, sessionStorageSetItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"localStorageGetItem\", function() { return localStorageGetItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"localStorageRemoveItem\", function() { return localStorageRemoveItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"localStorageSetItem\", function() { return localStorageSetItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sessionStorageGetItem\", function() { return sessionStorageGetItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sessionStorageRemoveItem\", function() { return sessionStorageRemoveItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sessionStorageSetItem\", function() { return sessionStorageSetItem; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction localStorageGetItem(key) {\n  try {\n    return localStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction localStorageRemoveItem(key) {\n  try {\n    localStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction localStorageSetItem(key, value) {\n  try {\n    return localStorage.setItem(key, value);\n  } catch (error) {}\n}\nfunction sessionStorageGetItem(key) {\n  try {\n    return sessionStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction sessionStorageRemoveItem(key) {\n  try {\n    sessionStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction sessionStorageSetItem(key, value) {\n  try {\n    return sessionStorage.setItem(key, value);\n  } catch (error) {}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zdG9yYWdlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvc3RvcmFnZS5qcz85NGU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxTdG9yYWdlR2V0SXRlbShrZXk6IHN0cmluZyk6IGFueSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsU3RvcmFnZVJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsU3RvcmFnZVNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vzc2lvblN0b3JhZ2VHZXRJdGVtKGtleTogc3RyaW5nKTogYW55IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXNzaW9uU3RvcmFnZVJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vzc2lvblN0b3JhZ2VTZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/storage.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/types.js":
/*!*********************************************!*\
  !*** ../react-devtools-shared/src/types.js ***!
  \*********************************************/
/*! exports provided: ElementTypeClass, ElementTypeContext, ElementTypeFunction, ElementTypeForwardRef, ElementTypeHostComponent, ElementTypeMemo, ElementTypeOtherOrUnknown, ElementTypeProfiler, ElementTypeRoot, ElementTypeSuspense, ElementTypeSuspenseList, ComponentFilterElementType, ComponentFilterDisplayName, ComponentFilterLocation, ComponentFilterHOC, StrictMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeClass\", function() { return ElementTypeClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeContext\", function() { return ElementTypeContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeFunction\", function() { return ElementTypeFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeForwardRef\", function() { return ElementTypeForwardRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeHostComponent\", function() { return ElementTypeHostComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeMemo\", function() { return ElementTypeMemo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeOtherOrUnknown\", function() { return ElementTypeOtherOrUnknown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeProfiler\", function() { return ElementTypeProfiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeRoot\", function() { return ElementTypeRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeSuspense\", function() { return ElementTypeSuspense; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementTypeSuspenseList\", function() { return ElementTypeSuspenseList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentFilterElementType\", function() { return ComponentFilterElementType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentFilterDisplayName\", function() { return ComponentFilterDisplayName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentFilterLocation\", function() { return ComponentFilterLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentFilterHOC\", function() { return ComponentFilterHOC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StrictMode\", function() { return StrictMode; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new element types are added, use new numbers rather than re-ordering existing ones.\n//\n// Changing these types is also a backwards breaking change for the standalone shell,\n// since the frontend and backend must share the same values-\n// and the backend is embedded in certain environments (like React Native).\nconst ElementTypeClass = 1;\nconst ElementTypeContext = 2;\nconst ElementTypeFunction = 5;\nconst ElementTypeForwardRef = 6;\nconst ElementTypeHostComponent = 7;\nconst ElementTypeMemo = 8;\nconst ElementTypeOtherOrUnknown = 9;\nconst ElementTypeProfiler = 10;\nconst ElementTypeRoot = 11;\nconst ElementTypeSuspense = 12;\nconst ElementTypeSuspenseList = 13; // Different types of elements displayed in the Elements tree.\n// These types may be used to visually distinguish types,\n// or to enable/disable certain functionality.\n\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new filter types are added, use new numbers rather than re-ordering existing ones.\nconst ComponentFilterElementType = 1;\nconst ComponentFilterDisplayName = 2;\nconst ComponentFilterLocation = 3;\nconst ComponentFilterHOC = 4;\nconst StrictMode = 1;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy90eXBlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3R5cGVzLmpzPzM3NGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCB0eXBlIFdhbGwgPSB7fFxuICAvLyBgbGlzdGVuYCByZXR1cm5zIHRoZSBcInVubGlzdGVuXCIgZnVuY3Rpb24uXG4gIGxpc3RlbjogKGZuOiBGdW5jdGlvbikgPT4gRnVuY3Rpb24sXG4gIHNlbmQ6IChldmVudDogc3RyaW5nLCBwYXlsb2FkOiBhbnksIHRyYW5zZmVyYWJsZT86IEFycmF5PGFueT4pID0+IHZvaWQsXG58fTtcblxuLy8gV0FSTklOR1xuLy8gVGhlIHZhbHVlcyBiZWxvdyBhcmUgcmVmZXJlbmNlZCBieSBDb21wb25lbnRGaWx0ZXJzICh3aGljaCBhcmUgc2F2ZWQgdmlhIGxvY2FsU3RvcmFnZSkuXG4vLyBEbyBub3QgY2hhbmdlIHRoZW0gb3IgaXQgd2lsbCBicmVhayBwcmV2aW91c2x5IHNhdmVkIHVzZXIgY3VzdG9taXphdGlvbnMuXG4vLyBJZiBuZXcgZWxlbWVudCB0eXBlcyBhcmUgYWRkZWQsIHVzZSBuZXcgbnVtYmVycyByYXRoZXIgdGhhbiByZS1vcmRlcmluZyBleGlzdGluZyBvbmVzLlxuLy9cbi8vIENoYW5naW5nIHRoZXNlIHR5cGVzIGlzIGFsc28gYSBiYWNrd2FyZHMgYnJlYWtpbmcgY2hhbmdlIGZvciB0aGUgc3RhbmRhbG9uZSBzaGVsbCxcbi8vIHNpbmNlIHRoZSBmcm9udGVuZCBhbmQgYmFja2VuZCBtdXN0IHNoYXJlIHRoZSBzYW1lIHZhbHVlcy1cbi8vIGFuZCB0aGUgYmFja2VuZCBpcyBlbWJlZGRlZCBpbiBjZXJ0YWluIGVudmlyb25tZW50cyAobGlrZSBSZWFjdCBOYXRpdmUpLlxuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlQ2xhc3MgPSAxO1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlQ29udGV4dCA9IDI7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVGdW5jdGlvbiA9IDU7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVGb3J3YXJkUmVmID0gNjtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQgPSA3O1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlTWVtbyA9IDg7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVPdGhlck9yVW5rbm93biA9IDk7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVQcm9maWxlciA9IDEwO1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlUm9vdCA9IDExO1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlU3VzcGVuc2UgPSAxMjtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZVN1c3BlbnNlTGlzdCA9IDEzO1xuXG4vLyBEaWZmZXJlbnQgdHlwZXMgb2YgZWxlbWVudHMgZGlzcGxheWVkIGluIHRoZSBFbGVtZW50cyB0cmVlLlxuLy8gVGhlc2UgdHlwZXMgbWF5IGJlIHVzZWQgdG8gdmlzdWFsbHkgZGlzdGluZ3Vpc2ggdHlwZXMsXG4vLyBvciB0byBlbmFibGUvZGlzYWJsZSBjZXJ0YWluIGZ1bmN0aW9uYWxpdHkuXG5leHBvcnQgdHlwZSBFbGVtZW50VHlwZSA9IDEgfCAyIHwgNSB8IDYgfCA3IHwgOCB8IDkgfCAxMCB8IDExIHwgMTIgfCAxMztcblxuLy8gV0FSTklOR1xuLy8gVGhlIHZhbHVlcyBiZWxvdyBhcmUgcmVmZXJlbmNlZCBieSBDb21wb25lbnRGaWx0ZXJzICh3aGljaCBhcmUgc2F2ZWQgdmlhIGxvY2FsU3RvcmFnZSkuXG4vLyBEbyBub3QgY2hhbmdlIHRoZW0gb3IgaXQgd2lsbCBicmVhayBwcmV2aW91c2x5IHNhdmVkIHVzZXIgY3VzdG9taXphdGlvbnMuXG4vLyBJZiBuZXcgZmlsdGVyIHR5cGVzIGFyZSBhZGRlZCwgdXNlIG5ldyBudW1iZXJzIHJhdGhlciB0aGFuIHJlLW9yZGVyaW5nIGV4aXN0aW5nIG9uZXMuXG5leHBvcnQgY29uc3QgQ29tcG9uZW50RmlsdGVyRWxlbWVudFR5cGUgPSAxO1xuZXhwb3J0IGNvbnN0IENvbXBvbmVudEZpbHRlckRpc3BsYXlOYW1lID0gMjtcbmV4cG9ydCBjb25zdCBDb21wb25lbnRGaWx0ZXJMb2NhdGlvbiA9IDM7XG5leHBvcnQgY29uc3QgQ29tcG9uZW50RmlsdGVySE9DID0gNDtcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50RmlsdGVyVHlwZSA9IDEgfCAyIHwgMyB8IDQ7XG5cbi8vIEhpZGUgYWxsIGVsZW1lbnRzIG9mIHR5cGVzIGluIHRoaXMgU2V0LlxuLy8gV2UgaGlkZSBob3N0IGNvbXBvbmVudHMgb25seSBieSBkZWZhdWx0LlxuZXhwb3J0IHR5cGUgRWxlbWVudFR5cGVDb21wb25lbnRGaWx0ZXIgPSB7fFxuICBpc0VuYWJsZWQ6IGJvb2xlYW4sXG4gIHR5cGU6IDEsXG4gIHZhbHVlOiBFbGVtZW50VHlwZSxcbnx9O1xuXG4vLyBIaWRlIGFsbCBlbGVtZW50cyB3aXRoIGRpc3BsYXlOYW1lcyBvciBwYXRocyBtYXRjaGluZyBvbmUgb3IgbW9yZSBvZiB0aGUgUmVnRXhwcyBpbiB0aGlzIFNldC5cbi8vIFBhdGggZmlsdGVycyBhcmUgb25seSB1c2VkIHdoZW4gZWxlbWVudHMgaW5jbHVkZSBkZWJ1ZyBzb3VyY2UgbG9jYXRpb24uXG5leHBvcnQgdHlwZSBSZWdFeHBDb21wb25lbnRGaWx0ZXIgPSB7fFxuICBpc0VuYWJsZWQ6IGJvb2xlYW4sXG4gIGlzVmFsaWQ6IGJvb2xlYW4sXG4gIHR5cGU6IDIgfCAzLFxuICB2YWx1ZTogc3RyaW5nLFxufH07XG5cbmV4cG9ydCB0eXBlIEJvb2xlYW5Db21wb25lbnRGaWx0ZXIgPSB7fFxuICBpc0VuYWJsZWQ6IGJvb2xlYW4sXG4gIGlzVmFsaWQ6IGJvb2xlYW4sXG4gIHR5cGU6IDQsXG58fTtcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50RmlsdGVyID1cbiAgfCBCb29sZWFuQ29tcG9uZW50RmlsdGVyXG4gIHwgRWxlbWVudFR5cGVDb21wb25lbnRGaWx0ZXJcbiAgfCBSZWdFeHBDb21wb25lbnRGaWx0ZXI7XG5cbmV4cG9ydCB0eXBlIEhvb2tOYW1lID0gc3RyaW5nIHwgbnVsbDtcbi8vIE1hcCBvZiBob29rIHNvdXJjZSAoXCI8ZmlsZW5hbWU+OjxsaW5lLW51bWJlcj46PGNvbHVtbi1udW1iZXI+XCIpIHRvIG5hbWUuXG4vLyBIb29rIHNvdXJjZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIGhvb2sgaXRzZWxmIGJlY2F1c2UgdGhlIGxhdHRlciBpcyBub3Qgc3RhYmxlIGJldHdlZW4gZWxlbWVudCBpbnNwZWN0aW9ucy5cbi8vIFdlIHVzZSBhIE1hcCByYXRoZXIgdGhhbiBhbiBBcnJheSBiZWNhdXNlIG9mIG5lc3RlZCBob29rcyBhbmQgdHJhdmVyc2FsIG9yZGVyaW5nLlxuZXhwb3J0IHR5cGUgSG9va1NvdXJjZUxvY2F0aW9uS2V5ID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgSG9va05hbWVzID0gTWFwPEhvb2tTb3VyY2VMb2NhdGlvbktleSwgSG9va05hbWU+O1xuXG5leHBvcnQgdHlwZSBMUlVDYWNoZTxLLCBWPiA9IHt8XG4gIGdldDogKGtleTogSykgPT4gVixcbiAgaGFzOiAoa2V5OiBLKSA9PiBib29sZWFuLFxuICByZW1vdmU6IChrZXk6IEspID0+IHZvaWQsXG4gIHJlc2V0OiAoKSA9PiB2b2lkLFxuICBzZXQ6IChrZXk6IEssIHZhbHVlOiBWKSA9PiB2b2lkLFxufH07XG5cbmV4cG9ydCB0eXBlIFN0eWxlWFBsdWdpbiA9IHt8XG4gIHNvdXJjZXM6IEFycmF5PHN0cmluZz4sXG4gIHJlc29sdmVkU3R5bGVzOiBPYmplY3QsXG58fTtcblxuZXhwb3J0IHR5cGUgUGx1Z2lucyA9IHt8XG4gIHN0eWxleDogU3R5bGVYUGx1Z2luIHwgbnVsbCxcbnx9O1xuXG5leHBvcnQgY29uc3QgU3RyaWN0TW9kZSA9IDE7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3REEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/types.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/utils.js":
/*!*********************************************!*\
  !*** ../react-devtools-shared/src/utils.js ***!
  \*********************************************/
/*! exports provided: alphaSortKeys, getAllEnumerableKeys, getDisplayName, getUID, utfDecodeString, utfEncodeString, printOperationsArray, getDefaultComponentFilters, getSavedComponentFilters, saveComponentFilters, getAppendComponentStack, setAppendComponentStack, getBreakOnConsoleErrors, setBreakOnConsoleErrors, getHideConsoleLogsInStrictMode, sethideConsoleLogsInStrictMode, getShowInlineWarningsAndErrors, setShowInlineWarningsAndErrors, getDefaultOpenInEditorURL, getOpenInEditorURL, separateDisplayNameAndHOCs, shallowDiffers, getInObject, deletePathInObject, renamePathInObject, setInObject, getDataType, getDisplayNameForReactElement, formatDataForPreview */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alphaSortKeys\", function() { return alphaSortKeys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAllEnumerableKeys\", function() { return getAllEnumerableKeys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDisplayName\", function() { return getDisplayName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUID\", function() { return getUID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utfDecodeString\", function() { return utfDecodeString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utfEncodeString\", function() { return utfEncodeString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"printOperationsArray\", function() { return printOperationsArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDefaultComponentFilters\", function() { return getDefaultComponentFilters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSavedComponentFilters\", function() { return getSavedComponentFilters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveComponentFilters\", function() { return saveComponentFilters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAppendComponentStack\", function() { return getAppendComponentStack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAppendComponentStack\", function() { return setAppendComponentStack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBreakOnConsoleErrors\", function() { return getBreakOnConsoleErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setBreakOnConsoleErrors\", function() { return setBreakOnConsoleErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHideConsoleLogsInStrictMode\", function() { return getHideConsoleLogsInStrictMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sethideConsoleLogsInStrictMode\", function() { return sethideConsoleLogsInStrictMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getShowInlineWarningsAndErrors\", function() { return getShowInlineWarningsAndErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setShowInlineWarningsAndErrors\", function() { return setShowInlineWarningsAndErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDefaultOpenInEditorURL\", function() { return getDefaultOpenInEditorURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOpenInEditorURL\", function() { return getOpenInEditorURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"separateDisplayNameAndHOCs\", function() { return separateDisplayNameAndHOCs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shallowDiffers\", function() { return shallowDiffers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getInObject\", function() { return getInObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deletePathInObject\", function() { return deletePathInObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renamePathInObject\", function() { return renamePathInObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setInObject\", function() { return setInObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDataType\", function() { return getDataType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDisplayNameForReactElement\", function() { return getDisplayNameForReactElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatDataForPreview\", function() { return formatDataForPreview; });\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ \"../../node_modules/lru-cache/index.js\");\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-is */ \"../../build/oss-experimental/react-is/index.js\");\n/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shared/ReactSymbols */ \"../shared/ReactSymbols.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-devtools-shared/src/types */ \"../react-devtools-shared/src/types.js\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage */ \"../react-devtools-shared/src/storage.js\");\n/* harmony import */ var _hydration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hydration */ \"../react-devtools-shared/src/hydration.js\");\n/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./isArray */ \"../react-devtools-shared/src/isArray.js\");\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n\n\nconst cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.\n// Try to reuse the already encoded strings.\n\nconst encodedStringCache = new lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a({\n  max: 1000\n});\nfunction alphaSortKeys(a, b) {\n  if (a.toString() > b.toString()) {\n    return 1;\n  } else if (b.toString() > a.toString()) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\nfunction getAllEnumerableKeys(obj) {\n  const keys = new Set();\n  let current = obj;\n\n  while (current != null) {\n    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];\n    const descriptors = Object.getOwnPropertyDescriptors(current);\n    currentKeys.forEach(key => {\n      // $FlowFixMe: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n      if (descriptors[key].enumerable) {\n        keys.add(key);\n      }\n    });\n    current = Object.getPrototypeOf(current);\n  }\n\n  return keys;\n}\nfunction getDisplayName(type, fallbackName = 'Anonymous') {\n  const nameFromCache = cachedDisplayNames.get(type);\n\n  if (nameFromCache != null) {\n    return nameFromCache;\n  }\n\n  let displayName = fallbackName; // The displayName property is not guaranteed to be a string.\n  // It's only safe to use for our purposes if it's a string.\n  // github.com/facebook/react-devtools/issues/803\n\n  if (typeof type.displayName === 'string') {\n    displayName = type.displayName;\n  } else if (typeof type.name === 'string' && type.name !== '') {\n    displayName = type.name;\n  }\n\n  cachedDisplayNames.set(type, displayName);\n  return displayName;\n}\nlet uidCounter = 0;\nfunction getUID() {\n  return ++uidCounter;\n}\nfunction utfDecodeString(array) {\n  // Avoid spreading the array (e.g. String.fromCodePoint(...array))\n  // Functions arguments are first placed on the stack before the function is called\n  // which throws a RangeError for large arrays.\n  // See github.com/facebook/react/issues/22293\n  let string = '';\n\n  for (let i = 0; i < array.length; i++) {\n    const char = array[i];\n    string += String.fromCodePoint(char);\n  }\n\n  return string;\n}\n\nfunction surrogatePairToCodePoint(charCode1, charCode2) {\n  return ((charCode1 & 0x3ff) << 10) + (charCode2 & 0x3ff) + 0x10000;\n} // Credit for this encoding approach goes to Tim Down:\n// https://stackoverflow.com/questions/4877326/how-can-i-tell-if-a-string-contains-multibyte-characters-in-javascript\n\n\nfunction utfEncodeString(string) {\n  const cached = encodedStringCache.get(string);\n\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const encoded = [];\n  let i = 0;\n  let charCode;\n\n  while (i < string.length) {\n    charCode = string.charCodeAt(i); // Handle multibyte unicode characters (like emoji).\n\n    if ((charCode & 0xf800) === 0xd800) {\n      encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));\n    } else {\n      encoded.push(charCode);\n    }\n\n    ++i;\n  }\n\n  encodedStringCache.set(string, encoded);\n  return encoded;\n}\nfunction printOperationsArray(operations) {\n  // The first two values are always rendererID and rootID\n  const rendererID = operations[0];\n  const rootID = operations[1];\n  const logs = [`operations for renderer:${rendererID} and root:${rootID}`];\n  let i = 2; // Reassemble the string table.\n\n  const stringTable = [null // ID = 0 corresponds to the null string.\n  ];\n  const stringTableSize = operations[i++];\n  const stringTableEnd = i + stringTableSize;\n\n  while (i < stringTableEnd) {\n    const nextLength = operations[i++];\n    const nextString = utfDecodeString(operations.slice(i, i + nextLength));\n    stringTable.push(nextString);\n    i += nextLength;\n  }\n\n  while (i < operations.length) {\n    const operation = operations[i];\n\n    switch (operation) {\n      case _constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_ADD\"]:\n        {\n          const id = operations[i + 1];\n          const type = operations[i + 2];\n          i += 3;\n\n          if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[\"ElementTypeRoot\"]) {\n            logs.push(`Add new root node ${id}`);\n            i++; // isStrictModeCompliant\n\n            i++; // supportsProfiling\n\n            i++; // supportsStrictMode\n\n            i++; // hasOwnerMetadata\n          } else {\n            const parentID = operations[i];\n            i++;\n            i++; // ownerID\n\n            const displayNameStringID = operations[i];\n            const displayName = stringTable[displayNameStringID];\n            i++;\n            i++; // key\n\n            logs.push(`Add node ${id} (${displayName || 'null'}) as child of ${parentID}`);\n          }\n\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_REMOVE\"]:\n        {\n          const removeLength = operations[i + 1];\n          i += 2;\n\n          for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {\n            const id = operations[i];\n            i += 1;\n            logs.push(`Remove node ${id}`);\n          }\n\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_REMOVE_ROOT\"]:\n        {\n          i += 1;\n          logs.push(`Remove root ${rootID}`);\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_SET_SUBTREE_MODE\"]:\n        {\n          const id = operations[i + 1];\n          const mode = operations[i + 1];\n          i += 3;\n          logs.push(`Mode ${mode} set for subtree with root ${id}`);\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_REORDER_CHILDREN\"]:\n        {\n          const id = operations[i + 1];\n          const numChildren = operations[i + 2];\n          i += 3;\n          const children = operations.slice(i, i + numChildren);\n          i += numChildren;\n          logs.push(`Re-order node ${id} children ${children.join(',')}`);\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_UPDATE_TREE_BASE_DURATION\"]:\n        // Base duration updates are only sent while profiling is in progress.\n        // We can ignore them at this point.\n        // The profiler UI uses them lazily in order to generate the tree.\n        i += 3;\n        break;\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__[\"TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS\"]:\n        const id = operations[i + 1];\n        const numErrors = operations[i + 2];\n        const numWarnings = operations[i + 3];\n        i += 4;\n        logs.push(`Node ${id} has ${numErrors} errors and ${numWarnings} warnings`);\n        break;\n\n      default:\n        throw Error(`Unsupported Bridge operation \"${operation}\"`);\n    }\n  }\n\n  console.log(logs.join('\\n  '));\n}\nfunction getDefaultComponentFilters() {\n  return [{\n    type: react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[\"ComponentFilterElementType\"],\n    value: react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[\"ElementTypeHostComponent\"],\n    isEnabled: true\n  }];\n}\nfunction getSavedComponentFilters() {\n  try {\n    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_FILTER_PREFERENCES_KEY\"]);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return getDefaultComponentFilters();\n}\nfunction saveComponentFilters(componentFilters) {\n  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_FILTER_PREFERENCES_KEY\"], JSON.stringify(componentFilters));\n}\nfunction getAppendComponentStack() {\n  try {\n    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY\"]);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return true;\n}\nfunction setAppendComponentStack(value) {\n  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY\"], JSON.stringify(value));\n}\nfunction getBreakOnConsoleErrors() {\n  try {\n    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS\"]);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return false;\n}\nfunction setBreakOnConsoleErrors(value) {\n  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS\"], JSON.stringify(value));\n}\nfunction getHideConsoleLogsInStrictMode() {\n  try {\n    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE\"]);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return false;\n}\nfunction sethideConsoleLogsInStrictMode(value) {\n  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE\"], JSON.stringify(value));\n}\nfunction getShowInlineWarningsAndErrors() {\n  try {\n    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY\"]);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return true;\n}\nfunction setShowInlineWarningsAndErrors(value) {\n  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageSetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY\"], JSON.stringify(value));\n}\nfunction getDefaultOpenInEditorURL() {\n  return typeof null === 'string' ? null : '';\n}\nfunction getOpenInEditorURL() {\n  try {\n    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"localStorageGetItem\"])(_constants__WEBPACK_IMPORTED_MODULE_3__[\"LOCAL_STORAGE_OPEN_IN_EDITOR_URL\"]);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return getDefaultOpenInEditorURL();\n}\nfunction separateDisplayNameAndHOCs(displayName, type) {\n  if (displayName === null) {\n    return [null, null];\n  }\n\n  let hocDisplayNames = null;\n\n  switch (type) {\n    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[\"ElementTypeClass\"]:\n    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[\"ElementTypeForwardRef\"]:\n    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[\"ElementTypeFunction\"]:\n    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[\"ElementTypeMemo\"]:\n      if (displayName.indexOf('(') >= 0) {\n        const matches = displayName.match(/[^()]+/g);\n\n        if (matches != null) {\n          displayName = matches.pop();\n          hocDisplayNames = matches;\n        }\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[\"ElementTypeMemo\"]) {\n    if (hocDisplayNames === null) {\n      hocDisplayNames = ['Memo'];\n    } else {\n      hocDisplayNames.unshift('Memo');\n    }\n  } else if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[\"ElementTypeForwardRef\"]) {\n    if (hocDisplayNames === null) {\n      hocDisplayNames = ['ForwardRef'];\n    } else {\n      hocDisplayNames.unshift('ForwardRef');\n    }\n  }\n\n  return [displayName, hocDisplayNames];\n} // Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\n\nfunction shallowDiffers(prev, next) {\n  for (const attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (const attribute in next) {\n    if (prev[attribute] !== next[attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction getInObject(object, path) {\n  return path.reduce((reduced, attr) => {\n    if (reduced) {\n      if (hasOwnProperty.call(reduced, attr)) {\n        return reduced[attr];\n      }\n\n      if (typeof reduced[Symbol.iterator] === 'function') {\n        // Convert iterable to array and return array[index]\n        //\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        return Array.from(reduced)[attr];\n      }\n    }\n\n    return null;\n  }, object);\n}\nfunction deletePathInObject(object, path) {\n  const length = path.length;\n  const last = path[length - 1];\n\n  if (object != null) {\n    const parent = getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(parent)) {\n        parent.splice(last, 1);\n      } else {\n        delete parent[last];\n      }\n    }\n  }\n}\nfunction renamePathInObject(object, oldPath, newPath) {\n  const length = oldPath.length;\n\n  if (object != null) {\n    const parent = getInObject(object, oldPath.slice(0, length - 1));\n\n    if (parent) {\n      const lastOld = oldPath[length - 1];\n      const lastNew = newPath[length - 1];\n      parent[lastNew] = parent[lastOld];\n\n      if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(parent)) {\n        parent.splice(lastOld, 1);\n      } else {\n        delete parent[lastOld];\n      }\n    }\n  }\n}\nfunction setInObject(object, path, value) {\n  const length = path.length;\n  const last = path[length - 1];\n\n  if (object != null) {\n    const parent = getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      parent[last] = value;\n    }\n  }\n}\n\n/**\n * Get a enhanced/artificial type string based on the object instance\n */\nfunction getDataType(data) {\n  if (data === null) {\n    return 'null';\n  } else if (data === undefined) {\n    return 'undefined';\n  }\n\n  if (Object(react_is__WEBPACK_IMPORTED_MODULE_1__[\"isElement\"])(data)) {\n    return 'react_element';\n  }\n\n  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {\n    return 'html_element';\n  }\n\n  const type = typeof data;\n\n  switch (type) {\n    case 'bigint':\n      return 'bigint';\n\n    case 'boolean':\n      return 'boolean';\n\n    case 'function':\n      return 'function';\n\n    case 'number':\n      if (Number.isNaN(data)) {\n        return 'nan';\n      } else if (!Number.isFinite(data)) {\n        return 'infinity';\n      } else {\n        return 'number';\n      }\n\n    case 'object':\n      if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(data)) {\n        return 'array';\n      } else if (ArrayBuffer.isView(data)) {\n        return hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';\n      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {\n        // HACK This ArrayBuffer check is gross; is there a better way?\n        // We could try to create a new DataView with the value.\n        // If it doesn't error, we know it's an ArrayBuffer,\n        // but this seems kind of awkward and expensive.\n        return 'array_buffer';\n      } else if (typeof data[Symbol.iterator] === 'function') {\n        const iterator = data[Symbol.iterator]();\n\n        if (!iterator) {// Proxies might break assumptoins about iterators.\n          // See github.com/facebook/react/issues/21654\n        } else {\n          return iterator === data ? 'opaque_iterator' : 'iterator';\n        }\n      } else if (data.constructor && data.constructor.name === 'RegExp') {\n        return 'regexp';\n      } else {\n        const toStringValue = Object.prototype.toString.call(data);\n\n        if (toStringValue === '[object Date]') {\n          return 'date';\n        } else if (toStringValue === '[object HTMLAllCollection]') {\n          return 'html_all_collection';\n        }\n      }\n\n      return 'object';\n\n    case 'string':\n      return 'string';\n\n    case 'symbol':\n      return 'symbol';\n\n    case 'undefined':\n      if (Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {\n        return 'html_all_collection';\n      }\n\n      return 'undefined';\n\n    default:\n      return 'unknown';\n  }\n}\nfunction getDisplayNameForReactElement(element) {\n  const elementType = Object(react_is__WEBPACK_IMPORTED_MODULE_1__[\"typeOf\"])(element);\n\n  switch (elementType) {\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"ContextConsumer\"]:\n      return 'ContextConsumer';\n\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"ContextProvider\"]:\n      return 'ContextProvider';\n\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"ForwardRef\"]:\n      return 'ForwardRef';\n\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"]:\n      return 'Fragment';\n\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Lazy\"]:\n      return 'Lazy';\n\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Memo\"]:\n      return 'Memo';\n\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Portal\"]:\n      return 'Portal';\n\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Profiler\"]:\n      return 'Profiler';\n\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"StrictMode\"]:\n      return 'StrictMode';\n\n    case react_is__WEBPACK_IMPORTED_MODULE_1__[\"Suspense\"]:\n      return 'Suspense';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__[\"REACT_SUSPENSE_LIST_TYPE\"]:\n      return 'SuspenseList';\n\n    default:\n      const {\n        type\n      } = element;\n\n      if (typeof type === 'string') {\n        return type;\n      } else if (typeof type === 'function') {\n        return getDisplayName(type, 'Anonymous');\n      } else if (type != null) {\n        return 'NotImplementedInDevtools';\n      } else {\n        return 'Element';\n      }\n\n  }\n}\nconst MAX_PREVIEW_STRING_LENGTH = 50;\n\nfunction truncateForDisplay(string, length = MAX_PREVIEW_STRING_LENGTH) {\n  if (string.length > length) {\n    return string.substr(0, length) + '…';\n  } else {\n    return string;\n  }\n} // Attempts to mimic Chrome's inline preview for values.\n// For example, the following value...\n//   {\n//      foo: 123,\n//      bar: \"abc\",\n//      baz: [true, false],\n//      qux: { ab: 1, cd: 2 }\n//   };\n//\n// Would show a preview of...\n//   {foo: 123, bar: \"abc\", baz: Array(2), qux: {…}}\n//\n// And the following value...\n//   [\n//     123,\n//     \"abc\",\n//     [true, false],\n//     { foo: 123, bar: \"abc\" }\n//   ];\n//\n// Would show a preview of...\n//   [123, \"abc\", Array(2), {…}]\n\n\nfunction formatDataForPreview(data, showFormattedValue) {\n  if (data != null && hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[\"meta\"].type)) {\n    return showFormattedValue ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[\"meta\"].preview_long] : data[_hydration__WEBPACK_IMPORTED_MODULE_6__[\"meta\"].preview_short];\n  }\n\n  const type = getDataType(data);\n\n  switch (type) {\n    case 'html_element':\n      return `<${truncateForDisplay(data.tagName.toLowerCase())} />`;\n\n    case 'function':\n      return truncateForDisplay(`ƒ ${typeof data.name === 'function' ? '' : data.name}() {}`);\n\n    case 'string':\n      return `\"${data}\"`;\n\n    case 'bigint':\n      return truncateForDisplay(data.toString() + 'n');\n\n    case 'regexp':\n      return truncateForDisplay(data.toString());\n\n    case 'symbol':\n      return truncateForDisplay(data.toString());\n\n    case 'react_element':\n      return `<${truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown')} />`;\n\n    case 'array_buffer':\n      return `ArrayBuffer(${data.byteLength})`;\n\n    case 'data_view':\n      return `DataView(${data.buffer.byteLength})`;\n\n    case 'array':\n      if (showFormattedValue) {\n        let formatted = '';\n\n        for (let i = 0; i < data.length; i++) {\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += formatDataForPreview(data[i], false);\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `[${truncateForDisplay(formatted)}]`;\n      } else {\n        const length = hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[\"meta\"].size) ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[\"meta\"].size] : data.length;\n        return `Array(${length})`;\n      }\n\n    case 'typed_array':\n      const shortName = `${data.constructor.name}(${data.length})`;\n\n      if (showFormattedValue) {\n        let formatted = '';\n\n        for (let i = 0; i < data.length; i++) {\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += data[i];\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `${shortName} [${truncateForDisplay(formatted)}]`;\n      } else {\n        return shortName;\n      }\n\n    case 'iterator':\n      const name = data.constructor.name;\n\n      if (showFormattedValue) {\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        const array = Array.from(data);\n        let formatted = '';\n\n        for (let i = 0; i < array.length; i++) {\n          const entryOrEntries = array[i];\n\n          if (i > 0) {\n            formatted += ', ';\n          } // TRICKY\n          // Browsers display Maps and Sets differently.\n          // To mimic their behavior, detect if we've been given an entries tuple.\n          //   Map(2) {\"abc\" => 123, \"def\" => 123}\n          //   Set(2) {\"abc\", 123}\n\n\n          if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(entryOrEntries)) {\n            const key = formatDataForPreview(entryOrEntries[0], true);\n            const value = formatDataForPreview(entryOrEntries[1], false);\n            formatted += `${key} => ${value}`;\n          } else {\n            formatted += formatDataForPreview(entryOrEntries, false);\n          }\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `${name}(${data.size}) {${truncateForDisplay(formatted)}}`;\n      } else {\n        return `${name}(${data.size})`;\n      }\n\n    case 'opaque_iterator':\n      {\n        return data[Symbol.toStringTag];\n      }\n\n    case 'date':\n      return data.toString();\n\n    case 'object':\n      if (showFormattedValue) {\n        const keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);\n        let formatted = '';\n\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += `${key.toString()}: ${formatDataForPreview(data[key], false)}`;\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `{${truncateForDisplay(formatted)}}`;\n      } else {\n        return '{…}';\n      }\n\n    case 'boolean':\n    case 'number':\n    case 'infinity':\n    case 'nan':\n    case 'null':\n    case 'undefined':\n      return data;\n\n    default:\n      try {\n        return truncateForDisplay(String(data));\n      } catch (error) {\n        return 'unserializable';\n      }\n\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy91dGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3V0aWxzLmpzPzY2YTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBMUlUgZnJvbSAnbHJ1LWNhY2hlJztcbmltcG9ydCB7XG4gIGlzRWxlbWVudCxcbiAgdHlwZU9mLFxuICBDb250ZXh0Q29uc3VtZXIsXG4gIENvbnRleHRQcm92aWRlcixcbiAgRm9yd2FyZFJlZixcbiAgRnJhZ21lbnQsXG4gIExhenksXG4gIE1lbW8sXG4gIFBvcnRhbCxcbiAgUHJvZmlsZXIsXG4gIFN0cmljdE1vZGUsXG4gIFN1c3BlbnNlLFxufSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQge1JFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSBhcyBTdXNwZW5zZUxpc3R9IGZyb20gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnO1xuaW1wb3J0IHtcbiAgVFJFRV9PUEVSQVRJT05fQURELFxuICBUUkVFX09QRVJBVElPTl9SRU1PVkUsXG4gIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09ULFxuICBUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOLFxuICBUUkVFX09QRVJBVElPTl9TRVRfU1VCVFJFRV9NT0RFLFxuICBUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTLFxuICBUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge0VsZW1lbnRUeXBlUm9vdH0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy90eXBlcyc7XG5pbXBvcnQge1xuICBMT0NBTF9TVE9SQUdFX0ZJTFRFUl9QUkVGRVJFTkNFU19LRVksXG4gIExPQ0FMX1NUT1JBR0VfT1BFTl9JTl9FRElUT1JfVVJMLFxuICBMT0NBTF9TVE9SQUdFX1NIT1VMRF9CUkVBS19PTl9DT05TT0xFX0VSUk9SUyxcbiAgTE9DQUxfU1RPUkFHRV9TSE9VTERfUEFUQ0hfQ09OU09MRV9LRVksXG4gIExPQ0FMX1NUT1JBR0VfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19LRVksXG4gIExPQ0FMX1NUT1JBR0VfSElERV9DT05TT0xFX0xPR1NfSU5fU1RSSUNUX01PREUsXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Q29tcG9uZW50RmlsdGVyRWxlbWVudFR5cGUsIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBFbGVtZW50VHlwZUNsYXNzLFxuICBFbGVtZW50VHlwZUZvcndhcmRSZWYsXG4gIEVsZW1lbnRUeXBlRnVuY3Rpb24sXG4gIEVsZW1lbnRUeXBlTWVtbyxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy90eXBlcyc7XG5pbXBvcnQge2xvY2FsU3RvcmFnZUdldEl0ZW0sIGxvY2FsU3RvcmFnZVNldEl0ZW19IGZyb20gJy4vc3RvcmFnZSc7XG5pbXBvcnQge21ldGF9IGZyb20gJy4vaHlkcmF0aW9uJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheSc7XG5cbmltcG9ydCB0eXBlIHtDb21wb25lbnRGaWx0ZXIsIEVsZW1lbnRUeXBlfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB0eXBlIHtMUlVDYWNoZX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy90eXBlcyc7XG5cbmNvbnN0IGNhY2hlZERpc3BsYXlOYW1lczogV2Vha01hcDxGdW5jdGlvbiwgc3RyaW5nPiA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIE9uIGxhcmdlIHRyZWVzLCBlbmNvZGluZyB0YWtlcyBzaWduaWZpY2FudCB0aW1lLlxuLy8gVHJ5IHRvIHJldXNlIHRoZSBhbHJlYWR5IGVuY29kZWQgc3RyaW5ncy5cbmNvbnN0IGVuY29kZWRTdHJpbmdDYWNoZTogTFJVQ2FjaGU8c3RyaW5nLCBBcnJheTxudW1iZXI+PiA9IG5ldyBMUlUoe1xuICBtYXg6IDEwMDAsXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFscGhhU29ydEtleXMoXG4gIGE6IHN0cmluZyB8IG51bWJlciB8IFN5bWJvbCxcbiAgYjogc3RyaW5nIHwgbnVtYmVyIHwgU3ltYm9sLFxuKTogbnVtYmVyIHtcbiAgaWYgKGEudG9TdHJpbmcoKSA+IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGIudG9TdHJpbmcoKSA+IGEudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsRW51bWVyYWJsZUtleXMoXG4gIG9iajogT2JqZWN0LFxuKTogU2V0PHN0cmluZyB8IG51bWJlciB8IFN5bWJvbD4ge1xuICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICBsZXQgY3VycmVudCA9IG9iajtcbiAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGN1cnJlbnRLZXlzID0gW1xuICAgICAgLi4uT2JqZWN0LmtleXMoY3VycmVudCksXG4gICAgICAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGN1cnJlbnQpLFxuICAgIF07XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhjdXJyZW50KTtcbiAgICBjdXJyZW50S2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAvLyAkRmxvd0ZpeE1lOiBrZXkgY2FuIGJlIGEgU3ltYm9sIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgIGlmIChkZXNjcmlwdG9yc1trZXldLmVudW1lcmFibGUpIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdXJyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnQpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoXG4gIHR5cGU6IEZ1bmN0aW9uLFxuICBmYWxsYmFja05hbWU6IHN0cmluZyA9ICdBbm9ueW1vdXMnLFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbmFtZUZyb21DYWNoZSA9IGNhY2hlZERpc3BsYXlOYW1lcy5nZXQodHlwZSk7XG4gIGlmIChuYW1lRnJvbUNhY2hlICE9IG51bGwpIHtcbiAgICByZXR1cm4gbmFtZUZyb21DYWNoZTtcbiAgfVxuXG4gIGxldCBkaXNwbGF5TmFtZSA9IGZhbGxiYWNrTmFtZTtcblxuICAvLyBUaGUgZGlzcGxheU5hbWUgcHJvcGVydHkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgYSBzdHJpbmcuXG4gIC8vIEl0J3Mgb25seSBzYWZlIHRvIHVzZSBmb3Igb3VyIHB1cnBvc2VzIGlmIGl0J3MgYSBzdHJpbmcuXG4gIC8vIGdpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtZGV2dG9vbHMvaXNzdWVzLzgwM1xuICBpZiAodHlwZW9mIHR5cGUuZGlzcGxheU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlLm5hbWUgPT09ICdzdHJpbmcnICYmIHR5cGUubmFtZSAhPT0gJycpIHtcbiAgICBkaXNwbGF5TmFtZSA9IHR5cGUubmFtZTtcbiAgfVxuXG4gIGNhY2hlZERpc3BsYXlOYW1lcy5zZXQodHlwZSwgZGlzcGxheU5hbWUpO1xuICByZXR1cm4gZGlzcGxheU5hbWU7XG59XG5cbmxldCB1aWRDb3VudGVyOiBudW1iZXIgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VUlEKCk6IG51bWJlciB7XG4gIHJldHVybiArK3VpZENvdW50ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1dGZEZWNvZGVTdHJpbmcoYXJyYXk6IEFycmF5PG51bWJlcj4pOiBzdHJpbmcge1xuICAvLyBBdm9pZCBzcHJlYWRpbmcgdGhlIGFycmF5IChlLmcuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmFycmF5KSlcbiAgLy8gRnVuY3Rpb25zIGFyZ3VtZW50cyBhcmUgZmlyc3QgcGxhY2VkIG9uIHRoZSBzdGFjayBiZWZvcmUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAvLyB3aGljaCB0aHJvd3MgYSBSYW5nZUVycm9yIGZvciBsYXJnZSBhcnJheXMuXG4gIC8vIFNlZSBnaXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMjI5M1xuICBsZXQgc3RyaW5nID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gYXJyYXlbaV07XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNoYXIpO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHN1cnJvZ2F0ZVBhaXJUb0NvZGVQb2ludChcbiAgY2hhckNvZGUxOiBudW1iZXIsXG4gIGNoYXJDb2RlMjogbnVtYmVyLFxuKTogbnVtYmVyIHtcbiAgcmV0dXJuICgoY2hhckNvZGUxICYgMHgzZmYpIDw8IDEwKSArIChjaGFyQ29kZTIgJiAweDNmZikgKyAweDEwMDAwO1xufVxuXG4vLyBDcmVkaXQgZm9yIHRoaXMgZW5jb2RpbmcgYXBwcm9hY2ggZ29lcyB0byBUaW0gRG93bjpcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4NzczMjYvaG93LWNhbi1pLXRlbGwtaWYtYS1zdHJpbmctY29udGFpbnMtbXVsdGlieXRlLWNoYXJhY3RlcnMtaW4tamF2YXNjcmlwdFxuZXhwb3J0IGZ1bmN0aW9uIHV0ZkVuY29kZVN0cmluZyhzdHJpbmc6IHN0cmluZyk6IEFycmF5PG51bWJlcj4ge1xuICBjb25zdCBjYWNoZWQgPSBlbmNvZGVkU3RyaW5nQ2FjaGUuZ2V0KHN0cmluZyk7XG4gIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cblxuICBjb25zdCBlbmNvZGVkID0gW107XG4gIGxldCBpID0gMDtcbiAgbGV0IGNoYXJDb2RlO1xuICB3aGlsZSAoaSA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICBjaGFyQ29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIEhhbmRsZSBtdWx0aWJ5dGUgdW5pY29kZSBjaGFyYWN0ZXJzIChsaWtlIGVtb2ppKS5cbiAgICBpZiAoKGNoYXJDb2RlICYgMHhmODAwKSA9PT0gMHhkODAwKSB7XG4gICAgICBlbmNvZGVkLnB1c2goc3Vycm9nYXRlUGFpclRvQ29kZVBvaW50KGNoYXJDb2RlLCBzdHJpbmcuY2hhckNvZGVBdCgrK2kpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kZWQucHVzaChjaGFyQ29kZSk7XG4gICAgfVxuICAgICsraTtcbiAgfVxuXG4gIGVuY29kZWRTdHJpbmdDYWNoZS5zZXQoc3RyaW5nLCBlbmNvZGVkKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50T3BlcmF0aW9uc0FycmF5KG9wZXJhdGlvbnM6IEFycmF5PG51bWJlcj4pIHtcbiAgLy8gVGhlIGZpcnN0IHR3byB2YWx1ZXMgYXJlIGFsd2F5cyByZW5kZXJlcklEIGFuZCByb290SURcbiAgY29uc3QgcmVuZGVyZXJJRCA9IG9wZXJhdGlvbnNbMF07XG4gIGNvbnN0IHJvb3RJRCA9IG9wZXJhdGlvbnNbMV07XG5cbiAgY29uc3QgbG9ncyA9IFtgb3BlcmF0aW9ucyBmb3IgcmVuZGVyZXI6JHtyZW5kZXJlcklEfSBhbmQgcm9vdDoke3Jvb3RJRH1gXTtcblxuICBsZXQgaSA9IDI7XG5cbiAgLy8gUmVhc3NlbWJsZSB0aGUgc3RyaW5nIHRhYmxlLlxuICBjb25zdCBzdHJpbmdUYWJsZSA9IFtcbiAgICBudWxsLCAvLyBJRCA9IDAgY29ycmVzcG9uZHMgdG8gdGhlIG51bGwgc3RyaW5nLlxuICBdO1xuICBjb25zdCBzdHJpbmdUYWJsZVNpemUgPSBvcGVyYXRpb25zW2krK107XG4gIGNvbnN0IHN0cmluZ1RhYmxlRW5kID0gaSArIHN0cmluZ1RhYmxlU2l6ZTtcbiAgd2hpbGUgKGkgPCBzdHJpbmdUYWJsZUVuZCkge1xuICAgIGNvbnN0IG5leHRMZW5ndGggPSBvcGVyYXRpb25zW2krK107XG4gICAgY29uc3QgbmV4dFN0cmluZyA9IHV0ZkRlY29kZVN0cmluZyhcbiAgICAgIChvcGVyYXRpb25zLnNsaWNlKGksIGkgKyBuZXh0TGVuZ3RoKTogYW55KSxcbiAgICApO1xuICAgIHN0cmluZ1RhYmxlLnB1c2gobmV4dFN0cmluZyk7XG4gICAgaSArPSBuZXh0TGVuZ3RoO1xuICB9XG5cbiAgd2hpbGUgKGkgPCBvcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbaV07XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9BREQ6IHtcbiAgICAgICAgY29uc3QgaWQgPSAoKG9wZXJhdGlvbnNbaSArIDFdOiBhbnkpOiBudW1iZXIpO1xuICAgICAgICBjb25zdCB0eXBlID0gKChvcGVyYXRpb25zW2kgKyAyXTogYW55KTogRWxlbWVudFR5cGUpO1xuXG4gICAgICAgIGkgKz0gMztcblxuICAgICAgICBpZiAodHlwZSA9PT0gRWxlbWVudFR5cGVSb290KSB7XG4gICAgICAgICAgbG9ncy5wdXNoKGBBZGQgbmV3IHJvb3Qgbm9kZSAke2lkfWApO1xuXG4gICAgICAgICAgaSsrOyAvLyBpc1N0cmljdE1vZGVDb21wbGlhbnRcbiAgICAgICAgICBpKys7IC8vIHN1cHBvcnRzUHJvZmlsaW5nXG4gICAgICAgICAgaSsrOyAvLyBzdXBwb3J0c1N0cmljdE1vZGVcbiAgICAgICAgICBpKys7IC8vIGhhc093bmVyTWV0YWRhdGFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRJRCA9ICgob3BlcmF0aW9uc1tpXTogYW55KTogbnVtYmVyKTtcbiAgICAgICAgICBpKys7XG5cbiAgICAgICAgICBpKys7IC8vIG93bmVySURcblxuICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lU3RyaW5nSUQgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gc3RyaW5nVGFibGVbZGlzcGxheU5hbWVTdHJpbmdJRF07XG4gICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgaSsrOyAvLyBrZXlcblxuICAgICAgICAgIGxvZ3MucHVzaChcbiAgICAgICAgICAgIGBBZGQgbm9kZSAke2lkfSAoJHtkaXNwbGF5TmFtZSB8fCAnbnVsbCd9KSBhcyBjaGlsZCBvZiAke3BhcmVudElEfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fUkVNT1ZFOiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZUxlbmd0aCA9ICgob3BlcmF0aW9uc1tpICsgMV06IGFueSk6IG51bWJlcik7XG4gICAgICAgIGkgKz0gMjtcblxuICAgICAgICBmb3IgKGxldCByZW1vdmVJbmRleCA9IDA7IHJlbW92ZUluZGV4IDwgcmVtb3ZlTGVuZ3RoOyByZW1vdmVJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgaWQgPSAoKG9wZXJhdGlvbnNbaV06IGFueSk6IG51bWJlcik7XG4gICAgICAgICAgaSArPSAxO1xuXG4gICAgICAgICAgbG9ncy5wdXNoKGBSZW1vdmUgbm9kZSAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVDoge1xuICAgICAgICBpICs9IDE7XG5cbiAgICAgICAgbG9ncy5wdXNoKGBSZW1vdmUgcm9vdCAke3Jvb3RJRH1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1NFVF9TVUJUUkVFX01PREU6IHtcbiAgICAgICAgY29uc3QgaWQgPSBvcGVyYXRpb25zW2kgKyAxXTtcbiAgICAgICAgY29uc3QgbW9kZSA9IG9wZXJhdGlvbnNbaSArIDFdO1xuXG4gICAgICAgIGkgKz0gMztcblxuICAgICAgICBsb2dzLnB1c2goYE1vZGUgJHttb2RlfSBzZXQgZm9yIHN1YnRyZWUgd2l0aCByb290ICR7aWR9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOOiB7XG4gICAgICAgIGNvbnN0IGlkID0gKChvcGVyYXRpb25zW2kgKyAxXTogYW55KTogbnVtYmVyKTtcbiAgICAgICAgY29uc3QgbnVtQ2hpbGRyZW4gPSAoKG9wZXJhdGlvbnNbaSArIDJdOiBhbnkpOiBudW1iZXIpO1xuICAgICAgICBpICs9IDM7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gb3BlcmF0aW9ucy5zbGljZShpLCBpICsgbnVtQ2hpbGRyZW4pO1xuICAgICAgICBpICs9IG51bUNoaWxkcmVuO1xuXG4gICAgICAgIGxvZ3MucHVzaChgUmUtb3JkZXIgbm9kZSAke2lkfSBjaGlsZHJlbiAke2NoaWxkcmVuLmpvaW4oJywnKX1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT046XG4gICAgICAgIC8vIEJhc2UgZHVyYXRpb24gdXBkYXRlcyBhcmUgb25seSBzZW50IHdoaWxlIHByb2ZpbGluZyBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgLy8gV2UgY2FuIGlnbm9yZSB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIC8vIFRoZSBwcm9maWxlciBVSSB1c2VzIHRoZW0gbGF6aWx5IGluIG9yZGVyIHRvIGdlbmVyYXRlIHRoZSB0cmVlLlxuICAgICAgICBpICs9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTOlxuICAgICAgICBjb25zdCBpZCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICBjb25zdCBudW1FcnJvcnMgPSBvcGVyYXRpb25zW2kgKyAyXTtcbiAgICAgICAgY29uc3QgbnVtV2FybmluZ3MgPSBvcGVyYXRpb25zW2kgKyAzXTtcblxuICAgICAgICBpICs9IDQ7XG5cbiAgICAgICAgbG9ncy5wdXNoKFxuICAgICAgICAgIGBOb2RlICR7aWR9IGhhcyAke251bUVycm9yc30gZXJyb3JzIGFuZCAke251bVdhcm5pbmdzfSB3YXJuaW5nc2AsXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIEJyaWRnZSBvcGVyYXRpb24gXCIke29wZXJhdGlvbn1cImApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnNvbGUubG9nKGxvZ3Muam9pbignXFxuICAnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycygpOiBBcnJheTxDb21wb25lbnRGaWx0ZXI+IHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB0eXBlOiBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZSxcbiAgICAgIHZhbHVlOiBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQsXG4gICAgICBpc0VuYWJsZWQ6IHRydWUsXG4gICAgfSxcbiAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNhdmVkQ29tcG9uZW50RmlsdGVycygpOiBBcnJheTxDb21wb25lbnRGaWx0ZXI+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2VHZXRJdGVtKExPQ0FMX1NUT1JBR0VfRklMVEVSX1BSRUZFUkVOQ0VTX0tFWSk7XG4gICAgaWYgKHJhdyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gIHJldHVybiBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUNvbXBvbmVudEZpbHRlcnMoXG4gIGNvbXBvbmVudEZpbHRlcnM6IEFycmF5PENvbXBvbmVudEZpbHRlcj4sXG4pOiB2b2lkIHtcbiAgbG9jYWxTdG9yYWdlU2V0SXRlbShcbiAgICBMT0NBTF9TVE9SQUdFX0ZJTFRFUl9QUkVGRVJFTkNFU19LRVksXG4gICAgSlNPTi5zdHJpbmdpZnkoY29tcG9uZW50RmlsdGVycyksXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcHBlbmRDb21wb25lbnRTdGFjaygpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2VHZXRJdGVtKExPQ0FMX1NUT1JBR0VfU0hPVUxEX1BBVENIX0NPTlNPTEVfS0VZKTtcbiAgICBpZiAocmF3ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJhdyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge31cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBcHBlbmRDb21wb25lbnRTdGFjayh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICBsb2NhbFN0b3JhZ2VTZXRJdGVtKFxuICAgIExPQ0FMX1NUT1JBR0VfU0hPVUxEX1BBVENIX0NPTlNPTEVfS0VZLFxuICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJyZWFrT25Db25zb2xlRXJyb3JzKCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZUdldEl0ZW0oXG4gICAgICBMT0NBTF9TVE9SQUdFX1NIT1VMRF9CUkVBS19PTl9DT05TT0xFX0VSUk9SUyxcbiAgICApO1xuICAgIGlmIChyYXcgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRCcmVha09uQ29uc29sZUVycm9ycyh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICBsb2NhbFN0b3JhZ2VTZXRJdGVtKFxuICAgIExPQ0FMX1NUT1JBR0VfU0hPVUxEX0JSRUFLX09OX0NPTlNPTEVfRVJST1JTLFxuICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSgpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2VHZXRJdGVtKFxuICAgICAgTE9DQUxfU1RPUkFHRV9ISURFX0NPTlNPTEVfTE9HU19JTl9TVFJJQ1RfTU9ERSxcbiAgICApO1xuICAgIGlmIChyYXcgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUodmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgbG9jYWxTdG9yYWdlU2V0SXRlbShcbiAgICBMT0NBTF9TVE9SQUdFX0hJREVfQ09OU09MRV9MT0dTX0lOX1NUUklDVF9NT0RFLFxuICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycygpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2VHZXRJdGVtKFxuICAgICAgTE9DQUxfU1RPUkFHRV9TSE9XX0lOTElORV9XQVJOSU5HU19BTkRfRVJST1JTX0tFWSxcbiAgICApO1xuICAgIGlmIChyYXcgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICBsb2NhbFN0b3JhZ2VTZXRJdGVtKFxuICAgIExPQ0FMX1NUT1JBR0VfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19LRVksXG4gICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdE9wZW5JbkVkaXRvclVSTCgpOiBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MuZW52LkVESVRPUl9VUkwgPT09ICdzdHJpbmcnXG4gICAgPyBwcm9jZXNzLmVudi5FRElUT1JfVVJMXG4gICAgOiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZW5JbkVkaXRvclVSTCgpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZUdldEl0ZW0oTE9DQUxfU1RPUkFHRV9PUEVOX0lOX0VESVRPUl9VUkwpO1xuICAgIGlmIChyYXcgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICByZXR1cm4gZ2V0RGVmYXVsdE9wZW5JbkVkaXRvclVSTCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGVEaXNwbGF5TmFtZUFuZEhPQ3MoXG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsLFxuICB0eXBlOiBFbGVtZW50VHlwZSxcbik6IFtzdHJpbmcgfCBudWxsLCBBcnJheTxzdHJpbmc+IHwgbnVsbF0ge1xuICBpZiAoZGlzcGxheU5hbWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG5cbiAgbGV0IGhvY0Rpc3BsYXlOYW1lcyA9IG51bGw7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBFbGVtZW50VHlwZUNsYXNzOlxuICAgIGNhc2UgRWxlbWVudFR5cGVGb3J3YXJkUmVmOlxuICAgIGNhc2UgRWxlbWVudFR5cGVGdW5jdGlvbjpcbiAgICBjYXNlIEVsZW1lbnRUeXBlTWVtbzpcbiAgICAgIGlmIChkaXNwbGF5TmFtZS5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gZGlzcGxheU5hbWUubWF0Y2goL1teKCldKy9nKTtcbiAgICAgICAgaWYgKG1hdGNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgIGRpc3BsYXlOYW1lID0gbWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgICBob2NEaXNwbGF5TmFtZXMgPSBtYXRjaGVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gRWxlbWVudFR5cGVNZW1vKSB7XG4gICAgaWYgKGhvY0Rpc3BsYXlOYW1lcyA9PT0gbnVsbCkge1xuICAgICAgaG9jRGlzcGxheU5hbWVzID0gWydNZW1vJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvY0Rpc3BsYXlOYW1lcy51bnNoaWZ0KCdNZW1vJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IEVsZW1lbnRUeXBlRm9yd2FyZFJlZikge1xuICAgIGlmIChob2NEaXNwbGF5TmFtZXMgPT09IG51bGwpIHtcbiAgICAgIGhvY0Rpc3BsYXlOYW1lcyA9IFsnRm9yd2FyZFJlZiddO1xuICAgIH0gZWxzZSB7XG4gICAgICBob2NEaXNwbGF5TmFtZXMudW5zaGlmdCgnRm9yd2FyZFJlZicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbZGlzcGxheU5hbWUsIGhvY0Rpc3BsYXlOYW1lc107XG59XG5cbi8vIFB1bGxlZCBmcm9tIHJlYWN0LWNvbXBhdFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QtY29tcGF0L2Jsb2IvN2M1ZGUwMGU3Yzg1ZTJmZmQwMTFiZjNhZjAyODk5YjYzZjY5OWQzYS9zcmMvaW5kZXguanMjTDM0OVxuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKHByZXY6IE9iamVjdCwgbmV4dDogT2JqZWN0KTogYm9vbGVhbiB7XG4gIGZvciAoY29uc3QgYXR0cmlidXRlIGluIHByZXYpIHtcbiAgICBpZiAoIShhdHRyaWJ1dGUgaW4gbmV4dCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBpbiBuZXh0KSB7XG4gICAgaWYgKHByZXZbYXR0cmlidXRlXSAhPT0gbmV4dFthdHRyaWJ1dGVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5PYmplY3Qob2JqZWN0OiBPYmplY3QsIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4pOiBhbnkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKHJlZHVjZWQ6IE9iamVjdCwgYXR0cjogYW55KTogYW55ID0+IHtcbiAgICBpZiAocmVkdWNlZCkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVkdWNlZCwgYXR0cikpIHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRbYXR0cl07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlZHVjZWRbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBDb252ZXJ0IGl0ZXJhYmxlIHRvIGFycmF5IGFuZCByZXR1cm4gYXJyYXlbaW5kZXhdXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRSSUNLWVxuICAgICAgICAvLyBEb24ndCB1c2UgWy4uLnNwcmVhZF0gc3ludGF4IGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIC8vIFRoaXMgcHJvamVjdCB1c2VzIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXNwcmVhZCBpbiBcImxvb3NlXCIgbW9kZSB3aGljaCBvbmx5IHdvcmtzIHdpdGggQXJyYXkgdmFsdWVzLlxuICAgICAgICAvLyBPdGhlciB0eXBlcyAoZS5nLiB0eXBlZCBhcnJheXMsIFNldHMpIHdpbGwgbm90IHNwcmVhZCBjb3JyZWN0bHkuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJlZHVjZWQpW2F0dHJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlUGF0aEluT2JqZWN0KFxuICBvYmplY3Q6IE9iamVjdCxcbiAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbikge1xuICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgY29uc3QgbGFzdCA9IHBhdGhbbGVuZ3RoIC0gMV07XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKGlzQXJyYXkocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuc3BsaWNlKCgobGFzdDogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcGFyZW50W2xhc3RdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuYW1lUGF0aEluT2JqZWN0KFxuICBvYmplY3Q6IE9iamVjdCxcbiAgb2xkUGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgbmV3UGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbikge1xuICBjb25zdCBsZW5ndGggPSBvbGRQYXRoLmxlbmd0aDtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZ2V0SW5PYmplY3Qob2JqZWN0LCBvbGRQYXRoLnNsaWNlKDAsIGxlbmd0aCAtIDEpKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBjb25zdCBsYXN0T2xkID0gb2xkUGF0aFtsZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGxhc3ROZXcgPSBuZXdQYXRoW2xlbmd0aCAtIDFdO1xuICAgICAgcGFyZW50W2xhc3ROZXddID0gcGFyZW50W2xhc3RPbGRdO1xuICAgICAgaWYgKGlzQXJyYXkocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuc3BsaWNlKCgobGFzdE9sZDogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcGFyZW50W2xhc3RPbGRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SW5PYmplY3QoXG4gIG9iamVjdDogT2JqZWN0LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICB2YWx1ZTogYW55LFxuKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICBjb25zdCBsYXN0ID0gcGF0aFtsZW5ndGggLSAxXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZ2V0SW5PYmplY3Qob2JqZWN0LCBwYXRoLnNsaWNlKDAsIGxlbmd0aCAtIDEpKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgRGF0YVR5cGUgPVxuICB8ICdhcnJheSdcbiAgfCAnYXJyYXlfYnVmZmVyJ1xuICB8ICdiaWdpbnQnXG4gIHwgJ2Jvb2xlYW4nXG4gIHwgJ2RhdGFfdmlldydcbiAgfCAnZGF0ZSdcbiAgfCAnZnVuY3Rpb24nXG4gIHwgJ2h0bWxfYWxsX2NvbGxlY3Rpb24nXG4gIHwgJ2h0bWxfZWxlbWVudCdcbiAgfCAnaW5maW5pdHknXG4gIHwgJ2l0ZXJhdG9yJ1xuICB8ICdvcGFxdWVfaXRlcmF0b3InXG4gIHwgJ25hbidcbiAgfCAnbnVsbCdcbiAgfCAnbnVtYmVyJ1xuICB8ICdvYmplY3QnXG4gIHwgJ3JlYWN0X2VsZW1lbnQnXG4gIHwgJ3JlZ2V4cCdcbiAgfCAnc3RyaW5nJ1xuICB8ICdzeW1ib2wnXG4gIHwgJ3R5cGVkX2FycmF5J1xuICB8ICd1bmRlZmluZWQnXG4gIHwgJ3Vua25vd24nO1xuXG4vKipcbiAqIEdldCBhIGVuaGFuY2VkL2FydGlmaWNpYWwgdHlwZSBzdHJpbmcgYmFzZWQgb24gdGhlIG9iamVjdCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YVR5cGUoZGF0YTogT2JqZWN0KTogRGF0YVR5cGUge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaWYgKGlzRWxlbWVudChkYXRhKSkge1xuICAgIHJldHVybiAncmVhY3RfZWxlbWVudCc7XG4gIH1cblxuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gJ2h0bWxfZWxlbWVudCc7XG4gIH1cblxuICBjb25zdCB0eXBlID0gdHlwZW9mIGRhdGE7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICByZXR1cm4gJ2JpZ2ludCc7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiAnZnVuY3Rpb24nO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnbmFuJztcbiAgICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0Zpbml0ZShkYXRhKSkge1xuICAgICAgICByZXR1cm4gJ2luZmluaXR5JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIH1cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLmNvbnN0cnVjdG9yLCAnQllURVNfUEVSX0VMRU1FTlQnKVxuICAgICAgICAgID8gJ3R5cGVkX2FycmF5J1xuICAgICAgICAgIDogJ2RhdGFfdmlldyc7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuY29uc3RydWN0b3IgJiYgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInKSB7XG4gICAgICAgIC8vIEhBQ0sgVGhpcyBBcnJheUJ1ZmZlciBjaGVjayBpcyBncm9zczsgaXMgdGhlcmUgYSBiZXR0ZXIgd2F5P1xuICAgICAgICAvLyBXZSBjb3VsZCB0cnkgdG8gY3JlYXRlIGEgbmV3IERhdGFWaWV3IHdpdGggdGhlIHZhbHVlLlxuICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IGVycm9yLCB3ZSBrbm93IGl0J3MgYW4gQXJyYXlCdWZmZXIsXG4gICAgICAgIC8vIGJ1dCB0aGlzIHNlZW1zIGtpbmQgb2YgYXdrd2FyZCBhbmQgZXhwZW5zaXZlLlxuICAgICAgICByZXR1cm4gJ2FycmF5X2J1ZmZlcic7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgaWYgKCFpdGVyYXRvcikge1xuICAgICAgICAgIC8vIFByb3hpZXMgbWlnaHQgYnJlYWsgYXNzdW1wdG9pbnMgYWJvdXQgaXRlcmF0b3JzLlxuICAgICAgICAgIC8vIFNlZSBnaXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMTY1NFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvciA9PT0gZGF0YSA/ICdvcGFxdWVfaXRlcmF0b3InIDogJ2l0ZXJhdG9yJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLmNvbnN0cnVjdG9yICYmIGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1JlZ0V4cCcpIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdG9TdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKTtcbiAgICAgICAgaWYgKHRvU3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgSFRNTEFsbENvbGxlY3Rpb25dJykge1xuICAgICAgICAgIHJldHVybiAnaHRtbF9hbGxfY29sbGVjdGlvbic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGlmIChcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuICdodG1sX2FsbF9jb2xsZWN0aW9uJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWVGb3JSZWFjdEVsZW1lbnQoXG4gIGVsZW1lbnQ6IFJlYWN0JEVsZW1lbnQ8YW55Pixcbik6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCBlbGVtZW50VHlwZSA9IHR5cGVPZihlbGVtZW50KTtcbiAgc3dpdGNoIChlbGVtZW50VHlwZSkge1xuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuICdDb250ZXh0Q29uc3VtZXInO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuICdDb250ZXh0UHJvdmlkZXInO1xuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiAnRm9yd2FyZFJlZic7XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuICAgIGNhc2UgTGF6eTpcbiAgICAgIHJldHVybiAnTGF6eSc7XG4gICAgY2FzZSBNZW1vOlxuICAgICAgcmV0dXJuICdNZW1vJztcbiAgICBjYXNlIFBvcnRhbDpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG4gICAgY2FzZSBTdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICBjYXNlIFN1c3BlbnNlOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG4gICAgY2FzZSBTdXNwZW5zZUxpc3Q6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnN0IHt0eXBlfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUodHlwZSwgJ0Fub255bW91cycpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdOb3RJbXBsZW1lbnRlZEluRGV2dG9vbHMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdFbGVtZW50JztcbiAgICAgIH1cbiAgfVxufVxuXG5jb25zdCBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIID0gNTA7XG5cbmZ1bmN0aW9uIHRydW5jYXRlRm9yRGlzcGxheShcbiAgc3RyaW5nOiBzdHJpbmcsXG4gIGxlbmd0aDogbnVtYmVyID0gTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCxcbikge1xuICBpZiAoc3RyaW5nLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIGxlbmd0aCkgKyAn4oCmJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIG1pbWljIENocm9tZSdzIGlubGluZSBwcmV2aWV3IGZvciB2YWx1ZXMuXG4vLyBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyB2YWx1ZS4uLlxuLy8gICB7XG4vLyAgICAgIGZvbzogMTIzLFxuLy8gICAgICBiYXI6IFwiYWJjXCIsXG4vLyAgICAgIGJhejogW3RydWUsIGZhbHNlXSxcbi8vICAgICAgcXV4OiB7IGFiOiAxLCBjZDogMiB9XG4vLyAgIH07XG4vL1xuLy8gV291bGQgc2hvdyBhIHByZXZpZXcgb2YuLi5cbi8vICAge2ZvbzogMTIzLCBiYXI6IFwiYWJjXCIsIGJhejogQXJyYXkoMiksIHF1eDoge+KApn19XG4vL1xuLy8gQW5kIHRoZSBmb2xsb3dpbmcgdmFsdWUuLi5cbi8vICAgW1xuLy8gICAgIDEyMyxcbi8vICAgICBcImFiY1wiLFxuLy8gICAgIFt0cnVlLCBmYWxzZV0sXG4vLyAgICAgeyBmb286IDEyMywgYmFyOiBcImFiY1wiIH1cbi8vICAgXTtcbi8vXG4vLyBXb3VsZCBzaG93IGEgcHJldmlldyBvZi4uLlxuLy8gICBbMTIzLCBcImFiY1wiLCBBcnJheSgyKSwge+KApn1dXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0YUZvclByZXZpZXcoXG4gIGRhdGE6IGFueSxcbiAgc2hvd0Zvcm1hdHRlZFZhbHVlOiBib29sZWFuLFxuKTogc3RyaW5nIHtcbiAgaWYgKGRhdGEgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIG1ldGEudHlwZSkpIHtcbiAgICByZXR1cm4gc2hvd0Zvcm1hdHRlZFZhbHVlXG4gICAgICA/IGRhdGFbbWV0YS5wcmV2aWV3X2xvbmddXG4gICAgICA6IGRhdGFbbWV0YS5wcmV2aWV3X3Nob3J0XTtcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSBnZXREYXRhVHlwZShkYXRhKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdodG1sX2VsZW1lbnQnOlxuICAgICAgcmV0dXJuIGA8JHt0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpfSAvPmA7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHRydW5jYXRlRm9yRGlzcGxheShcbiAgICAgICAgYMaSICR7dHlwZW9mIGRhdGEubmFtZSA9PT0gJ2Z1bmN0aW9uJyA/ICcnIDogZGF0YS5uYW1lfSgpIHt9YCxcbiAgICAgICk7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBgXCIke2RhdGF9XCJgO1xuICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICByZXR1cm4gdHJ1bmNhdGVGb3JEaXNwbGF5KGRhdGEudG9TdHJpbmcoKSArICduJyk7XG4gICAgY2FzZSAncmVnZXhwJzpcbiAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50b1N0cmluZygpKTtcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIHRydW5jYXRlRm9yRGlzcGxheShkYXRhLnRvU3RyaW5nKCkpO1xuICAgIGNhc2UgJ3JlYWN0X2VsZW1lbnQnOlxuICAgICAgcmV0dXJuIGA8JHt0cnVuY2F0ZUZvckRpc3BsYXkoXG4gICAgICAgIGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50KGRhdGEpIHx8ICdVbmtub3duJyxcbiAgICAgICl9IC8+YDtcbiAgICBjYXNlICdhcnJheV9idWZmZXInOlxuICAgICAgcmV0dXJuIGBBcnJheUJ1ZmZlcigke2RhdGEuYnl0ZUxlbmd0aH0pYDtcbiAgICBjYXNlICdkYXRhX3ZpZXcnOlxuICAgICAgcmV0dXJuIGBEYXRhVmlldygke2RhdGEuYnVmZmVyLmJ5dGVMZW5ndGh9KWA7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKHNob3dGb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICBsZXQgZm9ybWF0dGVkID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9ICcsICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcm1hdHRlZCArPSBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhW2ldLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKGZvcm1hdHRlZC5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgWyR7dHJ1bmNhdGVGb3JEaXNwbGF5KGZvcm1hdHRlZCl9XWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIG1ldGEuc2l6ZSlcbiAgICAgICAgICA/IGRhdGFbbWV0YS5zaXplXVxuICAgICAgICAgIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBgQXJyYXkoJHtsZW5ndGh9KWA7XG4gICAgICB9XG4gICAgY2FzZSAndHlwZWRfYXJyYXknOlxuICAgICAgY29uc3Qgc2hvcnROYW1lID0gYCR7ZGF0YS5jb25zdHJ1Y3Rvci5uYW1lfSgke2RhdGEubGVuZ3RofSlgO1xuICAgICAgaWYgKHNob3dGb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICBsZXQgZm9ybWF0dGVkID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9ICcsICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcm1hdHRlZCArPSBkYXRhW2ldO1xuICAgICAgICAgIGlmIChmb3JtYXR0ZWQubGVuZ3RoID4gTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBkb2luZyBhIGxvdCBvZiB1bm5lY2Vzc2FyeSBpdGVyYXRpb24uLi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7c2hvcnROYW1lfSBbJHt0cnVuY2F0ZUZvckRpc3BsYXkoZm9ybWF0dGVkKX1dYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaG9ydE5hbWU7XG4gICAgICB9XG4gICAgY2FzZSAnaXRlcmF0b3InOlxuICAgICAgY29uc3QgbmFtZSA9IGRhdGEuY29uc3RydWN0b3IubmFtZTtcblxuICAgICAgaWYgKHNob3dGb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICAvLyBUUklDS1lcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFsuLi5zcHJlYWRdIHN5bnRheCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICAvLyBUaGlzIHByb2plY3QgdXNlcyBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1zcHJlYWQgaW4gXCJsb29zZVwiIG1vZGUgd2hpY2ggb25seSB3b3JrcyB3aXRoIEFycmF5IHZhbHVlcy5cbiAgICAgICAgLy8gT3RoZXIgdHlwZXMgKGUuZy4gdHlwZWQgYXJyYXlzLCBTZXRzKSB3aWxsIG5vdCBzcHJlYWQgY29ycmVjdGx5LlxuICAgICAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oZGF0YSk7XG5cbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZW50cnlPckVudHJpZXMgPSBhcnJheVtpXTtcblxuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9ICcsICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVFJJQ0tZXG4gICAgICAgICAgLy8gQnJvd3NlcnMgZGlzcGxheSBNYXBzIGFuZCBTZXRzIGRpZmZlcmVudGx5LlxuICAgICAgICAgIC8vIFRvIG1pbWljIHRoZWlyIGJlaGF2aW9yLCBkZXRlY3QgaWYgd2UndmUgYmVlbiBnaXZlbiBhbiBlbnRyaWVzIHR1cGxlLlxuICAgICAgICAgIC8vICAgTWFwKDIpIHtcImFiY1wiID0+IDEyMywgXCJkZWZcIiA9PiAxMjN9XG4gICAgICAgICAgLy8gICBTZXQoMikge1wiYWJjXCIsIDEyM31cbiAgICAgICAgICBpZiAoaXNBcnJheShlbnRyeU9yRW50cmllcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGVudHJ5T3JFbnRyaWVzWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0RGF0YUZvclByZXZpZXcoZW50cnlPckVudHJpZXNbMV0sIGZhbHNlKTtcbiAgICAgICAgICAgIGZvcm1hdHRlZCArPSBgJHtrZXl9ID0+ICR7dmFsdWV9YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGVudHJ5T3JFbnRyaWVzLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZvcm1hdHRlZC5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke25hbWV9KCR7ZGF0YS5zaXplfSkgeyR7dHJ1bmNhdGVGb3JEaXNwbGF5KGZvcm1hdHRlZCl9fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX0oJHtkYXRhLnNpemV9KWA7XG4gICAgICB9XG4gICAgY2FzZSAnb3BhcXVlX2l0ZXJhdG9yJzoge1xuICAgICAgcmV0dXJuIGRhdGFbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICB9XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKGdldEFsbEVudW1lcmFibGVLZXlzKGRhdGEpKS5zb3J0KGFscGhhU29ydEtleXMpO1xuXG4gICAgICAgIGxldCBmb3JtYXR0ZWQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZCArPSAnLCAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3JtYXR0ZWQgKz0gYCR7a2V5LnRvU3RyaW5nKCl9OiAke2Zvcm1hdERhdGFGb3JQcmV2aWV3KFxuICAgICAgICAgICAgZGF0YVtrZXldLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgKX1gO1xuICAgICAgICAgIGlmIChmb3JtYXR0ZWQubGVuZ3RoID4gTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBkb2luZyBhIGxvdCBvZiB1bm5lY2Vzc2FyeSBpdGVyYXRpb24uLi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHske3RydW5jYXRlRm9yRGlzcGxheShmb3JtYXR0ZWQpfX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICd74oCmfSc7XG4gICAgICB9XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdpbmZpbml0eSc6XG4gICAgY2FzZSAnbmFuJzpcbiAgICBjYXNlICdudWxsJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoU3RyaW5nKGRhdGEpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAndW5zZXJpYWxpemFibGUnO1xuICAgICAgfVxuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQWNBO0FBQ0E7QUFTQTtBQUNBO0FBUUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQXZGQTtBQXlGQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFkQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTBCQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBM0RBO0FBNkRBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQ0E7QUFtQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvSUE7QUFnSkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/utils.js\n");

/***/ }),

/***/ "../react-reconciler/src/ReactWorkTags.js":
/*!************************************************!*\
  !*** ../react-reconciler/src/ReactWorkTags.js ***!
  \************************************************/
/*! exports provided: FunctionComponent, ClassComponent, IndeterminateComponent, HostRoot, HostPortal, HostComponent, HostText, Fragment, Mode, ContextConsumer, ContextProvider, ForwardRef, Profiler, SuspenseComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, DehydratedFragment, SuspenseListComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionComponent\", function() { return FunctionComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassComponent\", function() { return ClassComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IndeterminateComponent\", function() { return IndeterminateComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HostRoot\", function() { return HostRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HostPortal\", function() { return HostPortal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HostComponent\", function() { return HostComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HostText\", function() { return HostText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return Fragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mode\", function() { return Mode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ContextConsumer\", function() { return ContextConsumer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ContextProvider\", function() { return ContextProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ForwardRef\", function() { return ForwardRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Profiler\", function() { return Profiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SuspenseComponent\", function() { return SuspenseComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MemoComponent\", function() { return MemoComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimpleMemoComponent\", function() { return SimpleMemoComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LazyComponent\", function() { return LazyComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IncompleteClassComponent\", function() { return IncompleteClassComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DehydratedFragment\", function() { return DehydratedFragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SuspenseListComponent\", function() { return SuspenseListComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScopeComponent\", function() { return ScopeComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OffscreenComponent\", function() { return OffscreenComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LegacyHiddenComponent\", function() { return LegacyHiddenComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CacheComponent\", function() { return CacheComponent; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst FunctionComponent = 0;\nconst ClassComponent = 1;\nconst IndeterminateComponent = 2; // Before we know whether it is function or class\n\nconst HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\nconst HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\nconst HostComponent = 5;\nconst HostText = 6;\nconst Fragment = 7;\nconst Mode = 8;\nconst ContextConsumer = 9;\nconst ContextProvider = 10;\nconst ForwardRef = 11;\nconst Profiler = 12;\nconst SuspenseComponent = 13;\nconst MemoComponent = 14;\nconst SimpleMemoComponent = 15;\nconst LazyComponent = 16;\nconst IncompleteClassComponent = 17;\nconst DehydratedFragment = 18;\nconst SuspenseListComponent = 19;\nconst ScopeComponent = 21;\nconst OffscreenComponent = 22;\nconst LegacyHiddenComponent = 23;\nconst CacheComponent = 24;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RXb3JrVGFncy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdFdvcmtUYWdzLmpzPzMzZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCB0eXBlIFdvcmtUYWcgPVxuICB8IDBcbiAgfCAxXG4gIHwgMlxuICB8IDNcbiAgfCA0XG4gIHwgNVxuICB8IDZcbiAgfCA3XG4gIHwgOFxuICB8IDlcbiAgfCAxMFxuICB8IDExXG4gIHwgMTJcbiAgfCAxM1xuICB8IDE0XG4gIHwgMTVcbiAgfCAxNlxuICB8IDE3XG4gIHwgMThcbiAgfCAxOVxuICB8IDIwXG4gIHwgMjFcbiAgfCAyMlxuICB8IDIzXG4gIHwgMjQ7XG5cbmV4cG9ydCBjb25zdCBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG5leHBvcnQgY29uc3QgQ2xhc3NDb21wb25lbnQgPSAxO1xuZXhwb3J0IGNvbnN0IEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAyOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uIG9yIGNsYXNzXG5leHBvcnQgY29uc3QgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbmV4cG9ydCBjb25zdCBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbmV4cG9ydCBjb25zdCBIb3N0Q29tcG9uZW50ID0gNTtcbmV4cG9ydCBjb25zdCBIb3N0VGV4dCA9IDY7XG5leHBvcnQgY29uc3QgRnJhZ21lbnQgPSA3O1xuZXhwb3J0IGNvbnN0IE1vZGUgPSA4O1xuZXhwb3J0IGNvbnN0IENvbnRleHRDb25zdW1lciA9IDk7XG5leHBvcnQgY29uc3QgQ29udGV4dFByb3ZpZGVyID0gMTA7XG5leHBvcnQgY29uc3QgRm9yd2FyZFJlZiA9IDExO1xuZXhwb3J0IGNvbnN0IFByb2ZpbGVyID0gMTI7XG5leHBvcnQgY29uc3QgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcbmV4cG9ydCBjb25zdCBNZW1vQ29tcG9uZW50ID0gMTQ7XG5leHBvcnQgY29uc3QgU2ltcGxlTWVtb0NvbXBvbmVudCA9IDE1O1xuZXhwb3J0IGNvbnN0IExhenlDb21wb25lbnQgPSAxNjtcbmV4cG9ydCBjb25zdCBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSAxNztcbmV4cG9ydCBjb25zdCBEZWh5ZHJhdGVkRnJhZ21lbnQgPSAxODtcbmV4cG9ydCBjb25zdCBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSAxOTtcbmV4cG9ydCBjb25zdCBTY29wZUNvbXBvbmVudCA9IDIxO1xuZXhwb3J0IGNvbnN0IE9mZnNjcmVlbkNvbXBvbmVudCA9IDIyO1xuZXhwb3J0IGNvbnN0IExlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IDIzO1xuZXhwb3J0IGNvbnN0IENhY2hlQ29tcG9uZW50ID0gMjQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBb0NBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-reconciler/src/ReactWorkTags.js\n");

/***/ }),

/***/ "../shared/ReactSymbols.js":
/*!*********************************!*\
  !*** ../shared/ReactSymbols.js ***!
  \*********************************/
/*! exports provided: REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE, REACT_FRAGMENT_TYPE, REACT_STRICT_MODE_TYPE, REACT_PROFILER_TYPE, REACT_PROVIDER_TYPE, REACT_CONTEXT_TYPE, REACT_FORWARD_REF_TYPE, REACT_SUSPENSE_TYPE, REACT_SUSPENSE_LIST_TYPE, REACT_MEMO_TYPE, REACT_LAZY_TYPE, REACT_SCOPE_TYPE, REACT_DEBUG_TRACING_MODE_TYPE, REACT_OFFSCREEN_TYPE, REACT_LEGACY_HIDDEN_TYPE, REACT_CACHE_TYPE, getIteratorFn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_ELEMENT_TYPE\", function() { return REACT_ELEMENT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_PORTAL_TYPE\", function() { return REACT_PORTAL_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_FRAGMENT_TYPE\", function() { return REACT_FRAGMENT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_STRICT_MODE_TYPE\", function() { return REACT_STRICT_MODE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_PROFILER_TYPE\", function() { return REACT_PROFILER_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_PROVIDER_TYPE\", function() { return REACT_PROVIDER_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_CONTEXT_TYPE\", function() { return REACT_CONTEXT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_FORWARD_REF_TYPE\", function() { return REACT_FORWARD_REF_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_SUSPENSE_TYPE\", function() { return REACT_SUSPENSE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_SUSPENSE_LIST_TYPE\", function() { return REACT_SUSPENSE_LIST_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_MEMO_TYPE\", function() { return REACT_MEMO_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_LAZY_TYPE\", function() { return REACT_LAZY_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_SCOPE_TYPE\", function() { return REACT_SCOPE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_DEBUG_TRACING_MODE_TYPE\", function() { return REACT_DEBUG_TRACING_MODE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_OFFSCREEN_TYPE\", function() { return REACT_OFFSCREEN_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_LEGACY_HIDDEN_TYPE\", function() { return REACT_LEGACY_HIDDEN_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACT_CACHE_TYPE\", function() { return REACT_CACHE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIteratorFn\", function() { return getIteratorFn; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nlet REACT_ELEMENT_TYPE = 0xeac7;\nlet REACT_PORTAL_TYPE = 0xeaca;\nlet REACT_FRAGMENT_TYPE = 0xeacb;\nlet REACT_STRICT_MODE_TYPE = 0xeacc;\nlet REACT_PROFILER_TYPE = 0xead2;\nlet REACT_PROVIDER_TYPE = 0xeacd;\nlet REACT_CONTEXT_TYPE = 0xeace;\nlet REACT_FORWARD_REF_TYPE = 0xead0;\nlet REACT_SUSPENSE_TYPE = 0xead1;\nlet REACT_SUSPENSE_LIST_TYPE = 0xead8;\nlet REACT_MEMO_TYPE = 0xead3;\nlet REACT_LAZY_TYPE = 0xead4;\nlet REACT_SCOPE_TYPE = 0xead7;\nlet REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\nlet REACT_OFFSCREEN_TYPE = 0xeae2;\nlet REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\nlet REACT_CACHE_TYPE = 0xeae4;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  const symbolFor = Symbol.for;\n  REACT_ELEMENT_TYPE = symbolFor('react.element');\n  REACT_PORTAL_TYPE = symbolFor('react.portal');\n  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');\n  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n  REACT_PROFILER_TYPE = symbolFor('react.profiler');\n  REACT_PROVIDER_TYPE = symbolFor('react.provider');\n  REACT_CONTEXT_TYPE = symbolFor('react.context');\n  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n  REACT_MEMO_TYPE = symbolFor('react.memo');\n  REACT_LAZY_TYPE = symbolFor('react.lazy');\n  REACT_SCOPE_TYPE = symbolFor('react.scope');\n  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n  REACT_CACHE_TYPE = symbolFor('react.cache');\n}\n\nconst MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  const maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL1JlYWN0U3ltYm9scy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zaGFyZWQvUmVhY3RTeW1ib2xzLmpzP2MwMjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuZXhwb3J0IGxldCBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG5leHBvcnQgbGV0IFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0IGxldCBSRUFDVF9GUkFHTUVOVF9UWVBFID0gMHhlYWNiO1xuZXhwb3J0IGxldCBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xuZXhwb3J0IGxldCBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xuZXhwb3J0IGxldCBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xuZXhwb3J0IGxldCBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG5leHBvcnQgbGV0IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnQgbGV0IFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG5leHBvcnQgbGV0IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbmV4cG9ydCBsZXQgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xuZXhwb3J0IGxldCBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG5leHBvcnQgbGV0IFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG5leHBvcnQgbGV0IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xuZXhwb3J0IGxldCBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbmV4cG9ydCBsZXQgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuZXhwb3J0IGxldCBSRUFDVF9DQUNIRV9UWVBFID0gMHhlYWU0O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIGNvbnN0IHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xuICBSRUFDVF9DQUNIRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jYWNoZScpO1xufVxuXG5jb25zdCBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbmNvbnN0IEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlOiA/YW55KTogPygpID0+ID9JdGVyYXRvcjwqPiB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG1heWJlSXRlcmF0b3IgPVxuICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgIG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../shared/ReactSymbols.js\n");

/***/ }),

/***/ "../shared/hasOwnProperty.js":
/*!***********************************!*\
  !*** ../shared/hasOwnProperty.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/* harmony default export */ __webpack_exports__[\"default\"] = (hasOwnProperty);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL2hhc093blByb3BlcnR5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NoYXJlZC9oYXNPd25Qcm9wZXJ0eS5qcz9iYmM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmV4cG9ydCBkZWZhdWx0IGhhc093blByb3BlcnR5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7OztBQVNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../shared/hasOwnProperty.js\n");

/***/ }),

/***/ "../shared/isArray.js":
/*!****************************!*\
  !*** ../shared/isArray.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (isArray);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL2lzQXJyYXkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc2hhcmVkL2lzQXJyYXkuanM/ZDkzYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuZGVjbGFyZSBmdW5jdGlvbiBpc0FycmF5KGE6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzKEFycmF5LmlzQXJyYXkoYSkpO1xuXG5jb25zdCBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGlzQXJyYXkoYTogbWl4ZWQpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7OztBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../shared/isArray.js\n");

/***/ }),

/***/ "../shared/objectIs.js":
/*!*****************************!*\
  !*** ../shared/objectIs.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nconst objectIs = typeof Object.is === 'function' ? Object.is : is;\n/* harmony default export */ __webpack_exports__[\"default\"] = (objectIs);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL29iamVjdElzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NoYXJlZC9vYmplY3RJcy5qcz9kMWNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4OiBhbnksIHk6IGFueSkge1xuICByZXR1cm4gKFxuICAgICh4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICk7XG59XG5cbmNvbnN0IG9iamVjdElzOiAoeDogYW55LCB5OiBhbnkpID0+IGJvb2xlYW4gPVxuICB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdElzO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7Ozs7QUFTQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../shared/objectIs.js\n");

/***/ }),

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_devtools_shared_src_backend_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/backend/renderer */ \"../react-devtools-shared/src/backend/renderer.js\");\n/**\n * In order to support reload-and-profile functionality, the renderer needs to be injected before any other scripts.\n * Since it is a complex file (with imports) we can't just toString() it like we do with the hook itself,\n * So this entry point (one of the web_accessible_resources) provides a way to eagerly inject it.\n * The hook will look for the presence of a global __REACT_DEVTOOLS_ATTACH__ and attach an injected renderer early.\n * The normal case (not a reload-and-profile) will not make use of this entry point though.\n *\n * \n */\n\nObject.defineProperty(window, '__REACT_DEVTOOLS_ATTACH__', {\n  enumerable: false,\n  // This property needs to be configurable to allow third-party integrations\n  // to attach their own renderer. Note that using third-party integrations\n  // is not officially supported. Use at your own risk.\n  configurable: true,\n\n  get() {\n    return react_devtools_shared_src_backend_renderer__WEBPACK_IMPORTED_MODULE_0__[\"attach\"];\n  }\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVuZGVyZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIuanM/ODhjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVsb2FkLWFuZC1wcm9maWxlIGZ1bmN0aW9uYWxpdHksIHRoZSByZW5kZXJlciBuZWVkcyB0byBiZSBpbmplY3RlZCBiZWZvcmUgYW55IG90aGVyIHNjcmlwdHMuXG4gKiBTaW5jZSBpdCBpcyBhIGNvbXBsZXggZmlsZSAod2l0aCBpbXBvcnRzKSB3ZSBjYW4ndCBqdXN0IHRvU3RyaW5nKCkgaXQgbGlrZSB3ZSBkbyB3aXRoIHRoZSBob29rIGl0c2VsZixcbiAqIFNvIHRoaXMgZW50cnkgcG9pbnQgKG9uZSBvZiB0aGUgd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzKSBwcm92aWRlcyBhIHdheSB0byBlYWdlcmx5IGluamVjdCBpdC5cbiAqIFRoZSBob29rIHdpbGwgbG9vayBmb3IgdGhlIHByZXNlbmNlIG9mIGEgZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfQVRUQUNIX18gYW5kIGF0dGFjaCBhbiBpbmplY3RlZCByZW5kZXJlciBlYXJseS5cbiAqIFRoZSBub3JtYWwgY2FzZSAobm90IGEgcmVsb2FkLWFuZC1wcm9maWxlKSB3aWxsIG5vdCBtYWtlIHVzZSBvZiB0aGlzIGVudHJ5IHBvaW50IHRob3VnaC5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7YXR0YWNofSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvcmVuZGVyZXInO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gIHdpbmRvdyxcbiAgJ19fUkVBQ1RfREVWVE9PTFNfQVRUQUNIX18nLFxuICAoe1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gYmUgY29uZmlndXJhYmxlIHRvIGFsbG93IHRoaXJkLXBhcnR5IGludGVncmF0aW9uc1xuICAgIC8vIHRvIGF0dGFjaCB0aGVpciBvd24gcmVuZGVyZXIuIE5vdGUgdGhhdCB1c2luZyB0aGlyZC1wYXJ0eSBpbnRlZ3JhdGlvbnNcbiAgICAvLyBpcyBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gYXR0YWNoO1xuICAgIH0sXG4gIH06IE9iamVjdCksXG4pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7Ozs7Ozs7OztBQVVBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVRBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/renderer.js\n");

/***/ })

/******/ });